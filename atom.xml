<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pipi`Blog🍉🍉</title>
  
  <subtitle>欢迎大家的访问哦❤</subtitle>
  <link href="https://pipi1002.github.io/atom.xml" rel="self"/>
  
  <link href="https://pipi1002.github.io/"/>
  <updated>2024-04-08T04:14:55.102Z</updated>
  <id>https://pipi1002.github.io/</id>
  
  <author>
    <name>Pipi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AssemblyLanguage</title>
    <link href="https://pipi1002.github.io/2024/03/03/AssemblyLanguage/"/>
    <id>https://pipi1002.github.io/2024/03/03/AssemblyLanguage/</id>
    <published>2024-03-03T05:28:02.000Z</published>
    <updated>2024-04-08T04:14:55.102Z</updated>
    
    <content type="html"><![CDATA[<h1id="汇编语言----直接在硬件之上工作的编程语言">汇编语言----直接在硬件之上工作的编程语言</h1><h2 id="汇编指令机器码的助记符">汇编指令(机器码的助记符)</h2><h3id="cpu对存储器的读写逻辑上划分为">cpu对存储器的读写逻辑上划分为：</h3><ul><li><p>地址总线：地址总线上能传送多少个不同的信息，cpu就可以对多少个存储单元进行寻址。一个cpu有N根地址总线，则可以说这个cpu的地址总线的宽度为N，这样的cpu最多可以寻找2的N次方个内存单元(8086/8088cpu的cpu地址总线宽度为20位，寻址能力为<spanclass="math inline">\(2^{20}=1024*1024字节=1024K字节=1M字节\)</span>)(8086/80286--16位，80386--32位)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">寻址能力的判断:</span><br><span class="line">寻址能力=2的N次方(N为地址总线的条数)</span><br><span class="line">32位地址总线为例子，cpu的寻址能力2^32Bit=4G</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bit单位间的换算关系:</span><br><span class="line">1字节=1byte=1B=8位</span><br><span class="line">1KB=1024B</span><br><span class="line">1MB=1024KB</span><br><span class="line">1GB=1024MB</span><br><span class="line"></span><br><span class="line">1TB=1024GB</span><br><span class="line">1PB=1024TB</span><br></pre></td></tr></table></figure></li><li><p>数据总线：cpu和内存或其他器件之间的数据传送是通过数据总线来进行的，数据总线的宽度决定了cpu和外界的数据传送速度</p></li><li><p>控制总线：cpu对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着cpu提供了对外部器件的多少种控制</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171325985.png"alt="屏幕截图_20240303_164348" /><figcaption aria-hidden="true">屏幕截图_20240303_164348</figcaption></figure></li></ul><h3 id="原码反码补码">原码，反码，补码：</h3><ul><li><p>原码：最高位(符号位0为正，1为负)+低位(数值)</p></li><li><p>反码：分正反</p></li><li><p>补码：分正反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用8位表示7的原码: 00000111</span><br><span class="line">-7:10000111</span><br><span class="line">用8位表示7的反码:</span><br><span class="line">1.对于正数来讲反码和原码是一样的 00000111</span><br><span class="line">2.对于负数来讲除最高位以外,其余位进行取反 -7:11111000</span><br><span class="line">用8位表示7的补码:</span><br><span class="line">1.对于正数来讲补码和原码是一样的 00000111</span><br><span class="line">2.对于负数来讲补码等于反码加1 11111000+1-&gt;11111001</span><br></pre></td></tr></table></figure></li></ul><h3 id="十进制转化bcd码">十进制转化BCD码:</h3><h6 id="bcd码用四位二进制表示09数据">bcd码：用四位二进制表示0~9数据</h6><h5id="也就是从右向左每四位分别表示十进制的个位十位百位...">也就是从右向左每四位分别表示十进制的个位，十位，百位...</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171324934.png" /></p><h3id="寄存器16位寄存器组可以存放两个字节的数据">寄存器(16位寄存器组，可以存放两个字节的数据):</h3><ul><li>8个通用寄存器<ul><li>累加器AX：算数运算的主要寄存器(AH,AL两个独立寄存器，为高位和低位)</li><li>基址寄存器BX：存放地址的偏移地址</li><li>计数寄存器CX：作为循环和串操作等指令中的计数器，存放循环次数或重复次数</li><li>数据寄存器DX：常用来存放双字长数据的高16位，或在间接寻址的I/O指令中存放I/O端口地址</li><li>堆栈指针寄存器SP：用以指出在堆栈段中当前栈顶的地址</li><li>基址指针寄存器BP：指出要处理的数据在堆栈段中的基地址</li></ul></li><li>段寄存器<ul><li>代码段寄存器CS：用于存放当前正在运行的程序。存放当前执行程序所在段的段地址，<strong>将其内容左移4位再加上IP指针的内容即为下一条执行指令的地址。</strong></li><li>堆栈段寄存器SS：是内存中开辟的专用存储区，<strong>用来暂时保存寄存器中的数据</strong>。存放当前堆栈段的段地址，将其内容左移4位再加上SP的内容即为<strong>栈顶地址</strong></li><li>数据段寄存器DS：<strong>存放当前数据段的段地址</strong>，将其内容左移4为再加上计算所得的偏移地址即为对数据段指定单元进行读/写的地址。</li><li>附加数据段寄存器ES：是附加的数据，在串操作指令中用于存放目的操作数</li></ul></li><li>标志寄存器FLAGS</li><li>指令指针寄存器IP：CS和IP两个关键的寄存器，cpu将CS:IP指向的内容当作指令执行</li></ul><h3 id="八位标志寄存器信息如下">八位标志寄存器信息如下</h3><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171325139.png" /></p><h2id="寻址方式获取操作数所在地址的寻址方式">8086/8088寻址方式(获取操作数所在地址的寻址方式)：</h2><ul><li><p>操作数分为</p><ul><li><p>立即数:立即寻址<code>助剂符 目的操作数(本身含有地址的含义) 源操作数(立即寻址只针对源操作数)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,0FFFH </span><br></pre></td></tr></table></figure></li><li><p>存储器操作数</p><ul><li><p>直接寻址”【(存放数据的偏移地址,也可以进行段重设)】“</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV BL,[1200H] ;默认DS段</span><br><span class="line">MOV BL,ES:[1200H] ;段重设</span><br></pre></td></tr></table></figure></li><li><p>寄存器间接寻址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[SI] ;SI内容为1200H,把1200H所对应的内容传给AX</span><br><span class="line">    BX ;默认在数据段DS</span><br><span class="line">    BP ;默认在堆栈段SS</span><br><span class="line">    SI ;DS</span><br><span class="line">    DI ;DS</span><br><span class="line">    SX ;DS</span><br></pre></td></tr></table></figure></li><li><p>寄存器相对寻址(在寄存器寻址的基础上再加一个相对位移量)用来存取表格或一维数组里的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,DATA[BX] ;DATA+[BX]如果DATA=0010H,BX=1200H,DS=1000H则完整地址=1000H:0010H+1200H=1000H:1210H=11210H</span><br><span class="line">;DATA[BX] [BX]DATA DATA+[BX] [BX]+DATA [DATA+BX] [BX+DATA]这几种写法都行</span><br></pre></td></tr></table></figure></li><li><p>基址变址寻址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX [BX(BP)][SI(DI)] ;基准变址相加，BX默认DS段，BP默认SS段</span><br></pre></td></tr></table></figure></li><li><p>基址变址相对寻址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX [BX(BP)][SI(DI)]+(8/16bit的偏移量)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>寄存器操作数：寄存器寻址(其操作数是CPU寄存器中的数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV SI AX</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="指令计算">指令计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov ax,18;将18送入AX  AX=18</span><br><span class="line">mov ah,78;将78送入AH  AH=78</span><br><span class="line">add ax,8;将寄存器AX中的数值加上8，并放入前面的操作数中  AX=AX+8</span><br><span class="line">mov ax,bx;将寄存器BX中的数据送入寄存器AX  AX=BX</span><br><span class="line">add ax,bx;将AX,BX内容相加,结果存在AX中  AX=AX+BX</span><br><span class="line"></span><br><span class="line">add ax,bx;假设此时AX=8226H=BX,则结果应为1044CH,但结果为044CH,因为汇编语言也会出现溢出的情况</span><br><span class="line"></span><br><span class="line">mov ax,001AH;AX=001AH</span><br><span class="line">mov bx,0026H;BX=0026H</span><br><span class="line">add al,bl;al=1AH+26H=40H,则此时AX=0040HBX=0026H</span><br><span class="line">add ah,bl;AX=2640H,BX=0026H</span><br><span class="line">add bh,al;AX=2640H,BX=4026H</span><br><span class="line">mov ah,0;AX=0040H,BX=4026H</span><br><span class="line">add al,85H;AX=00C5H,BX=4026H</span><br><span class="line">add al,93H;AX=0058H,因为发生溢出0158H变成0058H,不能进入到高位,因为这里相当于两个八位相加,BX=4026H</span><br></pre></td></tr></table></figure><h3id="物理地址8086有20位地址总线可传输20位地址寻址能力为1m8086是16位结构的cpu运算器一次最多可以处理16位的数据寄存器的最大宽度位16位在8086内部处理的传输暂存的地址也是16位寻址能力也只有64kb">物理地址：8086有20位地址总线，可传输20位地址，寻址能力为1M；8086是16位结构的cpu，运算器一次最多可以处理16位的数据，寄存器的最大宽度位16位，在8086内部处理的，传输，暂存的地址也是16位，<code>寻址能力也只有64KB</code></h3><h4id="解决方案用两个16位地址段地址偏移地址合成一个20位物理地址16进制左移一位相当于16进制左移1位">解决方案：用两个16位地址(段地址，偏移地址)合成一个20位物理地址16进制左移一位相当于16进制左移1位</h4><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171421993.jpg"alt="265be9e7b54349ef265c8c4c89f5405" /><figcaptionaria-hidden="true">265be9e7b54349ef265c8c4c89f5405</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171421283.png"alt="屏幕截图_20240317_141854" /><figcaption aria-hidden="true">屏幕截图_20240317_141854</figcaption></figure><ul><li>段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数</li><li>便宜地址位16位，16位地址的寻址能力位64K，所以一个段的长度最大位64K(0~FFFFFH)</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171449203.png" /></p><ol type="1"><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器</li><li>IP=IP+所读取指令的长度，从而指向下一条指令</li><li>执行指令转到步骤1，重复这个过程</li></ol><h4id="如何修改csip的指令debug中的r命令可以改变但是debug是调试手段不是程序方式cs和代码段的问题">如何修改CS,IP的指令(Debug中的R命令可以改变，但是Debug是调试手段不是程序方式)(CS和<code>代码段</code>的问题)</h4><h5 id="注意不能用指令mov修改"><code>注意</code>不能用指令mov修改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;mov cs 2000H 错误</span><br><span class="line">;mov ip 0000h 错误</span><br><span class="line">;mov ip cs    错误</span><br></pre></td></tr></table></figure><h5 id="转移指令可以修改ip和cs内容">转移指令可以修改ip和cs内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;同时修改cs和ip内容  jmp 段地址:偏移地址</span><br><span class="line">jmp 2AE3:3</span><br><span class="line">jmp 3:0B16</span><br><span class="line">;仅仅修改ip的内容  jmp某一和法寄存器</span><br><span class="line">jmp ax(类似于 mov IP,ax但事实不能使用这个语句)</span><br><span class="line">jmp bx</span><br></pre></td></tr></table></figure><h6 id="从2000h开始执行的顺序是">从2000H开始，执行的顺序是：</h6><ol type="1"><li>mov ax,6622</li><li>jmp 1000:3</li><li>mov ax,0000</li><li>mov bx,ax</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171521551.png"alt="image-20240317152122350" /><figcaption aria-hidden="true">image-20240317152122350</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171521807.png"alt="屏幕截图_20240317_151832" /><figcaption aria-hidden="true">屏幕截图_20240317_151832</figcaption></figure><h4id="ds数据段寄存器和address配合得出cpu要访问的内存单元的地址">DS(数据段寄存器)和[address]配合得出cpu要访问的内存单元的地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov al,[0];将10000H(1000:0)中的字型数据读到al中,默认段地址保存在ds中,[0]代表偏移地址</span><br><span class="line"></span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx</span><br><span class="line">mov [0],al;将al中的数据写到10000H(1000:0)中   内存和寄存器之间的数据可以相互传输</span><br><span class="line">mov [0],cx;cx中的16位数据送到1000:0中</span><br></pre></td></tr></table></figure><p>将段地址送入DS的两种方式</p><ul><li><p>mov ds,1000H 错误</p></li><li><p>mov bx,1000H</p><p>mov ds,bx 正确(数据-&gt;一般寄存器-&gt;段寄存器)</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;内存中:10000H 23</span><br><span class="line">;   10001H 11</span><br><span class="line">;   10002H 22</span><br><span class="line">;   10003H 66</span><br><span class="line">;指令:</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov bx,[2]</span><br><span class="line">mov cx,[1];x含有ah,al两个字节,ax是字;DS=1000,AX=1123,BX=6622,CX=2211</span><br><span class="line">add bx,[1];BX=8833(2211+6622)</span><br><span class="line">add cx,[2];CX=8833(6622+2211)</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403171640987.jpg"alt="bdbea24f789ffbe24d7c3eaa5fd03fd" /><figcaptionaria-hidden="true">bdbea24f789ffbe24d7c3eaa5fd03fd</figcaption></figure><h4 id="ds与数据段的问题">DS与数据段的问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;累加数据段中的前3个单元中的数据,将123B0H~123BAH的内存单元定义为数据段</span><br><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,0;为了把累加数据放入al，将其清零</span><br><span class="line">add al,[0]</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br><span class="line"></span><br><span class="line">;累加数据段中的前3个字型数据，将123B0H~123BAH的内存单元定义为数据段</span><br><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0</span><br><span class="line">add ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4]</span><br></pre></td></tr></table></figure><h3 id="栈结构">栈结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;PUSH(入栈)，POP(出栈)，以字为单位对栈进行操作</span><br><span class="line">push ax;将ax中的数据传入到栈中</span><br><span class="line">pop ax;从栈顶取出数据ax</span><br><span class="line"></span><br><span class="line">;将10000H~1000FH内存当作栈来使用</span><br><span class="line">mov ax,0123H</span><br><span class="line">(mov ss,ax)</span><br><span class="line">(mov sp,0001H)</span><br><span class="line">push ax</span><br><span class="line">mov bx,2266H</span><br><span class="line">push bx</span><br><span class="line">mov cx,1122H</span><br><span class="line">push cx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">pop cx;ax=1122,bx=2266,cx=0123</span><br><span class="line"></span><br><span class="line">;push ax</span><br><span class="line">;(1)SP=SP-2;</span><br><span class="line">;(2)将ax中的内容送到SS:SP指向的内存单元处,SS:SP此时指向新栈顶</span><br><span class="line">;pop ax</span><br><span class="line">;(1)将SS:SP指向的内存单元处的数据送入ax中</span><br><span class="line">;(2)SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶</span><br><span class="line"></span><br><span class="line">;执行入栈(或出栈)时，栈顶超出栈空间，需要编程人员注意</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403241730252.png"alt="image-20240324173005622" /><figcaption aria-hidden="true">image-20240324173005622</figcaption></figure><p>此图为debug运行情况</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403241646795.png"alt="image-20240324164612922" /><figcaption aria-hidden="true">image-20240324164612922</figcaption></figure><ul><li><p>CPU如何知道一段内存空间被当作栈使用？</p></li><li><p>执行push和pop的时候，如何知道哪个单元是栈顶单元？</p><p>8086cpu中，有两个与栈相关的寄存器:栈段寄存器<code>SS---存放栈顶的段地址</code></p><p>栈顶指针寄存器<code>SP---存放栈顶的偏移地址</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">;按要求设置段并执行代码</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx;数据段的设置</span><br><span class="line">mov bx,1001H</span><br><span class="line">mov ss,bx;栈段的地址</span><br><span class="line">mov sp,10H;为寻找栈底地址:10010+10=10020</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov bx,[2]</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax</span><br><span class="line">pop bx</span><br><span class="line">mov [0],ax</span><br><span class="line">mov [2],bx</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403241754460.png"alt="image-20240324175411106" /><figcaption aria-hidden="true">image-20240324175411106</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403241755895.png"alt="image-20240324175519035" /><figcaption aria-hidden="true">image-20240324175519035</figcaption></figure><h3 id="汇编程序中的伪指令">汇编程序中的伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg   ;assume:含义是假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联--assume cs:codesg指CS寄存器与codesg关联，将定义的codesg当作程序的代码段使用(伪指令2)</span><br><span class="line">codesg segment     ;段定义:一个有意义的汇编程序中至少有一个段，用来存放代码。segment--段的开始，ends--段的结束(伪指令1)</span><br><span class="line">mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends   </span><br><span class="line">end    ;汇编程序的结束标记(伪指令3)</span><br></pre></td></tr></table></figure><h3 id="与...">[...]与(...)</h3><ul><li>[...]---汇编语法规定表示一个内存单元</li><li>(...)---表示一个内存单元或寄存器中的内容</li><li>idata表示常量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H   ;ax=2000H</span><br><span class="line">mov ds,ax      ;ds=2000H</span><br><span class="line">mov bx,1000H;bx=1000H</span><br><span class="line">mov ax,[bx];mov ax,[bx]---(ax)=((ds)*16+(bx))---现在操作的是21000H~21001H这个地址的内容,是字操作,此时ax=00BE</span><br><span class="line">inc bx;inc是加一的意思</span><br><span class="line">inc bx;bx=1002H</span><br><span class="line">mov [bx],ax;mov [bx],ax---((ds)*16+(bx))=(ax)---现在操作的是21002H~21003H这个地址的内容,是字操作,将2100H~2101H的内容放在21002H~21003H中,此时21002H~21003H中内容为00BE</span><br><span class="line">inc bx</span><br><span class="line">inc bx;bx=1004H</span><br><span class="line">mov [bx],ax;现在操作的是21004H~21005H这个地址的内容,是字操作,此时21004H~21005H中内容为00BE</span><br><span class="line">inc bx;bx=1005H;</span><br><span class="line">mov [bx],al;是字节操作,将21004H的内容放在21005H上(al低八位寻址),此时21005H中存放的是BE</span><br><span class="line">inc bx;bx=1006H</span><br><span class="line">mov [bx],al;21006H中存放的是BE</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404081214242.png"alt="image-20240408121443862" /><figcaption aria-hidden="true">image-20240408121443862</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1
id=&quot;汇编语言----直接在硬件之上工作的编程语言&quot;&gt;汇编语言----直接在硬件之上工作的编程语言&lt;/h1&gt;
&lt;h2 id=&quot;汇编指令机器码的助记符&quot;&gt;汇编指令(机器码的助记符)&lt;/h2&gt;
&lt;h3
id=&quot;cpu对存储器的读写逻辑上划分为&quot;&gt;cpu对存储器的读写</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数学建模算法入门3</title>
    <link href="https://pipi1002.github.io/2024/02/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%953/"/>
    <id>https://pipi1002.github.io/2024/02/29/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%953/</id>
    <published>2024-02-29T09:43:13.000Z</published>
    <updated>2024-04-06T08:52:27.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据降维处理的算法评价模型">数据降维处理的算法：(评价模型)</h1><h2id="主成分分析法所有主成分的数量指标数量各主成分的累计方差贡献率80或特征根1spass图像">主成分分析法(所有主成分的数量=指标数量,各主成分的累计方差贡献率&gt;80%,或特征根&gt;1)SPASS图像</h2><h6id="例题1.1有31个样本每个样本有8个变量">例题1.1有31个样本，每个样本有8个变量</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402291812536.png" /></p><h5id="要从原来的所有变量得到新的综合变量一种较为简单的方法是作线性变换使得新的综合变量为原变量的线性组合">要从原来的所有变量得到新的综合变量，一种较为简单的方法是作线性变换，使得新的综合变量为原变量的线性组合</h5><p><span class="math display">\[\left \{ \begin{array}{lr**}F_1=a_{11}x_1+a_{21}x_2+...+a_{p1}x_p\\F_2=a_{12}x_1+a_{21}x_2+...+a_{p2}x_p\\...\\F_p=a_{1p}x_1+a_{2p}x_2+...+a_{pp}x_p\\\end{array} \right.\\F_i=a_{1i}x_1+a_{2i}x_2+...+a_{pi}x_p\quad i=1,2,...p\\\]</span></p><ul><li>（var()为求方差的意思）<spanclass="math inline">\(var(cF_1)=c^2var(f_1)\)</span>,c为常数</li><li>为使得方差var(F_i)可以比较<spanclass="math inline">\(a_{i1}^2+a_{i2}^2+a_{ip}^2=1\)</span></li><li>要求原始变量有一定相关性</li><li>要求各个综合变量之间互不相关，即协方差为0</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402291832101.png" /></p><h6id="例题1.2根据我国31个省市自治区2006年的6项主要经济指标数据进行主成分分析找出主成分并进行适当的解释">例题1.2根据我国31个省市自治区2006年的6项主要经济指标数据，进行主成分分析，找出主成分并进行适当的解释</h6><table style="width:100%;"><colgroup><col style="width: 3%" /><col style="width: 5%" /><col style="width: 9%" /><col style="width: 12%" /><col style="width: 15%" /><col style="width: 16%" /><col style="width: 16%" /><col style="width: 20%" /></colgroup><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th><th style="text-align: center;">F</th><th style="text-align: center;">G</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">地区</td><td style="text-align: center;">人均GDP(元)</td><td style="text-align: center;">财政收入(万元)</td><td style="text-align: center;">固定资产投资(亿元)</td><td style="text-align: center;">年末总人口 (万人)</td><td style="text-align: center;">居民消费水平(元/人)</td><td style="text-align: center;">社会消费品零售总额(亿元)</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">北京</td><td style="text-align: center;">50467</td><td style="text-align: center;">11171514</td><td style="text-align: center;">3296.4</td><td style="text-align: center;">1581</td><td style="text-align: center;">16770</td><td style="text-align: center;">3275.2</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">天津</td><td style="text-align: center;">41163</td><td style="text-align: center;">4170479</td><td style="text-align: center;">1820.5</td><td style="text-align: center;">1075</td><td style="text-align: center;">10564</td><td style="text-align: center;">1356.8</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">河北</td><td style="text-align: center;">16962</td><td style="text-align: center;">6205340</td><td style="text-align: center;">5470.2</td><td style="text-align: center;">6898</td><td style="text-align: center;">4945</td><td style="text-align: center;">3397.4</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">山西</td><td style="text-align: center;">14132</td><td style="text-align: center;">5833752</td><td style="text-align: center;">2255.7</td><td style="text-align: center;">3375</td><td style="text-align: center;">4843</td><td style="text-align: center;">1613.4</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">内蒙古</td><td style="text-align: center;">20053</td><td style="text-align: center;">3433774</td><td style="text-align: center;">3363.2</td><td style="text-align: center;">2397</td><td style="text-align: center;">5800</td><td style="text-align: center;">1595.3</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">辽宁</td><td style="text-align: center;">21788</td><td style="text-align: center;">8176718</td><td style="text-align: center;">5689.6</td><td style="text-align: center;">4217</td><td style="text-align: center;">6929</td><td style="text-align: center;">3434.6</td></tr></tbody></table><h5id="指标标准化分析-描述统计-描述-导入数据-将标准化值另存为变量-结果">指标标准化：分析-&gt;描述统计-&gt;描述-&gt;导入数据-&gt;将标准化值另存为变量-&gt;结果</h5><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121257104.png"alt="image-20240312125732589" /><figcaption aria-hidden="true">image-20240312125732589</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121258728.png"alt="image-20240312125837126" /><figcaption aria-hidden="true">image-20240312125837126</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121259793.png"alt="image-20240312125933548" /><figcaption aria-hidden="true">image-20240312125933548</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121301104.png"alt="image-20240312130106829" /><figcaption aria-hidden="true">image-20240312130106829</figcaption></figure><h5id="进行主成分分析分析-降维-因子-把标准化处理过的导入-描述-初始解-kmo和巴特利特球形度检验-得分-保存为变量-回归-显示因子得分系数矩阵">进行主成分分析：分析-&gt;降维-&gt;因子-&gt;把标准化处理过的导入-&gt;描述-&gt;初始解-&gt;KMO和巴特利特球形度检验-&gt;得分-&gt;保存为变量-&gt;回归-&gt;显示因子得分系数矩阵</h5><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121308235.png"alt="image-20240312130852981" /><figcaption aria-hidden="true">image-20240312130852981</figcaption></figure><h6id="上图显示的是特征值如果特征值累计值超过百分之85例如如图的前两个已经到了百分之85则选12作为主成分"><code>上图显示的是特征值</code>，如果特征值累计值超过百分之85，例如如图的前两个已经到了百分之85，则选1，2作为主成分</h6><h6id="此时成分矩阵下图并不是主成分分析的系数而是因子分析">此时成分矩阵(下图)并不是主成分分析的系数，而是因子分析</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121311198.png"alt="image-20240312131140618" /><figcaption aria-hidden="true">image-20240312131140618</figcaption></figure><h6id="重新标度后成分取值在1-1其中第一个主成分代表的是人均gdp固定资产投资年末总人口居民消费水平第二个主成分代表的是财政收入固定资产投资社会消费品零售总额-也可以用分析-降维-因子分析-旋转-载荷图或者提取-碎石图看出来">重新标度后成分取值在1~-1，其中第一个主成分代表的是人均GDP，固定资产投资，年末总人口，居民消费水平，第二个主成分代表的是财政收入，固定资产投资，社会消费品零售总额(也可以用分析-&gt;降维-&gt;因子分析-&gt;旋转-&gt;载荷图，或者提取-&gt;碎石图看出来)</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121745797.png"alt="image-20240312174525358" /><figcaption aria-hidden="true">image-20240312174525358</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121748934.png"alt="image-20240312174825898" /><figcaption aria-hidden="true">image-20240312174825898</figcaption></figure><h5id="因子分析和主成分分析之间的切换因为已经得出成分矩阵了只需要除以lambda得到新的特征向量">因子分析和主成分分析之间的切换:因为已经得出成分矩阵了，只需要除以<spanclass="math inline">\(\lambda\)</span>得到新的特征向量</h5><p><span class="math display">\[u_{ij}=a_{ij}/\sqrt{\lambda_{i}}\]</span></p><h6id="转换-计算变量-目标变量随意起名字v1sqrtlambda其中lambda总方差解释中的重新标度的值">转换-&gt;计算变量-&gt;(目标变量随意起名字)<spanclass="math inline">\(V1/\sqrt{\lambda},其中\lambda=总方差解释中的重新标度的值\)</span></h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121808564.png"alt="image-20240312180854024" /><figcaption aria-hidden="true">image-20240312180854024</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121813828.png"alt="image-20240312181312441" /><figcaption aria-hidden="true">image-20240312181312441</figcaption></figure><h5 id="计算最终答案">计算最终答案：</h5><h6 id="image-20240312181757462"><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202403121817744.png"alt="image-20240312181757462" /></h6><h2id="模糊综合评价模型适用于少量数据支撑情况下的评价问题">模糊综合评价模型(适用于少量数据支撑情况下的评价问题)</h2><h4id="模糊集长短多少高矮-这类现象不满足非此即彼的排中律而具有亦此亦彼的模糊性">模糊集：长，短；多，少；高，矮这类现象不满足"非此即彼"的排中律，而具有“亦此亦彼”的模糊性：</h4><h5id="设给定论域u所谓u上的一个模糊集a是指对于任意xu都能确定一个正数mu_ax01用其表示x属于a的程度映射xu-mu_ax01称为a的隶属函数函数值mu_ax称为x对a的隶属度每个元素都有隶属度的集合称之为模糊集">设给定论域U，所谓U上的一个模糊集A是指对于任意<spanclass="math inline">\(x∈U\)</span>，都能确定一个正数<spanclass="math inline">\(\mu_A(x)∈[0,1]\)</span>用其表示x属于A的程度，映射<spanclass="math inline">\(x∈U-&gt;\mu_A(x)∈[0,1]\)</span>称为A的隶属函数，函数值<spanclass="math inline">\(\mu_A(x)\)</span>称为x对A的隶属度，每个元素都有隶属度的集合称之为模糊集</h5><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404051347863.png"alt="image-20240405134713363" /><figcaption aria-hidden="true">image-20240405134713363</figcaption></figure><h5id="设x_i表示第ii12...30条线段则论域uleft-beginarraylr-x_1x_2...x_30endarray-right-若a为长线段的集合则线段x_i作为集a的成员资格就是x_i对a的隶属度因为线段越长属于a的程度越大所以线段的长短可以作为a的隶属度从而令ax_11ax_300作直线ax_i-0frac1-01-30i-30ax_ifrac12930-ii12...30">设<spanclass="math inline">\(x_i\)</span>表示第i(i=1,2,...,30)条线段，则论域<spanclass="math inline">\(U=\left \{ \begin{array}{lr**}x_1,x_2,...,x_{30}\end{array} \right\}\)</span>若A为“长线段”的集合，则线段<spanclass="math inline">\(x_i\)</span>作为集A的成员资格，就是<spanclass="math inline">\(x_i\)</span>对A的隶属度。因为线段越长，属于A的程度越大，所以线段的长短可以作为A的隶属度，从而令<spanclass="math inline">\(A(x_1)=1,A(x_{30})=0\)</span>,作直线<spanclass="math inline">\(A(x_i)-0=\frac{1-0}{1-30}(i-30),A(x_i)=\frac{1}{29}(30-i),i=1,2,...,30\)</span></h5><h3 id="隶属函数的分类">隶属函数的分类：</h3><ol type="1"><li><p><code>偏小型:</code><span class="math inline">\(A(x)=\left \{\begin{array}{lr**}1,x&lt;a\\\frac{b-x}{a-x},a \leq x\leq b \\0,x&gt;b\end{array} \right.\)</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404051416666.png"alt="image-20240405141634619" /><figcaption aria-hidden="true">image-20240405141634619</figcaption></figure></li><li><p><code>偏大型:</code><span class="math inline">\(A(x)=\left \{\begin{array}{lr**}1,x&lt;a\\\frac{x-a}{b-a},a \leq x\leq b \\0,x&gt;b\end{array} \right.\)</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404051417498.png"alt="image-20240405141756095" /><figcaption aria-hidden="true">image-20240405141756095</figcaption></figure></li><li><p><code>中间型:</code><span class="math inline">\(A(x)=\left \{\begin{array}{lr**}0,x&lt;a\\\frac{x-a}{b-a},a \leq x&lt; b \\1,b\leqx\leq c\\ \frac{d-x}{d-c},c\leq x\leq d \\0,x&gt;d\end{array}\right.\)</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404051420317.png"alt="image-20240405142052430" /><figcaption aria-hidden="true">image-20240405142052430</figcaption></figure></li></ol><h3 id="模糊评价">模糊评价：</h3><h4id="例题1.1-某服装厂采用模糊综合评价法来了解顾客对某种服装的欢迎程度顾客是否喜欢某种服装与话说样式价格耐用度和舒适度有关故确定评价服装的因素集为u花色样式价格耐用度舒适度">例题1.1某服装厂采用模糊综合评价法来了解顾客对某种服装的欢迎程度。顾客是否喜欢某种服装，与话说，样式，价格，耐用度和舒适度有关，故确定评价服装的因素集为U={花色，样式，价格，耐用度，舒适度}</h4><h5id="由市场调研得出分别对各个因素的受欢迎程度为评价指标">1.由市场调研得出分别对各个因素的受欢迎程度为(评价指标)</h5><h6id="r10.20.50.30r20.10.30.50.1r300.10.60.3r400.40.50.1r50.50.30.20得出模糊综合评价矩阵为aleft-beginarraylr-0.2quad0.5quad0.3quad00.1quad0.2quad0.5quad0.1-0quad0.1quad0.6quad0.30quad0.4quad0.5quad0.1-0.5quad0.3quad0.2quad0endarray-right.">R1={0.2，0.5，0.3，0}，R2={0.1，0.3，0.5，0.1}，R3={0，0.1，0.6，0.3}，R4={0，0.4，0.5，0.1}，R5={0.5，0.3，0.2，0}得出模糊综合评价矩阵为<spanclass="math inline">\(A=\left \{ \begin{array}{lr**}0.2\quad0.5\quad0.3\quad0\\0.1\quad0.2\quad0.5\quad0.1\\0\quad0.1\quad0.6\quad0.3\\0\quad0.4\quad0.5\quad0.1\\0.5\quad0.3\quad0.2\quad0\\\end{array} \right.\)</span></h6><h5id="评价指标权重的确定花色耐用度...谁更重要确定权重通常有主观和客观两类方法主观法的代表是层次分析法客观法是根据各指标的联系利用数学方法计算出各指标的权重如质量分数法变异系数法">2.评价指标权重的确定(花色，耐用度，...谁更重要),确定权重通常有主观和客观两类方法，主观法的代表是层次分析法，客观法是根据各指标的联系，利用数学方法计算出各指标的权重，如质量分数法，变异系数法</h5><h6id="通常引入一个模糊向量aa_1a_2...a_n来表示各评价指标在目标中所占权重称为权重向量">通常引入一个模糊向量<spanclass="math inline">\(A=(a_1,a_2,...,a_n)\)</span>来表示各评价指标在目标中所占权重，称为权重向量</h6><h3id="变异系数法已知5个投资方案如下表试确定4个评价指标的权重">变异系数法：已知5个投资方案如下表，试确定4个评价指标的权重</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404051501118.png"alt="image-20240405150127868" /><figcaption aria-hidden="true">image-20240405150127868</figcaption></figure><h5id="变异系数法的设计原理将波动幅度高的指标给与较大的权重因为方差可以描述取值的离散程度即某指标的方差反映了该指标的分辨能力所以可以用方差定义指标的权重">变异系数法的设计原理：将波动幅度高的指标，给与较大的权重，因为方差可以描述取值的离散程度，即某指标的方差反映了该指标的分辨能力，所以可以用方差定义指标的权重</h5><ul><li>计算第i项指标的均值与方差<spanclass="math inline">\(\overline{A_i}=\frac{1}{n}\sum_{j=1}^{n}a_{ij},s_i^2=\frac{1}{n-1}\sum_{j=1}^{n}(a_{ij}-\overline{x_i})^2\)</span>令<spanclass="math inline">\(v_i=s_i/|\overline{x_i}|\)</span>,则归一化的<spanclass="math inline">\(v_i\)</span>(如果此时v的值都在0~1范围内就不需要归一化，否则要对原始数据进行归一化处理)即为各指标的权重，<spanclass="math inline">\(归一化方法：\frac{v_i-v_{imin}}{v_{imax}-v_{imin}}\)</span>即<spanclass="math inline">\(\omega_i=v_i/\sum{v_i}\)</span></li></ul><h6id="结果overlinex_i7.37s_i238v_1s_1overlinex_12.387.370.323同理v_20.227v_30.228v_40.544从而omega_10.244omega_20.172omega_30.172omega_40.412-其实只能判断哪些指标分辨率更强但不是谁最重要">结果：<spanclass="math inline">\(\overline{x_i}=7.37,s_i=2,38,v_1=s_1/\overline{x_1}=2.38/7.37=0.323,同理v_2=0.227，v_3=0.228，v_4=0.544\)</span>从而<spanclass="math inline">\(\omega_1=0.244,\omega_2=0.172,\omega_3=0.172,\omega_4=0.412\)</span>其实只能判断哪些指标分辨率更强，但不是谁最重要</h6><h5 id="模糊合成与综合评价">3.模糊合成与综合评价</h5><h6id="其实也可以取m为普通的矩阵乘法此时合成即为加权平均效果不好至于到底取何种算子取决于问题的性质和算子的特点">其实也可以取M为普通的矩阵乘法，此时合成即为加权平均(效果不好)，至于到底取何种算子取决于问题的性质和算子的特点</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404061451387.png"alt="image-20240406145051828" /><figcaption aria-hidden="true">image-20240406145051828</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404061451697.png"alt="屏幕截图_20240406_144845" /><figcaption aria-hidden="true">屏幕截图_20240406_144845</figcaption></figure><h6id="乘法体现权数作用取和的时候综合程度强相乘就是利用r的信息图上有误">乘法体现权数作用，取和的时候综合程度强，相乘就是利用R的信息(图上有误)</h6><p><code>主因素突出型</code>适用于模糊矩阵中数据相差很悬殊的情形，而<code>加权平均型</code>则常用于因素很多的情形，可以避免信息丢失</p><h6id="例题1.3.1在教学过程的综合评价中取u清楚易懂教材熟悉生动有趣板书整齐v很好较好一般不好设某班同学对教师的教学评价矩阵为rleftmatrix0.4-0.5-0.1-00.6-0.3-0.1-00.1-0.2-0.6-0.10.1-0.2-0.5-0.2right若考虑权重a0.50.20.20.1试求学生对这位教师的综合评价">例题1.3.1在教学过程的综合评价中，取U={清楚易懂，教材熟悉，生动有趣，板书整齐}，V={很好，较好，一般，不好}。设某班同学对教师的教学评价矩阵为<spanclass="math inline">\(R=\left[\matrix{0.4 &amp; 0.5 &amp; 0.1 &amp;0\\0.6 &amp; 0.3 &amp; 0.1 &amp; 0\\0.1 &amp; 0.2 &amp; 0.6 &amp;0.1\\0.1 &amp; 0.2&amp; 0.5 &amp;0.2}\right]\)</span>,若考虑权重A=(0.5,0.2,0.2,0.1)试求学生对这位教师的综合评价</h6><h5id="利用a和r利用四种合成算子编程计算得bleftmatrix0.3333-0.4164-0.1667-0.08330.3200-0.4000-0.2000-0.08000.3390-0.4237-0.2033-0.03390.3500-0.3700-0.2400-0.0400right">利用A和R，利用四种合成算子编程计算得<spanclass="math inline">\(B=\left[\matrix{0.3333 &amp; 0.4164 &amp; 0.1667&amp; 0.0833\\0.3200 &amp; 0.4000 &amp; 0.2000 &amp; 0.0800\\0.3390&amp; 0.4237 &amp; 0.2033 &amp; 0.0339\\0.3500 &amp; 0.3700&amp; 0.2400&amp; 0.0400}\right]\)</span></h5><p>过程如下：</p><p>1.权重A的每一行元素和R分别和每一列元素相比得到最小<spanclass="math inline">\((0.4,0.2,0.1,0.1);(0.5,0.2,0.1,0.1);(0.1,0.1,0.2,0.5);(0,0,0.1,0.1)\)</span></p><p>2.再将得出的每一括号内的元素取最大值为<spanclass="math inline">\(0.4,0.5,0.2,0.1\)</span></p><p>3.因为所有<spanclass="math inline">\(b_i\)</span>相加应该等于1，0.4，0.5，0.2，0.1都在0~1范围内，已经归一化了，但是相加得0.4+0.5+0.2+0.1=1.2不为1，就用0.4除以他们的综合，其他同理，结果为以上</p><h5id="注意这道题简单于给出了权向量a和评价矩阵r一般情况下不会给要根据变异方差法求a求r的常用方法有相对偏差法和相对优属度法在数学建模中还可以考虑与灰色系数分析连用"><code>注意:</code>这道题简单于，给出了权向量A和评价矩阵R，一般情况下不会给，要根据变异方差法求A，求R的常用方法有相对偏差法和相对优属度法，在数学建模中还可以考虑与灰色系数分析连用</h5><h4 id="相对偏差法">相对偏差法</h4><h6id="例题先有下列5个农业奇数经济方案试评价各方案的优劣">1.4.1例题先有下列5个农业奇数经济方案，试评价各方案的优劣</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404061604446.png"alt="image-20240406160442055" /><figcaption aria-hidden="true">image-20240406160442055</figcaption></figure><h5id="产量和肥力为效益性指标其他为理想型指标效益性指标用最大值理想型指标用最小值u10006040001300.51">1.产量和肥力为效益性指标，其他为理想型指标，效益性指标用最大值，理想型指标用最小值：u={1000，60，4000，1，30，0.5，1}</h5><h5id="根据前述方法求出相对偏差模糊矩阵frac最大值-该值最大值-最小值frac1000-10001000-7000">2.根据前述方法求出相对偏差模糊矩阵：<spanclass="math inline">\(\frac{最大值-该值}{最大值-最小值}=\frac{1000-1000}{1000-700}=0\)</span></h5><p><span class="math inline">\(R=\left[\matrix{0 &amp; 1 &amp; 0.25&amp; 0 &amp; 0.5 &amp; 0.66 &amp;1\\1 &amp; 0 &amp; 0 &amp;1&amp;0.75&amp;1&amp;0.8\\0.333 &amp; 0 &amp; 0.75 &amp;0&amp;0&amp;0.33&amp;0.4\\0.667 &amp; 0.17&amp; 1 &amp;0.5&amp;0.75&amp;0&amp;0\\0.677&amp;0.33&amp;0&amp;1&amp;1&amp;1&amp;0.2}\right]\)</span></p><h5 id="用变异系数法求出指标权重">3.用变异系数法求出指标权重：</h5><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404061618357.png"alt="image-20240406161827039" /><figcaption aria-hidden="true">image-20240406161827039</figcaption></figure><p><spanclass="math inline">\(\omega=0.110,0.214,0.176,0.156,0.098,0.113,0.134\)</span></p><h5id="各个方案加权平均值f为omegar0.35250.45580.45050.52060.5864">4.各个方案加权平均值F为<spanclass="math inline">\(\omega*R\)</span>：0.3525，0.4558，0.4505，0.5206，0.5864</h5><h5id="越小越好则方案的优劣次序为13245">5.越小越好则方案的优劣次序为：1，3，2，4，5</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">A=[<span class="number">1000</span> <span class="number">120</span> <span class="number">5000</span> <span class="number">1</span> <span class="number">50</span> <span class="number">1.5</span> <span class="number">1</span></span><br><span class="line"><span class="number">700</span> <span class="number">60</span> <span class="number">4000</span> <span class="number">2</span> <span class="number">40</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">900</span> <span class="number">60</span> <span class="number">7000</span> <span class="number">1</span> <span class="number">70</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">800</span> <span class="number">70</span> <span class="number">8000</span> <span class="number">1.5</span> <span class="number">40</span> <span class="number">0.5</span> <span class="number">6</span></span><br><span class="line"><span class="number">800</span> <span class="number">80</span> <span class="number">4000</span> <span class="number">2</span> <span class="number">30</span> <span class="number">2</span> <span class="number">5</span>]</span><br><span class="line">[m,n]=<span class="built_in">size</span>(A);<span class="comment">%找出多少行，多少列</span></span><br><span class="line">maxA=<span class="built_in">max</span>(A);<span class="comment">%找出每列最大值</span></span><br><span class="line">minA=<span class="built_in">min</span>(A);<span class="comment">%找出每列最小值</span></span><br><span class="line">G=maxA-minA;</span><br><span class="line">A1=<span class="built_in">max</span>(A(:,<span class="number">1</span>));<span class="comment">%A1为效益性</span></span><br><span class="line">A2=<span class="built_in">min</span>(A(:,<span class="number">2</span>:n<span class="number">-1</span>));<span class="comment">%A2~A6为成本型</span></span><br><span class="line">A3=<span class="built_in">max</span>(A(:,<span class="number">7</span>));</span><br><span class="line">u=[A1,A2,A3];</span><br><span class="line">R=<span class="built_in">zeros</span>(m,n);<span class="comment">%将模糊综合矩阵设置初值为0</span></span><br><span class="line"><span class="comment">%如下是得出模糊综合局矩阵</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">        R(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">abs</span>(A(<span class="built_in">i</span>,<span class="built_in">j</span>)-u(<span class="built_in">j</span>))/G(<span class="built_in">j</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x=<span class="built_in">mean</span>(A);<span class="comment">%求均值</span></span><br><span class="line">s=std(A);<span class="comment">%求方差</span></span><br><span class="line">v=s./x;</span><br><span class="line">v2=sum(v);</span><br><span class="line">c=<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">7</span></span><br><span class="line">    c(<span class="built_in">i</span>)=v(<span class="built_in">i</span>)/v2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">FF=R*c&#x27;;</span><br></pre></td></tr></table></figure><h4 id="相对优属度评价法">相对优属度评价法</h4><h6id="例题1.5.1对下表中5个方案进行综合评价">例题1.5.1对下表中5个方案进行综合评价</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404061641777.png"alt="image-20240405150127868" /><figcaption aria-hidden="true">image-20240405150127868</figcaption></figure><h5id="建立模糊效益矩阵投资额风险损失为成本型期望净现值风险盈利值为效益型image-20240406163818413">1.建立模糊效益矩阵，投资额，风险损失为成本型；期望净现值，风险盈利值为效益型<imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202404061638410.png"alt="image-20240406163818413" /></h5><p><span class="math inline">\(W=\left[\matrix{1 &amp; 0.5159 &amp;0.9905 &amp; 0.5350 &amp; 0.7879\\0.7761 &amp; 1 &amp;0.6269&amp;0.7836&amp;0.5597\\0.8284 &amp; 1 &amp; 0.6690 &amp;0.9702&amp;0.5779\\1 &amp; 0.2958&amp; 1 &amp;0.3602&amp;0.5890}\right]\)</span></p><h5id="由变异系数法求指标权重0.2590.2350.2460.259">2.由变异系数法求指标权重:<spanclass="math inline">\((0.259,0.235,0.246,0.259)\)</span></h5><h5id="各方案的加权平均优属度为omegaw0.93200.59190.87650.58080.6307故方案排序为13524">3.各方案的加权平均优属度为<spanclass="math inline">\(\omega*W\)</span>:<spanclass="math inline">\(0.9320,0.5919,0.8765,0.5808,0.6307\)</span>,故方案排序为1，3，5，2，4</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据降维处理的算法评价模型&quot;&gt;数据降维处理的算法：(评价模型)&lt;/h1&gt;
&lt;h2
id=&quot;主成分分析法所有主成分的数量指标数量各主成分的累计方差贡献率80或特征根1spass图像&quot;&gt;主成分分析法(所有主成分的数量=指标数量,各主成分的累计方差贡献率&amp;gt;80</summary>
      
    
    
    
    <category term="数学建模学习" scheme="https://pipi1002.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模案例1</title>
    <link href="https://pipi1002.github.io/2024/02/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A1%88%E4%BE%8B1/"/>
    <id>https://pipi1002.github.io/2024/02/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A1%88%E4%BE%8B1/</id>
    <published>2024-02-26T08:34:50.000Z</published>
    <updated>2024-02-27T09:46:59.175Z</updated>
    
    <content type="html"><![CDATA[<h2id="sars疫情对某些经济指标的影响灰色预测">SARS疫情对某些经济指标的影响(灰色预测)</h2><p>图一：商品零售额</p><p>图二：接待海外旅行人数</p><p>图三：综合服务业累计数据(单位：亿元)</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402261645578.png"alt="屏幕截图_20240226_163906" /><figcaption aria-hidden="true">屏幕截图_20240226_163906</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402261643232.png"alt="屏幕截图_20240226_164204" /><figcaption aria-hidden="true">屏幕截图_20240226_164204</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402261644539.png"alt="屏幕截图_20240226_164222" /><figcaption aria-hidden="true">屏幕截图_20240226_164222</figcaption></figure><h6id="利用灰色理论建立灰微分方程模型由19972002年的平均值预测2023年平均值">1.利用灰色理论建立灰微分方程模型，由1997~2002年的平均值预测2023年平均值</h6><h5id="可以根据19972002年中每个月的数据预测出2003年每个月的数据也可以把每年中12个月数据总和加起来预测2003年总和并根据每年每月数据占总和的多少来预测2003年每月的情况以下是第二种想法">可以根据1997~2002年中每个月的数据，预测出2003年每个月的数据；也可以把每年中12个月数据总和加起来预测2003年总和，并根据每年每月数据占总和的多少来预测2003年每月的情况(以下是第二种想法)</h5><ul><li><p>对1997~2002年某项指标记为矩阵A=(a_ij)_6×12计算每年的年平均值，记为<span class="math display">\[x^{(0)}=(x^{(0)}(1),x^{(0)}(2),x^{(0)}(3),...,x^{(0)}(6))\]</span></p><ul><li>要求极比属于(0.7515到1.3307)</li></ul></li><li><p>对<span class="math inline">\(x^{(0)}\)</span>作一次累加，则<span class="math display">\[x^{(1)}(1)=x^{(0)}(1),x^{(1)}(i)=\sum_{k=1}^{i}{x^{(0)}(k)}(i=2,3)\\记x^{(1)}=(x^{(0)}(1),x^{(0)}(2),...,x^{(0)}(6))\]</span></p><p><span class="math display">\[x^{(0)}=(87.6167,98.5000,108.4750,118.4167,132.8083,145.4083)x^{(1)}=(87.6167,186.1167,294.5917,413.0083,545,8167,691.2250)\]</span></p></li><li><p><spanclass="math inline">\(\alpha=0.4则z^{(1)}(k)=0.4x^{(1)}(k)+(1-0.4)x^{(1)}(k-1),z^{(1)}=(127.0617,229.5067,341.9583,466.1317,603.9800)\)</span></p></li><li><p>最小二乘法得到a=-0.0993，b=85.5985，可得2003年的月平均值为x=162.8826，年总值为X=12x=1954.6<span class="math display">\[u_i=\frac{\sum_{j=1}^{6}a_{ij}}{\sum_{i=1}^{12}\sum_{j=1}^6a_{ij}}\]</span>上式子可以计算出每个月所占整年预测值得：u=(0.0794,0.0807,0.0749,0.0786,0.0829,0.0818,0.0845,0.0838,0.0872,0.0886,0.0866,0.0920)则可以得到2003年1-12月的预测值为：</p><p>Y=u·X=(155.2,157.8,146.4,153.6,160.1,159.9,165.2,163.8,170.5,173.2,169.3,179.9)(亿元)</p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">clc,clear</span><br><span class="line">han1=[输入数据]</span><br><span class="line">han1(<span class="keyword">end</span>,:)=[];m=<span class="built_in">size</span>(han1,<span class="number">2</span>);</span><br><span class="line">m=<span class="built_in">size</span>(han1,<span class="number">2</span>);<span class="comment">%把月份提取出来，一共十二个月</span></span><br><span class="line">x0=<span class="built_in">mean</span>(han1,<span class="number">2</span>);<span class="comment">%返回x0矩阵每行的平均值，其中的2代表返回行</span></span><br><span class="line">x1=cumsum(x0);<span class="comment">%一次累加</span></span><br><span class="line">alpha=<span class="number">0.4</span>;</span><br><span class="line">n=<span class="built_in">length</span>(x0);<span class="comment">%长度，数据的维度,n=6</span></span><br><span class="line">z1=alpha*x1(<span class="number">2</span>:n)+(<span class="number">1</span>-alpha)*x1(<span class="number">1</span>:n<span class="number">-1</span>)<span class="comment">%求邻域生成数</span></span><br><span class="line">Y=x0(<span class="number">2</span>:n);B=[-z1,<span class="built_in">ones</span>(n<span class="number">-1</span>,<span class="number">1</span>)];</span><br><span class="line">ab=B\Y<span class="comment">%求a,b</span></span><br><span class="line">k=<span class="number">6</span>;</span><br><span class="line">x7hat=(x0(<span class="number">1</span>)-ab(<span class="number">2</span>)/ab(<span class="number">1</span>))*(<span class="built_in">exp</span>(-ab(<span class="number">1</span>)*k)-<span class="built_in">exp</span>(-ab(<span class="number">1</span>)*(k<span class="number">-1</span>)))<span class="comment">%预测新一年平均每月的值</span></span><br><span class="line">z=m*x7hat</span><br><span class="line">u=sum(han1)/sum(sum(han1))</span><br><span class="line">v=z*u</span><br></pre></td></tr></table></figure><h6id="通过历史数据计算每个月的指标值与全年总值的关系从而可预测出正常情况下2003年每个月的指标值再与实际值比较可以估算出sars疫情实际造成的影响">2.通过历史数据计算每个月的指标值与全年总值的关系，从而可预测出正常情况下2003年每个月的指标值，再与实际值比较可以估算出SARS疫情实际造成的影响</h6><h5id="根据该市的统计报告显示2003年456三个月的实际商品零售额分别为145.2124144.1亿元在这之前根据统计部门的估计456三个月份sars疫情对该市的商品零售业的影响最为严重这三个月估计大约损失62亿元左右从我们的模型预测结果来计算456三个月的损失为60.3亿元这个数据基本与专家的估算值相符8月份基本恢复正常这也说明了模型的正确性和可靠性">根据该市的统计报告显示，2003年4，5，6三个月的实际商品零售额分别为145.2，124，144.1亿元。在这之前，根据统计部门的估计4，5，6三个月份SARS疫情对该市的商品零售业的影响最为严重，这三个月估计大约损失62亿元左右，从我们的模型预测结果来计算，4，5，6三个月的损失为60.3亿元，这个数据基本与专家的估算值相符，8月份基本恢复正常，这也说明了模型的正确性和可靠性</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2
id=&quot;sars疫情对某些经济指标的影响灰色预测&quot;&gt;SARS疫情对某些经济指标的影响(灰色预测)&lt;/h2&gt;
&lt;p&gt;图一：商品零售额&lt;/p&gt;
&lt;p&gt;图二：接待海外旅行人数&lt;/p&gt;
&lt;p&gt;图三：综合服务业累计数据(单位：亿元)&lt;/p&gt;
&lt;figure&gt;
&lt;img</summary>
      
    
    
    
    <category term="数学建模学习" scheme="https://pipi1002.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模算法入门(2)</title>
    <link href="https://pipi1002.github.io/2024/01/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%952/"/>
    <id>https://pipi1002.github.io/2024/01/26/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%952/</id>
    <published>2024-01-26T04:17:48.000Z</published>
    <updated>2024-02-29T06:39:28.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="topsis算法">TOPSIS算法</h1><h6id="评价方法大体可以分为两类其主要区别在确定权重的方法上一类是主观赋权法如综合指数法模糊综合评判法层次分析法功效系数法等另一类是客观赋权根据各项指标间相关关系或各指标值变异程度确定权数如主成分分析法因子分析法理想解法也称topsis法">评价方法大体可以分为两类，其主要区别在确定权重的方法上。一类是主观赋权法，如综合指数法，模糊综合评判法，层次分析法，功效系数法等。另一类是客观赋权，根据各项指标间相关关系或各指标值变异程度确定权数，如主成分分析法，因子分析法，理想解法(也称TOPSIS法)</h6><h5id="topsis构造评价问题的正理想解和负理想解方法设多属性决策方案集待评价方案集为dd_1d_2...d_m衡量方案优劣的属性变量为x_1x_2...x_n这时方案集d中的每个方案d_ii1...m的n个属性值构造的向量是a_i1...a_in它作为n维空间中的一个点能唯一地表征方案d_i">topsis:构造评价问题的正理想解和负理想解<code>方法：</code>设多属性决策方案集(待评价方案集)为D={d_1,d_2,...,d_m}衡量方案优劣的属性变量为x_1,x_2,...x_n这时方案集D中的每个方案d_i(i=1,...,m)的n个属性值构造的向量是[a_i1,...,a_in],它作为n维空间中的一个点，能唯一地表征方案d_i。</h5><h3 id="算法步骤">算法步骤：</h3><ul><li><p>消除量纲问题：用向量规划的方法求得规范决策矩阵，设多属性决策问题的决策矩阵<spanclass="math inline">\(A=(a_{ij})_{m×n}\)</span>，规范化决策矩阵<spanclass="math inline">\(B=(b_{ij})_{m×n}\)</span>，其中<spanclass="math inline">\(b_{ij}=a_{ij}/\sqrt{\sum_{i=1}^{m}{a_{ij}^{2}}}\)</span>,i=1,2,...,m;j=1,2,...,n。</p></li><li><p>权重问题：由决策人给定各属性的权重向量为<spanclass="math inline">\(w=[w_1,w_2,...,w_n]\)</span>,则<spanclass="math inline">\(c_{ij}=w_j·b_{ij},i=1,2,...,m;j=1,2,...,n\)</span><code>属性的权重值乘以每一个数据值就是最终的评价值</code></p></li><li><p>确定正理想解<spanclass="math inline">\(C^*\)</span>和负理想解<spanclass="math inline">\(C^0\)</span>，设正理想解的第j个属性值为<spanclass="math inline">\(C_j^*\)</span>,负理想解第j个属性值为<spanclass="math inline">\(C_j^0\)</span> <span class="math display">\[正理想解:C_j^*=\left \{ \begin{array}{lr**}max\quad c_{ij},j为效益性属性\\min\quad c_{ij},j为成本型属性,j=1,2,...,n\end{array} \right.\\负理想解:C_j^0=\left \{ \begin{array}{lr**}max\quad c_{ij},j为成本性属性\\min\quad c_{ij},j为效益性属性,j=1,2,...,n\end{array} \right.\\\]</span></p></li><li><p>计算各方案到正理想解与负理想解的距离 <spanclass="math display">\[备选方案d_i到正理想解的距离为\\s_i^n=\sqrt{\sum_{j=1}^{n}{(c_{ij}-c_j^*)^2}},i=1,2,...,m\\备选方案d_i到负理想解的距离为\\s_i^n=\sqrt{\sum_{j=1}^{n}{(c_{ij}-c_j^0)^2}},i=1,2,...,m\\\]</span></p></li><li><p>计算各方案的排队指标值<spanclass="math inline">\(f_i^*=s_i^0/s_i^*+s_i^0\)</span>越大越好</p></li></ul><h6id="例题1.1为了客观地评价我国研究生教育的实际状况和各研究院的教学质量国务院学位委员会办公室组织过依次研究生院的评估">例题1.1为了客观地评价我国研究生教育的实际状况和各研究院的教学质量，国务院学位委员会办公室组织过依次研究生院的评估</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401261337631.png" /></p><h5id="第一步属性值的规范化---标准的0-1变换为了使每个属性变换后的最优值为1且最差值为0----全变成效益型">第一步：属性值的规范化---&gt;标准的0-1变换(为了使每个属性变换后的最优值为1且最差值为0)----&gt;全变成效益型</h5><ul><li><p>对效益性属性 <span class="math display">\[b_{ij}=\frac{a_{ij}-a_j^{max}}{a_j^{max}-a_j^{min}}\]</span></p></li><li><p>对成本型属性 <span class="math display">\[b_{ij}=\frac{a_j^{max}-a_{ij}}{a_j^{max}-a_j^{min}}\]</span></p></li><li><p>对于区间型，设定最优属性区间为<spanclass="math inline">\([a_j^0,a_j^*],a_j^{&#39;&#39;}为无法容忍上限,a_j^{&#39;}为无法容忍下限\)</span></p></li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401261358390.png" /><span class="math display">\[b_{ij}=\left \{ \begin{array}{lr**}1-(a_j^0-a_{ij})/(a_j^0-a_j^{&#39;}),若a_j^{&#39;}\leq a_{ij}\leqa_j^0\\1,若a_j^0\leq a_{ij}\leq a_j^*\\1-(a_{ij}-a_j^*)/(a_j^{&#39;&#39;}-a_j^*),若a_j^*\leq a_{ij}\leqa_j^{&#39;&#39;}\\0,其它\end{array} \right.\\\]</span> <imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401261406573.png" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clc，clear</span><br><span class="line"><span class="comment">%@是用于定义函数句柄的操作符。函数句柄既是一种变量，可以用于传参和赋值；也可以当作函数名一样使用</span></span><br><span class="line">x_2=@(qujian,lb,ub,x)(<span class="number">1</span>-(qujian(<span class="number">1</span>)-x)./(qujian(<span class="number">1</span>)-lb).*(x&gt;=lb&amp;x&lt;qujian(<span class="number">1</span>))+...</span><br><span class="line">(x&gt;=qujian(<span class="number">1</span>)&amp;x&lt;=qujian(<span class="number">2</span>))+(<span class="number">1</span>-(x-qujian(<span class="number">2</span>))./(ub-qujian(<span class="number">2</span>))).*...</span><br><span class="line">(x&gt;qujian(<span class="number">2</span>)&amp;x&lt;=ub);</span><br><span class="line">qujian=[<span class="number">5</span>,<span class="number">6</span>];lb=<span class="number">2</span>;ub=<span class="number">12</span>;</span><br><span class="line">x2data=[<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">10</span> <span class="number">2</span>];</span><br><span class="line">y2=x2(qujian,lb,ub,x2data)</span><br></pre></td></tr></table></figure><h4id="注意这里其实是两种方法1.可以先都变成效益型的然后用向量规划的那个式子算2.之间用向量规划算但是成本型的要将算出-来的b_ij变成1-b_ij前提是没有区间型要是有区间型就要先把区间型变成效益型">注意：这里其实是两种方法1.可以先都变成效益型的然后用向量规划的那个式子算2.之间用向量规划算，但是成本型的要将算出来的b_ij变成1-b_ij。前提是没有区间型，要是有区间型就要先把区间型变成效益型。</h4><h1 id="聚类分析">聚类分析</h1><ul><li>R型聚类作用：降维处理，将原来的变量变为某一个或某几个变量</li><li>Q型聚类作用：分类及分析(常用)</li></ul><h3 id="样品间的相似度量----距离">样品间的相似度量----距离</h3><ol type="1"><li><p><code>欧式距离 pdist(x)</code> <span class="math display">\[d(x_i,x_j)=|\sum_{k=I}^{P}{(x_{ik}-x{jk})^2}|^{I/2}\]</span></p></li><li><p>绝对距离 pdist(x,'cityblock') (几乎不用) <spanclass="math display">\[d(x_i,x_j)=\sum_{(k=I)}^{p}{|x_{ik}-x_{jk}|}\]</span></p></li><li><p>明氏距离 pdist(x,'minkowski',m) <span class="math display">\[d(x_i,x_j)=[\sum_{k=I}^{P}|x_{ik}-x_{jk}|^m]^{I/m}\]</span></p></li><li><p>切氏距离 max(abs(xi-xj)) <span class="math display">\[d(x_i,x_j)=max_{(I\leq k\leq p)}{|x_{ik}-x_{jk}|}\]</span></p></li><li><p>方差加权距离，将原数据标准化以后的欧式距离 <spanclass="math display">\[d(x_i,x_j)=[\sum_{k=I}^{p}{(x_{ik}-x_{jk})}^2/s_k^2]^{I/2}\]</span></p></li><li><p><code>马氏距离 pdist(x,'mahal')</code> <spanclass="math display">\[d(x_i,x_j)=\sqrt{(x_i-x_j)^T\Sigma_{-1}(x_i-x_j)}式子中\Sigma_{-1}为向量x和y的协方差矩阵的逆矩阵\]</span></p></li></ol><h6id="例题1.1为了研究辽宁浙江河南甘肃青海五省1991年城镇居民生活消费规律需要利用调查资料对五个省进行分类指标变量共8个意义如下x1人均粮食支出x2人均副食支出x3人均烟酒茶叶支出x4人均其他副食支出x5人均衣着商品支出x6人均日用品支出x7人均燃料支出x8人均非商品支出">例题1.1为了研究辽宁，浙江，河南，甘肃，青海五省1991年城镇居民生活消费规律，需要利用调查资料对五个省进行分类，指标变量共8个，意义如下：x1：人均粮食支出，x2：人均副食支出，x3：人均烟酒茶叶支出，x4：人均其他副食支出，x5：人均衣着商品支出，x6：人均日用品支出，x7：人均燃料支出，x8：人均非商品支出</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401291422917.png"alt="屏幕截图_20240129_141626" /><figcaption aria-hidden="true">屏幕截图_20240129_141626</figcaption></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d1=pdist(a)<span class="comment">%此时计算出各行之间的欧式距离,为了得到书中的距离矩阵，我们输入命令</span></span><br><span class="line">D=squareform(d1)<span class="comment">%注意此时d1必须是一个行向量，结果是实对称矩阵</span></span><br><span class="line">S=<span class="built_in">tril</span>(squareform(d1))<span class="comment">%若想要得到三角阵</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401291440363.png" /></p><h4 id="类间距离">类间距离</h4><h5id="d_ij表示两个样品x_ix_j之间的距离g_pg_q分别表示两个类别各自含有n_pn_q个样品">d_ij表示两个样品x_i,x_j之间的距离，G_p,G_q分别表示两个类别，各自含有n_p,n_q个样品</h5><ul><li><h5id="最短距离-即用两类中样品之间的距离最短者作为两类间的距离">最短距离:即用两类中样品之间的距离最短者作为两类间的距离</h5></li><li><h5id="最长距离即用两类中样品之间的距离最长者作为两类间的距离">最长距离：即用两类中样品之间的距离最长者作为两类间的距离</h5></li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401291532316.png" /></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401291533770.png"alt="屏幕截图_20240129_153220" /><figcaption aria-hidden="true">屏幕截图_20240129_153220</figcaption></figure><ul><li><h5id="类平均距离即用两类中所有两两样品之间距离的平均作为两类间距离">类平均距离：即用两类中所有两两样品之间距离的平均作为两类间距离</h5></li><li><h5id="重心距离两类的重心之间的欧式距离作为两类的距离">重心距离：两类的重心之间的欧式距离作为两类的距离</h5></li></ul><h3 id="常见聚类方法的步骤">常见聚类方法的步骤</h3><h4 id="谱系聚类法"><code>谱系聚类法</code></h4><p>1.选择样本间距离的定义(一般为欧氏距离)及类间距离的定义(一般为最短距离)</p><p>2.计算n个样本两两间的距离，得到距离矩阵D=(d_ij)</p><p>3.构造个类，每类只含有一个样本</p><p>4.合并符合类间距离定义要求的两个类作为一个新类</p><p>5.计算新类与当前各类的距离。若类的个数为1，则转到步骤6，否则回到步骤4</p><p>6.画出聚类图</p><p>7.决定类的个数和类</p><h6id="例题1.1.2为了研究辽宁等5省1991年成长居民生活消费情况的分布规律根据调查资料做类型分类用最短距离做类间分类数据如表1">例题1.1.2为了研究辽宁等5省1991年成长居民生活消费情况的分布规律，根据调查资料做类型分类，用最短距离做类间分类，数据如表1</h6><h6id="将每个省视为一个样品先计算5个省区之间的欧氏距离用d0表示距离矩阵前一问已经构建出来可得">将每个省视为一个样品，先计算5个省区之间的欧氏距离，用D0表示距离矩阵(前一问已经构建出来)，可得：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     (1)   (2)   (3)   (4)   (5)</span><br><span class="line">(1)   0</span><br><span class="line">(2) 11.67   0</span><br><span class="line">(3) 13.80 24.63   0</span><br><span class="line">(4) 13.12 24.06  2.20    0</span><br><span class="line">(5) 12.80 23.54  3.51   2.21   0</span><br></pre></td></tr></table></figure><p>D0(3,4)=2.20最小因此要把3，4合并为一类,为类6，代替了3，4两类。</p><p>类6与剩余的1，2，5之间的距离分别为：</p><p>d(3,4)_1=min(d31,d41)=min(13.80,13.12)=13.12</p><p>d(3,4)_2=min(d32,d42)=min(24.63,24.06)=24.06</p><p>d(3,4)_5=min(3.51,2.21)=min(3.51,2.21)=2.21</p><h6 id="得到一个新矩阵">得到一个新矩阵：</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D1：</span><br><span class="line">       G6     G1    G2    G5</span><br><span class="line">G6      <span class="number">0</span></span><br><span class="line">G1    <span class="number">13.12</span>    <span class="number">0</span></span><br><span class="line">G2    <span class="number">24.06</span>  <span class="number">11.67</span>   <span class="number">0</span></span><br><span class="line">G5    <span class="number">2.21</span>   <span class="number">12.80</span>  <span class="number">23.54</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>D1(6,5)=2.21最小因此要把6，5合并成一类，为类7，代替了6，5两类</p><p>类7与剩余的1，2之间的距离分别为:</p><p>d(5,6)_1=min(d51,d61)=min(12.80,13.12)=12.80</p><p>d(5,6)_2=min(d52,d62)=min(23.54,24.06)=23.54</p><h6 id="再得到一个新矩阵">再得到一个新矩阵：</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D2:</span><br><span class="line">      G7     G1     G2</span><br><span class="line">G7    <span class="number">0</span></span><br><span class="line">G1   <span class="number">12.80</span>    <span class="number">0</span></span><br><span class="line">G2   <span class="number">23.54</span>  <span class="number">11.67</span>    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>D2(1,2)=11.67最小因此要把1，2合并成一类，为类8，代替了1，2两类</p><h6id="此时我们有两个不同的类类7和类8它们的距离">此时，我们有两个不同的类，类7和类8，它们的距离</h6><p>d(7,8)=min(d71,d72)=min(12.80,23.54)=12.80</p><h6 id="最后得到新矩阵">最后得到新矩阵：</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       G7     G8</span><br><span class="line">G7      <span class="number">0</span></span><br><span class="line">G8    <span class="number">12.80</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure><p>最后合并成一个大类。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%谱系聚类的MATLAB实现</span></span><br><span class="line"><span class="comment">%1.输入数据矩阵，注意行与列的实际意义</span></span><br><span class="line"><span class="comment">%2.计算各样品之间的距离，这里用的是欧式</span></span><br><span class="line">d=pdist(A);<span class="comment">%欧式距离</span></span><br><span class="line"><span class="comment">%以上命令输出结果是一个行向量，如果要得到距离矩阵，可以用命令</span></span><br><span class="line">D=squareform(d);</span><br><span class="line"><span class="comment">%三角阵的命令为</span></span><br><span class="line">D=<span class="built_in">tril</span>(squareform(d1))<span class="comment">%下三角函数</span></span><br><span class="line"><span class="comment">%选择不同的类间距离进行聚类，这里用的是最短距离</span></span><br><span class="line">z1=linkage(d);<span class="comment">%不仅把最短距离做出了了，而且把分类结果也做出来了</span></span><br><span class="line"><span class="comment">%作出谱系聚类图</span></span><br><span class="line">H=cluster(z,k)<span class="comment">%k是分类数目，z是最短距离的结果</span></span><br><span class="line">Find(T==k0)<span class="comment">%找出属于第k0类的样品编号</span></span><br><span class="line"><span class="comment">%输出分类结果</span></span><br><span class="line">T=cluster(z1,<span class="number">3</span>)<span class="comment">%结果表明，若分为3类，辽宁是一类，浙江是一类，河南，甘肃，青海是一类</span></span><br></pre></td></tr></table></figure><h5 id="以下为z1linkaged的聚类结果">以下为z1=linkage(d)的聚类结果</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401301406286.png" /></p><h4 id="k-平均聚类法"><code>K-平均聚类法</code></h4><ol type="1"><li>从n个数据对象任意选择k个对象作为初始聚类中心</li><li>循环3和4直到每个聚类不再发生变化为止</li><li>根据每个聚类对象的均值(中心对象)，计算每个对象与这些中心对象的距离，并根据最小距离重新对相应对象进行分析（第一次中心对象是指定的，之后中心对象是分配到每个类的对象的平均值，进行不断的更新中心对象）</li><li>重新计算每个(有变化)聚类的均值(中心对象)</li></ol><h5id="注意只适应于聚类均值有意义的场合当数据集中包含符号属性时直接应用k-means算法就有问题用户必须事先指定k的个数对噪声和孤立点数敏感少量的该类数据能够对聚类均值起到很大影响刚开始取中心对象可以不是样本点"><code>注意</code>:只适应于聚类均值有意义的场合，当数据集中包含<code>符号属性</code>时，直接应用k-means算法就有问题；用户必须<code>事先指定k的个数</code>；<code>对噪声和孤立点数敏感</code>，少量的该类数据能够对聚类均值起到很大影响；刚开始取中心对象可以不是样本点</h5><h6id="例题1.2假设空间数据对象分布如图a所示设k3也就是需要将数据集划分为三份聚类">例题1.2假设空间数据对象分布如图(a)所示，设k=3，也就是需要将数据集划分为三份(聚类)</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401301427426.png" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">clear all</span><br><span class="line">clc</span><br><span class="line">x=[<span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">0</span>  <span class="number">9</span>;<span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">7</span>  <span class="number">7</span>  <span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">9</span>  <span class="number">9</span>];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x(<span class="number">1</span>,:),x(<span class="number">2</span>,:),<span class="string">&#x27;r*&#x27;</span>)<span class="comment">%横轴为第一行所有列，纵轴为第二行所有列，红色星号表示</span></span><br><span class="line"><span class="comment">%%第一步选取聚类中心，即令K=2</span></span><br><span class="line">z1=[x(<span class="number">1</span>,<span class="number">1</span>);x(<span class="number">2</span>,<span class="number">1</span>)];</span><br><span class="line">z2=[x(<span class="number">1</span>,<span class="number">2</span>);x(<span class="number">2</span>,<span class="number">2</span>)];<span class="comment">%聚类中心为z1(0,0) z2(0,1)</span></span><br><span class="line">R1=[];</span><br><span class="line">R2=[];<span class="comment">%分成两个聚类，用于储存成员</span></span><br><span class="line">t=<span class="number">1</span></span><br><span class="line">K=<span class="number">1</span>;<span class="comment">%记录迭代的次数</span></span><br><span class="line">dif1=<span class="built_in">inf</span>;<span class="comment">%inf为正无穷</span></span><br><span class="line">dif2=<span class="built_in">inf</span>;</span><br><span class="line"><span class="comment">%%第二步计算各点与聚类中心的距离</span></span><br><span class="line"><span class="comment">%(inf表示最大值，eps表示最小值)只要两次聚类中心不等构成无限循环</span></span><br><span class="line"><span class="keyword">while</span>(dif1&gt;<span class="built_in">eps</span>&amp;dif2&gt;<span class="built_in">eps</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">20</span></span><br><span class="line">dist1=<span class="built_in">sqrt</span>((x(<span class="number">1</span>,<span class="built_in">i</span>)-Z1(<span class="number">1</span>)).^<span class="number">2</span>+(x(<span class="number">2</span>,<span class="built_in">i</span>)-Z1(<span class="number">2</span>)).^<span class="number">2</span>);</span><br><span class="line">dist2=<span class="built_in">sqrt</span>((x(<span class="number">1</span>,<span class="built_in">i</span>)-Z2(<span class="number">1</span>)).^+(x(<span class="number">2</span>,<span class="built_in">i</span>)-Z2(<span class="number">2</span>)).^<span class="number">2</span>);</span><br><span class="line">temp=[x(<span class="number">1</span>,<span class="built_in">i</span>),x(<span class="number">2</span>,<span class="built_in">i</span>)]&#x27;;</span><br><span class="line"><span class="keyword">if</span> dist1&lt;dist2</span><br><span class="line">R1=[R1,temp];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">R2=[R2,temp];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Z11=<span class="built_in">mean</span>(R1,<span class="number">2</span>);<span class="comment">%mean(A,2)包含每一行的平均值的列向量(对行求平均值)</span></span><br><span class="line">Z22=<span class="built_in">mean</span>(R2,<span class="number">2</span>);<span class="comment">%得到新的聚类中心</span></span><br><span class="line">t1=z1-z11;<span class="comment">%%测试两次是不是相等，可以有多种方法这里只简单的列举一种</span></span><br><span class="line">t2=z2-z22;</span><br><span class="line">dif1=<span class="built_in">sqrt</span>(<span class="built_in">dot</span>(t1,t1));<span class="comment">%dot两个向量的点积</span></span><br><span class="line">dif2=<span class="built_in">sqrt</span>(<span class="built_in">dot</span>(t2,t2));</span><br><span class="line">Z1=z11;</span><br><span class="line">Z2=z22;</span><br><span class="line">K=K+<span class="number">1</span>;</span><br><span class="line">R1=[];</span><br><span class="line">R2=[];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([Z1(<span class="number">1</span>),Z2(<span class="number">1</span>)],[Z2(<span class="number">2</span>),Z2(<span class="number">2</span>)],<span class="string">&#x27;g+&#x27;</span>)<span class="comment">%最终得到的聚类中心用绿色加号</span></span><br></pre></td></tr></table></figure><h3 id="变量间的相似度量----相似系数">变量间的相似度量----相似系数</h3><h5id="当对p个指标变量进行聚类时用相似系数来衡量变量之间的相似程度关联度若用-c_alpha-beta表示变量之间的相似系数则应满足">当对p个指标变量进行聚类时，用相似系数来衡量变量之间的相似程度(关联度)，若用<span class="math inline">\(C_{\alpha\beta}\)</span>表示变量之间的相似系数，则应满足</h5><p><span class="math display">\[|C_{\alpha\beta}|\leq1且C_{\alpha\alpha}=1\\C_{\alpha\beta}=\pm1,当且仅当\alpha=k\beta,k\neq0\\C_{\alpha\beta}=C_{\beta\alpha}\]</span></p><h5id="两个变量完全相似一个变量由另一个变量乘以一个整数得到此时相似系数为1"><code>两个变量完全相似(一个变量由另一个变量乘以一个整数得到)，此时相似系数为1</code></h5><h4id="相似系数中最常用的是相关系数与夹角余弦">相似系数中最常用的是相关系数与夹角余弦</h4><ul><li>两变量的夹角余弦定义为</li></ul><p><span class="math display">\[C_{ij}(1)=\cos\alpha_{ij}=\frac{\sum_{(t=1)}^{n}{x_{ti}x_{tj}}}{\sqrt{\sum_{t=1}^{n}{x_{ti}^{n}}}\sqrt{\sum_{t=1}^{n}{x_{tj}^2}}}\]</span></p><ul><li>两变量的相关系数定义</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401291505174.png" /></p><h6id="计算例题1中各指标之间的相关系数与夹角余弦">计算例题1中各指标之间的相关系数与夹角余弦</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">7.9</span>   <span class="number">39.77</span>  <span class="number">8.49</span>  <span class="number">12.94</span> <span class="number">19.27</span> <span class="number">11.05</span> <span class="number">2.04</span> <span class="number">13.29</span></span><br><span class="line">   <span class="number">7.68</span>  <span class="number">50.37</span>  <span class="number">11.35</span> <span class="number">13.3</span>  <span class="number">19.25</span> <span class="number">14.59</span> <span class="number">2.75</span> <span class="number">14.87</span></span><br><span class="line">   <span class="number">9.42</span>  <span class="number">27.93</span>  <span class="number">8.2</span>   <span class="number">8.14</span>  <span class="number">16.17</span> <span class="number">9.42</span>  <span class="number">1.55</span> <span class="number">9.76</span></span><br><span class="line">   <span class="number">9.16</span>  <span class="number">27.98</span>  <span class="number">9.01</span>  <span class="number">9.32</span>  <span class="number">15.99</span> <span class="number">9.1</span>   <span class="number">1.82</span> <span class="number">11.35</span></span><br><span class="line">   <span class="number">10.06</span> <span class="number">28.64</span>  <span class="number">10.52</span> <span class="number">10.05</span> <span class="number">16.18</span> <span class="number">8.39</span>  <span class="number">1.96</span> <span class="number">10.81</span>]</span><br><span class="line">R=corrcoef(a);<span class="comment">%指标之间的相关系数</span></span><br><span class="line">a1=normc(a);<span class="comment">%将a的各列化为单位向量</span></span><br><span class="line">J=a1&#x27;*a1<span class="comment">%计算a中各列之间的夹角余弦</span></span><br></pre></td></tr></table></figure><h1 id="gm11灰色预测">GM(1,1)灰色预测</h1><h5id="灰色预测法用等时距观测到的反应预测对象特征的一系列数量值构造灰色预测模型预测未来某一时刻的特征值或达到某一特征量的时间">灰色预测法用等时距观测到的反应预测对象特征的一系列数量值构造灰色预测模型，预测未来某一时刻的特征值，或达到某一特征量的时间</h5><h4 id="灰色预测的四种常见类型">灰色预测的四种常见类型</h4><ul><li>灰色时间序列预测：即用观察到的反映预测对象特征的时间序列来构造灰色预测模型，预测未来某一时刻的特征量，或达到某一特征量的时间</li><li>畸变预测：即通过灰色模型预测异常值出现的时刻，预测异常值什么时候出现在特定时区内(异常气候，预测零件问题时间)</li><li>系统预测：通过对系统行为特征指标建立一组相互关联的灰色预测模型，预测系统中众多变量之间的相互协调关系的变化(用的次数比较少)</li><li>拓扑预测：将原始数据做曲线，在曲线上按定值寻找该定值发生的所有时点，并以该定值为框架构成时点数列，然后建立模型预测该定值所发生的时点</li></ul><h5 id="灰色关联度"><code>灰色关联度</code>:</h5><p><spanclass="math inline">\(\zeta_i(k)=\frac{min_imin_k|X_0(k)-X_i(k)|+\rhomax_imax_k|X_0(k)-X_i(k)|}{|X_0(k)-X_i(k)|+\rhomax_imax_k|X_0(k)-X_i(k)|}\)</span></p><p><spanclass="math inline">\(X_0(k)表示标准数列中的第k个元素，例如：x_0(1)为标准列中的第一个元素\\假设有m个比较数列X_i(k)表示第i个数列中的第k个元素(i=1,2,...,m),\rho一般取0.5\)</span></p><h6id="上述式子中min_imin_kx_0k-x_ik表示先找出每个比较数列中的每个元素和标准数列中每个元素差值的最小值再找出这些元素中的最小值"><spanclass="math inline">\(上述式子中min_imin_k|X_0(k)-X_i(k)|表示先找出每个比较数列中的每个元素和标准数列中每个元素差值的最小值再找出这些元素中的最小值\)</span></h6><h6id="例题利用灰色关联分析对6位教师工作状况进行综合分析">例题利用灰色关联分析对6位教师工作状况进行综合分析</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401311554441.png" /></p><h5 id="确定参考数列x_09-9-9-9-8-9-9">1.确定参考数列{x_0}={9 9 9 9 8 99}</h5><h5 id="计算x_0k-x_jk见下表">2.计算<spanclass="math inline">\(|x_0(k)-x_j(k)|\)</span>见下表</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401311556040.png" /></p><h5 id="求最值">3.求最值</h5><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401311600634.png"alt="屏幕截图_20240131_155850" /><figcaption aria-hidden="true">屏幕截图_20240131_155850</figcaption></figure><h5 id="带入上述公式得">4.带入上述公式得</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401311559975.png" /></p><p><code>注意</code>：这里给出的只有第一个老师的数据还要求<spanclass="math inline">\(\zeta_2(k),\zeta_3(k)...,\zeta_6(k)其中k=1,2,...,7\)</span>结果如下</p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401311609065.png" /></p><h5id="分别计算每个人各指标关联系数的均值关联序">5.分别计算每个人各指标关联系数的均值(关联序)：</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401311611514.png" /></p><h3id="灰色生成数列一切灰色序列都能通过某种生成弱化其随机性显现其规律性数据生成的常用方式有累加生成累减生成和加权累加生成">灰色生成数列：一切灰色序列都能通过某种生成弱化其随机性，显现其规律性。数据生成的常用方式有<code>累加生成,累减生成，和加权累加生成</code></h3><ul><li><h5id="累加生成ago把数列各项时刻数据依次累加的过程称为累加生成过程">累加生成(AGO)：把数列各项(时刻)数据<code>依次累加</code>的过程称为累加生成过程</h5><span class="math display">\[x^{(1)}{(k)}=\sum_{i=1}^{k}{x^{(0)}(i)},k=1,2,...,n\\称所得到的新数列为数列x^{(0)}的一次累加数列，类似的有\\x^{(r)}{(k)}=\sum_{i=1}^{k}{x^{(r-1)}(i)},k=1,2,...,n,r\geq1\\称为原始数列x^{(0)}的第r次累加数列\\例:x^{(0)}=[1,2,3,4 ...],则经过累加后x^{(1)}=[1,3,6,10...]\]</span></li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402011419368.png" /></p><ul><li><h5id="累减生成iago对于原始数据列依次做前后相邻的两个数据相减的运算过程称为累减生成过程">累减生成(IAGO):对于原始数据列依次做<code>前后相邻的两个数据相减</code>的运算过程称为累减生成过程</h5></li></ul><p><span class="math display">\[如果原始数列为:x^{(1)}=(x^{(1)}(1),x^{(1)}(2),x^{(1)}(3)...,x^{(1)}(n))\\令x^{(0)}{k}=x^{(1)}{(k)}-x^{(1)}{(k-1)},k=2,3,...,n\\累减(或累加)后的数列第一个数为原始数据第一个数\\例如:x^{(1)}=[1,2,3,4],经过累减后x^{(0)}=[1,1,1,1]\]</span></p><h6id="注意从这里的记号可以看到从原始数列x0得到新数列x1在通过累减生成可以还原出原始序列实际运用在数列x1的基础上预测出x1通过累减生成得到预测数列x0"><code>注意:</code>从这里的记号可以看到，从原始数列x(0)得到新数列x(1)，在通过累减生成可以还原出原始序列。<spanclass="math inline">\(实际运用在数列x^{(1)}的基础上预测出x^{(&lt;1&gt;)},通过累减生成得到预测数列x^{0}\)</span></h6><ul><li><h5 id="加权邻值生成">加权邻值生成</h5><span class="math display">\[设原始数列为x^{(0)}=(x^{(0)}(1),x^{(0)}(2),x^{(0)}(3),...,x^{(0)}(n))\\称x^{(0)}(k-1),x^{(0)}(k)为数列x^{(0)}的任意一对邻值，x^{(0)}(k-1)为后邻值，x^{(0)}(k)为前邻值\\对于常数\alpha 属于[0,1]区间内，令z^{(0)}(k)=\alphax^{(0)}(k)+(1-\alpha)x^{(0)}(k-1),k=2,3,...,n\\由此得到的数列z^{(0)}称为数列x^{(0)}在权值\alpha下的邻值生成数，权\alpha也称为生成系数\\特别地，当生成系数\alpha=0.5时，则称z^{(0)}(k)=0.5x^{(0)}(k)+0.5x^{(0)}(k-1),k=2,3,...,n为均值生成数，也称等权邻值生成树\\例如x^{(0)}=[1,2,3,4],z^{(0)}=[0.5,1.5,2.5,7.5]\]</span></li></ul><h3id="灰色生成数列的后续构建函数由微分函数构成"><code>灰色生成数列的后续构建函数由微分函数构成</code></h3><ul><li><h5id="定义累加后数列x1的灰导数为dkx0kx1k-x1k-1">定义累加后数列x(1)的灰导数为：<spanclass="math inline">\(d(k)=x^{(0)}{k}=x^{(1)}(k)-x^{(1)}(k-1)\)</span></h5></li><li><h5id="定义邻值生成后数列z0的灰导数为x0kaz1kb其中x0为灰导数a为发展系数z1k称为白化背景值b称为灰作用量灰色导数方程中只有a和b两个未知量但是实际给的方程预测点很多这样就存在多余方程和多余解-----用最小二乘法求解多余解">定义邻值生成后数列z(0)的灰导数为：<spanclass="math inline">\(x^{(0)}{k}+az^{(1)}(k)=b,其中x^{(0)}为灰导数a为发展系数，z^{(1)}{(k)}称为白化背景值，b称为灰作用量\)</span>灰色导数方程中只有a和b两个未知量但是实际给的方程预测点很多，这样就存在多余方程和多余解-----用最小二乘法求解多余解</h5></li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402011439217.png" /></p><h4 id="最小二乘得到utabtbbt-1bty"><code>最小二乘得到:</code><spanclass="math inline">\(u^T=(a,b)^T=(BB^T)^{-1}B^TY\)</span></h4><p><span class="math display">\[GM(1,1)的灰微分方程对应于的白微分方程为:\\\frac{dx^{(1)}{(t)}}{dt}+ax^{(1)}{(t)}=b\]</span></p><h3 id="gm11灰色预测的步骤">GM(1,1)灰色预测的步骤</h3><ol type="1"><li><h4 id="数据的检验与处理">数据的检验与处理</h4><p><span class="math display">\[设原始序列为x^{(0)}=(x^{(0)}{(1)},x^{(0)}{(2)},...,x^{(0)}{(n)})\\计算数列的级比:\\\lambda{(k)}=\frac{x^{(0)}{(k-1)}}{x^{(0)}{(k)}},k=2,3,...,n\\如果所有的级比都落在可容覆盖区间X=(e^{\frac{-2}{n+1}},e^{\frac{2}{n+1}})\\否则对数据做适当的变换处理，如平移变换(加减一共数c):\\y^{(0)}{(k)}=x^{(0)}{(k)}+c,k=1,2,...,n,使得符合级比检验\]</span></p></li><li><h4 id="构造数据矩阵b和数据向量y">构造数据矩阵B和数据向量Y</h4><h6 id="这里用一个例题来说明">这里用一个例题来说明：</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402021451154.jpg"alt="CSDN_1706856538710" /><figcaption aria-hidden="true">CSDN_1706856538710</figcaption></figure><ul><li><p>数据矩阵B的构造方法：</p><ul><li><p>对原始序列做一次累加： <span class="math display">\[x^{(1)}{(k)}=\sum_{m=1}^{k}{x^{(0)}}{(m)},k=1,2,...,7\\得到:X^{(1)}=(x^{(1)}{(1)},x^{(1)}{(2)},...,x^{(1)}{(7)})={71.1,143.5,215.9,288,359.4,431.4,503}\]</span></p></li><li><p>用加权临值生成：这里<spanclass="math inline">\(\alpha=0.5,Y=\alpha(x^{(1)}(1)+x^{(1)}(2))...\)</span></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402021455406.jpg"alt="CSDN_1706856645517" /><figcaption aria-hidden="true">CSDN_1706856645517</figcaption></figure></li></ul></li></ul><h6 id="最后得到y和b">最后得到:Y和B</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402021500010.jpg"alt="CSDN_1706856647371" /><figcaption aria-hidden="true">CSDN_1706856647371</figcaption></figure></li><li><h4 id="其中ab用最小二乘法得到">其中a，b用最小二乘法得到：</h4><p><span class="math display">\[P=(a,b)^T=(BB^T)^{-1}B^TY=\\(0.00234379\\72.6572696)\]</span></p></li><li><h4 id="建立gm11模型">建立GM(1,1)模型</h4><p><span class="math display">\[不妨设x^{(0)}=(x^{(0)}{(1)},x^{(0)}{(2)},...,x^{(0)}{(n)})满足级比，以它为数列建立GM(1,1)模型\\x^{(0)}{(k)}+az^{(1)}{(k)}=b\\相应的白化模型为:\\\frac{dx^{(1)}{(t)}}{dt}+ax^{(1)}{(t)}=b\\得到时间响应序列:x^{(1)}{(t)}=(x^{(0)}{(1)}-\frac{b}{a})e^{-a(t-1)}+\frac{b}{a}\\\]</span></p></li><li><h4 id="得到预测">得到预测</h4></li></ol><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402021423379.png" /></p><h5id="其中x11x01x1171.1得到x1k1-30928.85259e-0.00234379k30999.95259">其中x^<sup>(1)</sup>(1)=x^<sup>(0)</sup>(1)=x<sup>(1)</sup>(1)=71.1得到:x^<sup>(1)</sup>(k+1)=-30928.85259e<sup>-0.00234379k</sup>+30999.95259</h5><h1 id="插值与拟合基本原理">插值与拟合基本原理</h1><h2id="插值问题已知函数在某区域内若干点处的值求函数在该区间内其他点处的值">插值问题(已知函数在某区域内若干点处的值，求函数在该区间内其他点处的值)</h2><h5id="注意因为runge不应该使用七次以上的差值为避免这一现象常用的方法是将差值区间分成若干小区间在小区间内用低次差值">注意因为Runge不应该使用七次以上的差值，为避免这一现象常用的方法是：将差值区间分成若干小区间，在小区间内用低次差值</h5><h6id="例题1.1在一天24小时内从零点开始每间隔2小时测得的环境温度数据分别为129910182428272520181513推测中午1点温度并作出24小时温度变化曲线图">例题1.1在一天24小时内，从零点开始每间隔2小时测得的环境温度数据分别为12，9，9，10，18，24，28，27，25，20，18，15，13推测中午1点温度，并作出24小时温度变化曲线图</h6><h3 id="matlab差值">matlab差值</h3><ul><li>一维插值命令是interp1,其基本格式是<spanclass="math inline">\(yi=interp1(x,y,xi,&#39;method&#39;)\)</span>,其中x，y为已知点坐标，xi为要差值点，通常x,y,xi为向量，'method'表示插值方法：'nearest'为最邻近插值，'linear'为线性插值，'spline'为三次样条插值，'cubic'为立法插值，缺省为线性插值</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">2</span>:<span class="number">24</span>;</span><br><span class="line">y=[<span class="number">12</span> <span class="number">9</span> <span class="number">9</span> <span class="number">10</span> <span class="number">18</span> <span class="number">24</span> <span class="number">28</span> <span class="number">27</span> <span class="number">25</span> <span class="number">20</span> <span class="number">18</span> <span class="number">15</span> <span class="number">13</span>];</span><br><span class="line">x1=<span class="number">13</span>;</span><br><span class="line">y1=interp1(x,y,x1,<span class="string">&#x27;spline&#x27;</span>)</span><br><span class="line">xi=<span class="number">0</span>:<span class="number">1</span>/<span class="number">3600</span>:<span class="number">24</span>;<span class="comment">%从0开始每次增加3600分之一到24</span></span><br><span class="line">yi=interp1(x,y,xi,<span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;*&#x27;</span>,xi,yi)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plane</span></span></span><br><span class="line">x0=[<span class="number">0</span> <span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>];</span><br><span class="line">y0=[<span class="number">0</span> <span class="number">1.2</span> <span class="number">1.7</span> <span class="number">2.0</span> <span class="number">2.1</span> <span class="number">2.0</span> <span class="number">1.8</span> <span class="number">1.2</span> <span class="number">1.0</span> <span class="number">1.6</span>];</span><br><span class="line">x=<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">15</span>;</span><br><span class="line">y1=lagrange(x0,y0,x);<span class="comment">%拉格朗日插值</span></span><br><span class="line">y2=interp1(x0,y0,x);<span class="comment">%缺省用线性插值</span></span><br><span class="line">y3=interp1(x0,y0,x,<span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>);<span class="comment">%作出三行一列的图</span></span><br><span class="line"><span class="built_in">plot</span>(x0,y0,<span class="string">&#x27;k+&#x27;</span>,x,y1,<span class="string">&#x27;r&#x27;</span>);<span class="comment">%第一个图放上拉格朗日插值出的,&#x27;k+&#x27;为黑色</span></span><br><span class="line">grid;<span class="comment">%加上网格</span></span><br><span class="line">title(<span class="string">&#x27;lagrange&#x27;</span>);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">%第二个图放的是如下内容</span></span><br><span class="line"><span class="built_in">plot</span>(x0,y0,<span class="string">&#x27;k+&#x27;</span>,x,y2,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">grid;</span><br><span class="line">title(<span class="string">&#x27;piecewisee linear&#x27;</span>);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">%第三个图放的是如下内容</span></span><br><span class="line"><span class="built_in">plot</span>(x0,y0,<span class="string">&#x27;k+&#x27;</span>x,y3,<span class="string">&#x27;r&#x27;</span>);<span class="comment">%样条函数插值出来的</span></span><br><span class="line">grid;</span><br><span class="line">title(<span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">lagrange</span><span class="params">(x0,y0,x)</span>%如下是拉格朗日函数的步骤,先建立这个函数，再输入上述代码</span></span><br><span class="line">n=<span class="built_in">length</span>(x0);m=<span class="built_in">length</span>(x);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line">  z=x(<span class="built_in">i</span>);</span><br><span class="line">  s=<span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span> k=<span class="number">1</span>:n</span><br><span class="line">    p=<span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">     <span class="keyword">if</span> <span class="built_in">j</span>~=k</span><br><span class="line">       p=p*(z-x0(<span class="built_in">j</span>))/(x0(k)-x0(<span class="built_in">j</span>));</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    s=p*y0(k)+s;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">  y(<span class="built_in">i</span>)=s;</span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272209118.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272209960.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272209665.png" /></p><ul><li>二维插值命令是interp2，基本格式为<spanclass="math inline">\(zi=interp2(x,y,z,xi,yi,&#39;method&#39;)\)</span>x,y,z为插值点，z可以理解为被插值函数在(x,y)处的值，xi,yi为被插值点，zi为输出的插值结果，可以理解为插值函数在(xi,yi)处的值，x,y为向量，xi,yi为向量或矩阵，而z和zi则为矩阵，'method'表示插值方法：'nearest'为最邻近插值，'linear'为双线性插值，'spline'为双三次样条插值，默认为线性</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">y=<span class="number">1</span>:<span class="number">3</span>;<span class="comment">%x有5个数，y有3个数，可以构建出15个点</span></span><br><span class="line">temps=[<span class="number">82</span> <span class="number">81</span> <span class="number">80</span> <span class="number">82</span> <span class="number">84</span>；<span class="number">79</span> <span class="number">63</span> <span class="number">61</span> <span class="number">65</span> <span class="number">81</span>；<span class="number">84</span> <span class="number">84</span> <span class="number">82</span> <span class="number">85</span> <span class="number">86</span>];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">mesh(x,y,temps);</span><br><span class="line">xi=<span class="number">1</span>:<span class="number">0.2</span>:<span class="number">5</span>;</span><br><span class="line">yi=<span class="number">1</span>:<span class="number">0.2</span>:<span class="number">3</span>;</span><br><span class="line">zi=interp2(x,y,temps,xi,yi,<span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">mesh(xi,yi,zi);<span class="comment">%plot3为空间曲线,mesh为空间曲面网格图,surf为空间曲面表面图,contour为等高线,以上为三维图的画图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">contour(xi,yi,zi,<span class="number">20</span>,<span class="string">&#x27;r&#x27;</span>);<span class="comment">%建立20条等高线，把zi相等的链接起来，等高线不会相互链接,&#x27;r&#x27;为颜色</span></span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">find</span>(zi==<span class="built_in">min</span>(<span class="built_in">min</span>(zi)));<span class="comment">%min(zi)为这一列的最小值则min(min(zi))为所有最小值</span></span><br><span class="line">x=xi(<span class="built_in">j</span>),y=yi(<span class="built_in">i</span>),zmin=zi(<span class="built_in">i</span>,<span class="built_in">j</span>)</span><br><span class="line">[<span class="built_in">i</span>,<span class="built_in">j</span>]=<span class="built_in">find</span>(zi==<span class="built_in">max</span>(<span class="built_in">max</span>(zi)));</span><br><span class="line">x=xi(<span class="built_in">j</span>),y=yi(<span class="built_in">i</span>),zmax=zi(<span class="built_in">i</span>,<span class="built_in">j</span>)</span><br></pre></td></tr></table></figure><h6id="例题1.2在某山区测得一些地点的高程如下表平面区域为0x56000y4800用matlab中的最邻近邻值双线性插值和双三次插值三种方法作出该山区的地貌图和等高线图并求出最高点和最低点">例题1.2在某山区测得一些地点的高程如下表，平面区域为0&lt;x&lt;5600,0&lt;y&lt;4800,用matlab中的最邻近邻值，双线性插值和双三次插值三种方法作出该山区的地貌图和等高线图，并求出最高点和最低点</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281239830.png"alt="屏幕截图_20240228_123722" /><figcaption aria-hidden="true">屏幕截图_20240228_123722</figcaption></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>:<span class="number">400</span>:<span class="number">5600</span>;</span><br><span class="line">y=<span class="number">0</span>:<span class="number">400</span>:<span class="number">4800</span>;</span><br><span class="line">z=[如上图];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">meshz(x,y,z);</span><br><span class="line">xlable(<span class="string">&#x27;X&#x27;</span>),ylable(<span class="string">&#x27;Y&#x27;</span>),zlable(<span class="string">&#x27;Z&#x27;</span>);<span class="comment">%横轴坐标的名字叫X...</span></span><br><span class="line">[xi,yi]=<span class="built_in">meshgrid</span>(<span class="number">0</span>:<span class="number">50</span>:<span class="number">5600</span>,<span class="number">0</span>:<span class="number">50</span>:<span class="number">4800</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">zli=interp2(x,y,z,xi,yi,<span class="string">&#x27;nearest&#x27;</span>);</span><br><span class="line">surfc(xi,yi,z1i);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>),ylabel(<span class="string">&#x27;Y&#x27;</span>),zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">z2i=interp2(x,y,z,xi,yi);</span><br><span class="line">surfc(xi,yi,z2i);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>),ylabel(<span class="string">&#x27;Y&#x27;</span>),zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line">z3i=interp2(x,y,z,xi,yi,<span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line">surfc(xi,yi,z3i);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>),ylabel(<span class="string">&#x27;Y&#x27;</span>),zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>),contour(xi,yi,z1i,<span class="number">10</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>),contour(xi,yi,z2i,<span class="number">10</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>),contour(xi,yi,z3i,<span class="number">10</span>,<span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><h5id="注意前面讨论的插值问题的插值点xy均为网格点当xy为散乱点时可用griddataxyzxiyimethod进行二维插值"><code>注意：</code>前面讨论的插值问题的插值点(x,y)均为网格点，当(x,y)为散乱点时可用<spanclass="math inline">\(griddata(x,y,z,xi,yi,&#39;method&#39;)\)</span>进行二维插值</h5><h6id="例题1.3在某海域测得一些点xy处的水深如下表船的吃水深度为5英尺在矩形区域75200-50150内的哪些地方船要避免进入">例题1.3在某海域测得一些点(x,y)处的水深如下表，船的吃水深度为5英尺，在矩形区域(75,200)*(-50,150)内的哪些地方船要避免进入</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281255809.png" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">x=[如上图];</span><br><span class="line">y=[如上图];</span><br><span class="line">z=[<span class="number">-4</span> <span class="number">-8</span> <span class="number">-6</span> <span class="number">-8</span> <span class="number">-6</span> <span class="number">-8</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">-9</span> <span class="number">-8</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">-4</span> <span class="number">-9</span>];<span class="comment">%先把z变成负数，再变成正数</span></span><br><span class="line">[xi,yi]=<span class="built_in">meshgrid</span>(<span class="number">75</span>:<span class="number">0.5</span>:<span class="number">200</span>,<span class="number">-50</span>:<span class="number">0.5</span>:<span class="number">150</span>);</span><br><span class="line">zi=griddata(x,y,z,xi,yi,<span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">meshz(xi,yi,zi);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>),ylabel(<span class="string">&#x27;Y&#x27;</span>),zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),contour(xi,yi,zi,[<span class="number">-5</span> <span class="number">-5</span>],<span class="string">&#x27;b&#x27;</span>);<span class="comment">%contour两种形式1.contour(xi,yi,zi,[k,k])指找出zi中为k的等高线(三维等高线图为二维)，这里指水深为-5的等高线2.contour(xi,yi,n)指画出n条等高线</span></span><br><span class="line">grid;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>),ylabel(<span class="string">&#x27;Y&#x27;</span>);</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281307921.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281309562.png" /></p><h2 id="拟合问题一般为2维">拟合问题(一般为2维)</h2><ul><li>小样本预测</li><li>拟合求导</li></ul><h6id="例题1.1从1点到12点每隔一个小时测量一次温度测得的温度依次为5891525293130222527">例题1.1从1点到12点每隔一个小时测量一次温度，测得的温度依次为:5,8,9,15,25,29,31,30,22,25,27</h6><h6id="每隔110小时的温度值并做出温度变化图形插值法这里就不写解答了">1.每隔1/10小时的温度值，并做出温度变化图形(插值法，这里就不写解答了)</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281935902.png" /></p><h6 id="推测t13.5时的温度拟合">2.推测t=13.5时的温度(拟合)</h6><h5id="高次插值出现了runge现象外推t12时的数据出现了巨大误差">高次插值出现了Runge现象，外推t&gt;12时的数据出现了巨大误差</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281935762.png" /></p><h5id="样条插值的第一个图表明样条插值可以很好地解决第一个问题但第二个图示显示用样条插值外推t12时数据也会产生较大误差">样条插值的第一个图表明样条插值可以很好地解决第一个问题，但第二个图示显示，用样条插值外推t&gt;12时数据也会产生较大误差</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281939964.png" /></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402281939674.png"alt="屏幕截图_20240228_193713" /><figcaption aria-hidden="true">屏幕截图_20240228_193713</figcaption></figure><h3id="拟合问题与插值问题的区别在于">拟合问题与插值问题的区别在于：</h3><ul><li>插值函数过已知点，而拟合函数不一定过已知点</li><li>插值主要用于求函数值，而拟合的主要目的是求函数关系，从而进行预测等下一步的分析</li></ul><h4id="线性拟合中参数的计算可采用最小二乘法而非线性拟合参数的计算则要用gauss-newton迭代法"><code>线性拟合中参数的计算可采用最小二乘法，而非线性拟合参数的计算则要用Gauss-Newton迭代法</code></h4><h3 id="matlab拟合线性">matlab拟合(线性)</h3><ul><li>多项式拟合:<spanclass="math inline">\([a,S]=polyfit(x,y,n)\)</span>,其中x和y是被拟合数据的自变量和因变量，n为拟合多项式的系数<code>例如:</code><spanclass="math inline">\(a_1+a_2x^2+a_3x^3+a_4x^4\)</span>中系数就是<code>4</code>，a为拟合多项式系数构成的向量，S为分析拟合效果所需要的指标(可省略)</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>:<span class="number">12</span>;</span><br><span class="line">y=[<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">15</span>,<span class="number">25</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">24</span>];</span><br><span class="line">a=polyfit(x,y,<span class="number">9</span>)<span class="comment">%插值才会出现Runge现象，现在是拟合，不会产生，9是自定义的</span></span><br><span class="line">xp=<span class="number">1</span>:<span class="number">0.1</span>:<span class="number">12</span>;</span><br><span class="line">yp=ployval(a,xp);<span class="comment">%y=polyval(p,x)计算多项式p在x的每个点处的值，参数p是长度为n+1的向量，其元素是n次多项式的系数</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;k&#x27;</span>,xp,yp,<span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402282037029.png" /></p><h3 id="matlab非线性拟合">matlab(非线性拟合)</h3><ul><li>命令格式为:<spanclass="math inline">\([b,r]=ployfit(x,y,fun,b0,option)\)</span>x,y为已知点坐标fun指拟合函数，b0为拟合参数的初始迭代值，option为拟合选项，b为拟合参数，r为拟合残差<ul><li>非线性函数需要提前把数据点展开</li><li>找近似的函数关系</li><li>从近似的函数关系(fun)找未知数和初值个数(x,b)<code>例如:</code><spanclass="math inline">\(e^{-b_1x}+b_2\)</span>其中未知数就是x，初值个数为2个(b1,b2),b1和b2可以随意赋值,fun的格式就为@(x,b)，<spanclass="citation"data-cites="为定义一个参数">@为定义一个参数</span>，有两个参数x和b</li></ul></li></ul><h6id="代码1.2其中的函数关系为b_1tfrac-tb_2b_3tfrac-tb_4b_5需要提前找到函数关系">代码1.2(其中的函数关系为：<spanclass="math inline">\(b_1t^{\frac{-t}{b_2}}+b_3t^{\frac{-t}{b_4}}+b_5,需要提前找到函数关系\)</span>)</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>:<span class="number">16</span>;</span><br><span class="line">y=[<span class="number">4.00</span> <span class="number">6.40</span> <span class="number">8.00</span> <span class="number">8.80</span> <span class="number">9.22</span> <span class="number">9.50</span> <span class="number">9.70</span> <span class="number">9.86</span> <span class="number">10.00</span> <span class="number">10.20</span> <span class="number">10.30</span> <span class="number">10.42</span> <span class="number">10.50</span> <span class="number">10.55</span> <span class="number">10.58</span> <span class="number">10.60</span>];</span><br><span class="line">y1=@(b,t)b(<span class="number">1</span>)*<span class="built_in">exp</span>(-t/b(<span class="number">2</span>))+b(<span class="number">3</span>)*<span class="built_in">exp</span>(-t/b(<span class="number">4</span>))+b(<span class="number">5</span>);</span><br><span class="line">b0=[<span class="number">-1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">a=polfit(x,y,y1,b0)</span><br><span class="line">xp=<span class="number">1</span>:<span class="number">0.1</span>:<span class="number">16</span>;<span class="comment">%待拟合坐标</span></span><br><span class="line">yp=y1(a,xp);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;k&#x27;</span>,xp,yp,<span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="matlab拟合可用工具cftool">matlab拟合可用工具：cftool</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402291414182.png" /></p><ul><li>RMSE剩余标准差误差</li><li>SSE平方和误差</li><li>R-square相关系数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;topsis算法&quot;&gt;TOPSIS算法&lt;/h1&gt;
&lt;h6
id=&quot;评价方法大体可以分为两类其主要区别在确定权重的方法上一类是主观赋权法如综合指数法模糊综合评判法层次分析法功效系数法等另一类是客观赋权根据各项指标间相关关系或各指标值变异程度确定权数如主成分分析法因</summary>
      
    
    
    
    <category term="数学建模学习" scheme="https://pipi1002.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学建模算法入门(1)</title>
    <link href="https://pipi1002.github.io/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95/"/>
    <id>https://pipi1002.github.io/2024/01/15/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95/</id>
    <published>2024-01-15T09:02:44.000Z</published>
    <updated>2024-02-29T06:39:39.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性规划模型基本原理lp">线性规划模型基本原理（LP）</h1><h3 id="在资源固定的利润最大化问题">在资源固定的利润最大化问题:</h3><h6id="例题1.1-某机床厂生产甲乙两种机床每台销售后的利润分别为4千元和3千元生产甲机床需要用ab机器加工加工时间分别为每台2小时和1小时生产乙机床需要abc三种机器加工加工时间为每台各一小时若每天用于加工的机器时数分别为a机器10小时b机器8小时和c机器7小时问该厂应生产甲乙机床各几台才能使总利润最大">例题1.1某机床厂生产甲，乙两种机床，每台销售后的利润分别为4千元和3千元。生产甲机床需要用A,B机器加工，加工时间分别为每台2小时和1小时；生产乙机床需要A,B,C三种机器加工，加工时间为每台各一小时。若每天用于加工的机器时数分别为A机器10小时，B机器8小时和C机器7小时，问该厂应生产甲，乙机床各几台，才能使总利润最大？</h6><p><span class="math display">\[max\quad z=4x_1+3x_2\quad (1.1)\\(1.2)\quad\left \{ \begin{array}{lr**}2x_1+x_2\leq 10\\x_1+x_2\leq 8\\x_2\leq 7\\x_1,x_2\geq 0\end{array} \right.\]</span></p><h6id="变量x1x2称之为决策变量1.1式被称为问题的目标函数1.2中的几个不等式是问题的约束条件记为s.t.">变量x1，x2称之为决策变量，（1.1）式被称为问题的目标函数，(1.2)中的几个不等式是问题的约束条件，记为s.t.</h6><p><span class="math display">\[min\quad c^Tx\\s.t.\quad\left \{ \begin{array}{lr**}  Ax\leq b\\Aeq*x=beq\\lb\leq x\lequb  \end{array} \right.\]</span></p><h5id="其中c和x为n维列向量aaeq为适当维数的矩阵bbeq为适当维数的列向量其中x返回的是决策向量的取值fval返回的是目标函数的最优值c为价值向量ab对应的是线性不等式约束aeqbeq对应的是线性等式约束lb和ub分别对应的是决策向量的下界向量和上界向量">其中c和x为n维列向量，A，Aeq为适当维数的矩阵，b，beq为适当维数的列向量；其中x返回的是决策向量的取值，fval返回的是目标函数的最优值，c为价值向量，A，b对应的是线性不等式约束，Aeq，beq对应的是线性等式约束，lb和ub分别对应的是决策向量的下界向量和上界向量</h5><h5id="matlab中求解线性规划的命令为只能求minmax加负号">matlab中求解线性规划的命令为(只能求min，max加负号)：</h5><ul><li><h5 id="xfvallinprogcab">[x,fval]=linprog(c,A,b)</h5></li><li><h5id="xfvallinprogcabaeqbeq">[x,fval]=linprog(c,A,b,Aeq,beq)</h5></li><li><h5id="xfvallinprogcabaeqbeqlbub">[x,fval]=linprog(c,A,b,Aeq,beq,lb,ub)</h5></li></ul><p><span class="math display">\[max\quad z=2x_1+3x_2-5x_3\\s.t.\quad\left \{ \begin{array}{lr**}   x_1+x_2+x_3=7\\2x_1-5x_2+x_3\geq10\\x_1+3x_2+x_3\leq 12\\x_1,x_2,x_3\geq 0 \end{array} \right.\]</span></p><h5 id="求解的matlab程序如下">求解的Matlab程序如下：</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c=[<span class="number">-2</span>;<span class="number">-3</span>;<span class="number">5</span>];</span><br><span class="line">a=[<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>;<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>];b=[<span class="number">-10</span>;<span class="number">12</span>];</span><br><span class="line">aeq=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">beq=<span class="number">7</span>;</span><br><span class="line">[x,y]=linprog(c,a,b,Aeq,beq,<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>)); <span class="comment">%因为c为n维列向量，这里的zeros(3,1)指的是一个行为3列为1的一个列向量，而lb=zeros(3,1)指的是x1，x2，x3都大于等于0</span></span><br><span class="line">x,y=-y;</span><br></pre></td></tr></table></figure><h3 id="投资组合方案的配置问题">投资组合方案的配置问题</h3><h6id="例题1.2-市场上有n种资产s_ii12ln可以选择现用数额为m的相当大的资金做一个时期的投资这n种资产在这一时期内购买s_i的平均收益率为r_i风险损失率为q_i投资越分散总的风险越少总体风险可用投资的s_i中最大的一个风险来度量-购买s_i时要付交易费费率为p_i当购买额不超过给定值u_i时交易费按购买u_i计算另外假定同期银行存款利率是r_0既无交易费又无风险r_05-已知n4时相关数据如下表1.1">例题1.2市场上有n种资产s_i(i=1,2,L,n)可以选择现用数额为M的相当大的资金做一个时期的投资。这n种资产在这一时期内购买s_i的平均收益率为r_i，风险损失率为q_i，投资越分散，总的风险越少，总体风险可用投资的s_i中最大的一个风险来度量。购买s_i时要付交易费，费率为p_i，当购买额不超过给定值u_i时，交易费按购买u_i计算。另外，假定同期银行存款利率是r_0，既无交易费又无风险(r_0=5%)。已知n=4时相关数据如下表1.1</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401161021488.png" /></p><h6id="试给该公司设计一种投资组合方案即用给定资金m有选择地购买若干种资产或存银行生息使净收益尽可能大使总体风险尽可能小">试给该公司设计一种投资组合方案，即用给定资金M，有选择地购买若干种资产或存银行生息，使净收益尽可能大，使总体风险尽可能小。</h6><h5 id="符号规定">符号规定：</h5><p>&lt;1&gt;<spanclass="math inline">\(s_i\)</span>表示第i种投资项目,如股票,债券等,i=0,1,L,n,其中<spanclass="math inline">\(s_0\)</span>指存入银行 &lt;2&gt;<spanclass="math inline">\(r_i,p_i,q_i\)</span>,分别表示s_i的平均收益率，交易费率，风险损失率,i=0,L,n,其中<spanclass="math inline">\(p_0=0,q_0=0\)</span> &lt;3&gt;<spanclass="math inline">\(u_i\)</span>表示<spanclass="math inline">\(s_i\)</span>的交易定额i=1,L,n &lt;4&gt;<spanclass="math inline">\(x_i\)</span>表示投资项目<spanclass="math inline">\(s_i\)</span>的资金,i=0,1,L,n&lt;5&gt;a表示投资风险度 &lt;6&gt;Q表示总体收益</p><h5 id="基本假设">基本假设：</h5><p>&lt;1&gt;投资数额M相当大，为了便于计算，假设M=1&lt;2&gt;投资越分散,总的风险越小 &lt;3&gt;总体风险用投资项目<spanclass="math inline">\(s_i\)</span>中最大的一个风险来度量&lt;4&gt;n+1种资产s_i之间是相互独立的 &lt;5&gt;在投资的这一时期内,<spanclass="math inline">\(r_i,p_i,q_i\)</span>为定值,,不受意外因素的影响&lt;6&gt;净收益和总体风险只受<spanclass="math inline">\(r_i,p_i,q_i\)</span>影响,不受其它因素干扰</p><h5 id="模型建立">模型建立：</h5><p>总体风险用所投资的s_i中最大的一个风险来衡量，即 <spanclass="math inline">\(max\left \{ \begin{array}{lr**}  q_ix_i|i=1,2,L,n\end{array} \}\right.\\\)</span>购买s_i(i=1,L,n)所付交易费是一个分段函数，即 交易费=<spanclass="math inline">\(max\left \{ \begin{array}{lr**}p_ix_i,\quad x_i\geq u_i,\\p_iu_i,\quad x_i\leq u_i.\\\end{array} \right.\\\)</span></p><p>而题目所给定的定值u_i(单位:元)相对总投资M很少,p_iu_i更小,这样购买s_i的净收益可以简化为<spanclass="math inline">\((r_i-p_i)x_i\)</span>要使净收益尽可能大,总体风险尽可能小，这是一个多目标规划模型</p><h5 id="目标函数和约束条件">目标函数和约束条件：</h5><p><span class="math display">\[\left \{ \begin{array}{lr**}\sum_{i=0}^{n}{(r_i-p_i)x_i}\\min(max_{1\leq i\leq n}{(q_ix_i)})\end{array} \right.\]</span></p><p><span class="math display">\[\left \{ \begin{array}{lr**}\sum_{i=0}^{n}{(1+p_i)x_i}=M\\x_i\geq 0,\quad i=0,1,...,n\end{array} \right.\]</span></p><h3 id="多目标规划改成线性规划">多目标规划改成线性规划</h3><p><code>模型1</code>在实际投资中，投资者承受风险的程度不一样，若给定风险一个界限a，使最大的一个风险<spanclass="math inline">\(\frac{q_ix_i}{M}\leqa\)</span>,可找到相应的投资方案。这样把多目标规划变成一个目标的线性规划</p><p>固定风险水平，优化收益</p><p><span class="math inline">\(max\sum_{i=0}^{n}{(r_i-p_i)x_i}\)</span><span class="math display">\[s.t.\left \{ \begin{array}{lr**}\frac{q_ix_i}{M}\leq a\\\sum_{i=0}^{n}{(1+p_i)x_i}=M,\quad x_i\geq 0\quad i=0,1,...,n\end{array} \right.\]</span> <code>模型2</code> 固定盈利水平，极小化风险</p><p><span class="math inline">\(min{(max{(q_ix_i)})}\)</span> <spanclass="math display">\[s.t.\left \{ \begin{array}{lr**}\sum_{i=0}^{n}{(r_i-p_i)x_i}\geq k\\\sum_{i=0}^{n}{(1+p_i)x_i}=M,\quad x_i\geq 0,i=0,1,2,...,n\end{array} \right.\]</span><code>模型3</code>投资者在权衡资产风险和预期收益两方面时，希望选择一个令自己满意的投资组合。因此对风险，收益分别赋予权重<spanclass="math inline">\(s(0\leq s\leq 1)\)</span>和<spanclass="math inline">\((1-s)\)</span>,s称为投资偏好系数 <spanclass="math display">\[min \quad shemax{q_ix_i}-{(1-s)}\sum_{i=0}^{n}{(r_i-p_i)x_i}\\s.t.\sum_{i=0}^{n}{(1+p_i)x_i}=M,\quad x_i\geq 0,i=0,1,2,...,n\]</span></p><h5 id="模型1求解"><code>模型1求解</code>:</h5><p><span class="math display">\[minf=(-0.05,-0.27,-0.19,-0.185,-0.185)(x_0,x_1,x_2,x_3,x_4)^T\\s.t.\left \{ \begin{array}{lr**}x_0+1.01x_1+1.02x_2+1.045x_3+1.065x_4=1\\0.025x_1\leq a\\0.015x_2\leq a\\0.055x_3\leq a\\0.026x_4\leq a\\x_i\geq 0,\quad i=0,1,...,4\end{array} \right.\]</span></p><h6id="由于a是任意给定的风险度到底怎样没有一个准则不同的投资者有不同的风险度我们从a0开始以步长delta-a0.001进行循环搜索编制程序如下">由于a是任意给定的风险度，到底怎样没有一个准则，不同的投资者有不同的风险度。我们从a=0开始，以步长<spanclass="math inline">\(\Deltaa=0.001\)</span>进行循环搜索，编制程序如下：</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%clc,clear</span></span><br><span class="line">a=<span class="number">0</span>;<span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">while</span> a&lt;<span class="number">0.05</span></span><br><span class="line">  c=[<span class="number">-0.05</span>,<span class="number">-0.27</span>,<span class="number">-0.19</span>,<span class="number">-0.185</span>,<span class="number">-0.185</span>];</span><br><span class="line">  A=[<span class="built_in">zeros</span>(<span class="number">4</span>,<span class="number">1</span>),<span class="built_in">diag</span>([<span class="number">0.025</span>,<span class="number">0.015</span>,<span class="number">0.055</span>,<span class="number">0.026</span>])];</span><br><span class="line">  b=a*<span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">  Aeq=[<span class="number">1</span>,<span class="number">1.01</span>,<span class="number">1.02</span>,<span class="number">1.045</span>,<span class="number">1.065</span>];</span><br><span class="line">  beq=<span class="number">1</span>;LB=<span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">  [x,Q]=linprog(c,A,b,Aeq,beq,LB);</span><br><span class="line">  Q=-Q;<span class="built_in">plot</span>(a,Q,<span class="string">&#x27;*k&#x27;</span>);</span><br><span class="line">  a=a+<span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">xlable(<span class="string">&#x27;a&#x27;</span>),ylable(<span class="string">&#x27;Q&#x27;</span>)</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401191138539.png"alt="屏幕截图_20240116_173128" /><figcaption aria-hidden="true">屏幕截图_20240116_173128</figcaption></figure><h5 id="可以看出">可以看出：</h5><ul><li><p>风险越大，收益越大</p></li><li><p>当投资越分散时，投资者承担的风险就越小，这与题目一致。冒险的投资者会出现集中投资的情况，保守的投资者则尽量分散投资</p></li><li><p>在a=0.006附近有一个转折点，在这一点左边，风险增加很少时，利润增长越快。在这一点右边，风险增加很大时，利润增长缓慢所以对于风险和收益没有特殊偏好的投资者来说，应该选择曲线的转折点作为最优投资组合，大约是a=0.6%，Q=20%，所对应投资方案为：<code>风险度a=0.006，收益Q=0.2019，x_0=0,x_1=0.24,x_2=0.4,x_3=0.1091,x_4=0.22212</code></p></li></ul><h2id="整数规划数学规划中的变量部分或全部限制为整数">整数规划（数学规划中的变量（部分或全部）限制为整数）</h2><ul><li><h6id="变量全限制为整数时称为纯完全整数规划多">变量全限制为整数时，称为纯（完全）整数规划【多】</h6><ul><li>原线性规划有最优解，当自变量限制为整数后，其整数规划会出现以下情况<ul><li>原线性规划最优解全是整数，则整数规划最优解与线性规划最优解一致</li><li>当原线性规划的最优解不是整数，那当然不是限制过后整数规划的最优解（无可行解或最优解值变差）</li></ul></li><li>整数规划的最优解不能按照实数最优解简单取整得到(有可能不满足约束条件)</li><li>纯整数规划：引进的松弛变量和剩余变量可以不要求取整数。<code>松弛变量</code>：解决把不等式约束变成等式约束的方法，例如，x_1+x_2&lt;=10，引进松弛变量x_3(x_3&gt;=0),此时原式子可以变成x_1+x_2+x_3=10(加上一个大于0的数等于10，说明没加之前小于等于10)；<code>剩余变量</code>:例如，x_1+x_2&gt;=10,引进剩余变量x_3(x_3&gt;=0)此时原式子可以变成x_1+x_2-x_3=10</li></ul></li><li><h6id="变量部分限制为整数的称为混合整数规划">变量部分限制为整数的，称为混合整数规划</h6></li><li><h6id="整数规划工作安排接力运动员非配">0--1整数规划(工作安排，接力运动员非配)</h6></li></ul><h3 id="合理下料问题">合理下料问题</h3><h6id="例题1.1设用某型号的圆钢下零件a_1a_2a_3....a_m的毛坯在一根圆钢上下料的方式有b_1b_2....b_n种每种下料方式可以得到各种零件的毛坯数以及每种零件的需要量如下表所示问怎样安排下料方式使得既满足需要所用的原材料又最少">例题1.1设用某型号的圆钢下零件A_1,A_2,A_3,....,A_m的毛坯。在一根圆钢上下料的方式有B_1,B_2,....,B_n种，每种下料方式可以得到各种零件的毛坯数以及每种零件的需要量，如下表所示。问怎样安排下料方式，使得既满足需要，所用的原材料又最少？</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401191138308.png" /></p><h6id="即用b_1种下料方式每根圆钢会产生a_1种零件a_11个a_1型号零件至少需要b_1个a_m型号零件至少需要b_m个">即：用B_1种下料方式每根圆钢会产生A_1种零件a_11个。A_1型号零件至少需要b_1个，A_m型号零件至少需要b_m个。</h6><h5 id="解设模型如下"><code>解设，模型如下：</code></h5><p><span class="math inline">\(x_j\)</span>表示用<spanclass="math inline">\(B_j\)</span>(j=1，2，...,n)种方式下料根数 <spanclass="math display">\[minZ=\sum_{j=1}^{n}{x_j}\\s.t.\left \{ \begin{array}{lr**}\sum_{j=1}^{n}{a_{ij}x_j}\geq b_i\quad (i=1,2,...,m)\\x_j\geq 0\quad (j=1,2,...,n)且为整数\end{array} \right.\]</span></p><h3 id="建厂问题">建厂问题</h3><h6id="例题1.2某公司计划在m个地点建厂可供选择的地点有a_1a_2...a_m他们的生产能力分别是a_1a_2...a_m假设生产同一件产品第i个工厂的建设费用为f_ii12...m又有n个地点b_1b_2...b_n需要销售这种产品其销量分别为b_1b_2...b_n从工厂运往销售地的单位运费为c_ij试决定应在哪些地方建厂即满足各地需要又使总建设费用和总运输费用最省">例题1.2某公司计划在m个地点建厂，可供选择的地点有A_1,A_2,...,A_m,他们的生产能力分别是a_1,a_2,...,a_m(假设生产同一件产品)。第i个工厂的建设费用为f_i(i=1,2,...,m),又有n个地点B_1,B_2,...B_n需要销售这种产品，其销量分别为b_1,b_2,...,b_n。从工厂运往销售地的单位运费为C_ij。试决定应在哪些地方建厂，即满足各地需要，又使总建设费用和总运输费用最省？</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401191138459.png" /></p><h5 id="解设以及模型"><code>解设以及模型：</code></h5><p><spanclass="math inline">\(x_{ij}\)</span>表示从工厂运往销地的运量(i=1,2,...,m、j=1,2,...,n),又设</p><p><span class="math inline">\(Y_i=\left \{ \begin{array}{lr**}  1\quad在A_i建厂\\ 0\quad 不在A_i建厂 (i=1,2,...,m)\end{array} \right.\)</span><span class="math display">\[minZ=\sum\sum{c_{ij}x_{ij}}+\sum_{i=1}^{m}{f_iy_i}\\运输的费用+建设的费用\\s.t.\left \{ \begin{array}{lr**}\sum_{i=1}^{m}{x_{ij}}\leq a_{ij}y_i\quad (i=1,2,...,m)\quad从该工厂运出去的量一定小于该工厂的产量\\\sum_{i=1}^{m}{x_{ij}\geq b_j}\quad (j=1,2,...,n)\quad从工厂运到销售地的量要大于等于该地的销售量\\x_{ij}\geq0,y_i=0或1\quad (i=1,2,...,m、j=1,2,...,n)\end{array} \right.\]</span></p><h3id="整数规划的一般数学模型一般解决运输问题或者指派问题">整数规划的一般数学模型(一般解决运输问题或者指派问题)</h3><p><span class="math display">\[max(min)z=\sum_{j=1}^{n}{c_jx_j}\\s.t.\left \{ \begin{array}{lr**}\sum_{j=1}^{n}{a_{ij}x_j}\leq(\geq,=)b_i\quad (i=1,2,...,m)\\x_j\geq，x_j为整数\quad (j=1,2,...,n)\end{array} \right.\]</span></p><h2id="分支定界算法求解整数规划"><code>分支定界算法</code>求解整数规划</h2><h6 id="例题1.1设整数规划问题如下">例题1.1：设整数规划问题如下</h6><p><span class="math display">\[max\quad z=x_1+x_2\\s.t.\left \{ \begin{array}{lr**}14x_1+9x_2\leq51\\-6x_1+3x_2\leq1\\x_1,x_2\geq0\quad 且为整数\end{array} \right.\]</span></p><h5 id="画图求解枚举法"><code>画图求解:(枚举法)</code></h5><p>最优解是当x_1=3/2,x_2=10/3时Z=29/6</p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401191138272.png" /></p><h5 id="分支定界算法求解方法">分支定界算法求解方法：</h5><p>不考虑整数限制先求出相应松弛问题的最优解，</p><p>若松弛问题无可行解，则ILP无可行解</p><p>若求得的松弛问题最优解符合整数要求，则是ILP的最优解；</p><p>若不满足整数条件，则任选一个不满足整数条件的变量<spanclass="math inline">\(x_i^0\)</span>来构造新的约束，添加到松弛问题中形成两个子问题</p><h5 id="x_ileqx_i0向下取整例如x_12.3则向下取整为2"><spanclass="math inline">\(x_i\leq[x_i^0]\)</span>,向下取整，例如<spanclass="math inline">\(x_1=2.3\)</span>,则向下取整为2</h5><h5 id="x_igeqx_i01向上取整例如x_23.3向上取整为4"><spanclass="math inline">\(x_i\geq[x_i^0]+1\)</span>,向上取整，例如<spanclass="math inline">\(x_2=3.3\)</span>,向上取整为4</h5><p>依次在缩小的可行域中求解新构造的线性规划的最优解，并重复上述过程，直到子问题无解或有整数最优解</p><h6 id="例题1.2">例题1.2：</h6><p><span class="math display">\[max\quad z=3x_1+2x_2\\s.t.\left \{ \begin{array}{lr**}2x_1+3x_2\leq4\\2x_1+x_2\leq24\\x_1,x_2\geq0\end{array} \right.\]</span></p><p>用matlab解得： <span class="math display">\[s.t.\left \{ \begin{array}{lr**}x_1=3.25\\x_2=2.5\\z=14.75\end{array} \right.\]</span></p><h5 id="先将x_1向下取整"><code>先将x_1向下取整</code></h5><p><span class="math display">\[max\quad z=3x_1+2x_2\\s.t.\left \{ \begin{array}{lr**}2x_1+3x_2\leq4\\2x_1+x_2\leq24\\x_1\leq3\\x_1,x_2\geq0\end{array} \right.\\得到：\left \{ \begin{array}{lr**}x_1=3\\x_2=2.67\\z=14.43\end{array} \right.\]</span></p><h5id="不难发现虽然x_1为整数但是x_22.67说明x_1向下取整无法得到最优解">不难发现，虽然x_1为整数，但是x_2=2.67,说明x_1向下取整无法得到最优解</h5><h5 id="再把x_1向上取整"><code>再把x_1向上取整</code></h5><p><span class="math display">\[max\quad z=3x_1+2x_2\\s.t.\left \{ \begin{array}{lr**}2x_1+3x_2\leq4\\2x_1+x_2\leq24\\x_1\geq4\\x_1,x_2\geq0\end{array} \right.\\得到：\left \{ \begin{array}{lr**}x_1=4\\x_2=1\\z=14\end{array} \right.\]</span></p><p><code>注意：整数规划只需要决策变量为整数，也就是x_1,x_2为整数就行，不要求结果z也为整数；并且当发现x_1向上取整可以后，还需要测验x_2向上和向下取整，以确保z的最大值</code><span class="math display">\[max\quad z=3x_1+2x_2\\s.t.\left \{ \begin{array}{lr**}2x_1+3x_2\leq4\\2x_1+x_2\leq24\\x_1\leq3,x_2\leq2\\x_1,x_2\geq0\end{array} \right.\\得到：\left \{ \begin{array}{lr**}x_1=3\\x_2=2\\z=13\end{array} \right.\]</span></p><h5id="发现z此时不是最大值继续把x_2向上取整">发现z此时不是最大值，继续把x_2向上取整</h5><p><span class="math display">\[max\quad z=3x_1+2x_2\\s.t.\left \{ \begin{array}{lr**}2x_1+3x_2\leq4\\2x_1+x_2\leq24\\x_1\leq3,x_2\geq3\\x_1,x_2\geq0\end{array} \right.\\得到：\left \{ \begin{array}{lr**}x_1=2.2\\x_2=3\\z=13.5\end{array} \right.\]</span></p><h5id="通过比较以上发现x_14x_21z14为最优解">通过比较以上发现，x_1=4,x_2=1,z=14为最优解</h5><h2 id="割平面算法求解整数规划"><code>割平面算法</code>求解整数规划</h2><p>不考虑整数限制先求出相应松弛问题的最优解，</p><p>若松弛问题无可行解，则ILP无可行解</p><p>若求得的松弛问题最优解符合整数要求，则是ILP的最优解；</p><p>如果松弛问题的解含有非整数分量，则对松弛问题增加割平面条件：即对松弛问题增加一个线性约束，将松弛问题的可行区域割掉一块，使得非整数解恰好在割掉的一块中，但又没有割掉原问题的可行解，重复上述过程</p><h6 id="例题1.1">例题1.1</h6><p><span class="math display">\[max\quad z=x_1+x_2\\s.t.\left \{ \begin{array}{lr**}-x_1+x_2\leq 1\\3x_1+x_2\leq 4\\x_1,x_2\geq 0\\x_1,x_2均为整数\end{array} \right.\]</span></p><h4id="如何确定应该切掉那一部分引入松弛变量或剩余变量将不等式变量转化为等式变量方法如下"><code>如何确定应该切掉那一部分？引入松弛变量或剩余变量将不等式变量转化为等式变量,方法如下:</code></h4><p><span class="math display">\[max\quad z=x_1+x_2+0x_3+0x_4\quad (1)\\s.t.\left \{ \begin{array}{lr**}-x_1+x_2+x_3=1\quad (2)\\3x_1+x_2+x_4=4\quad (3)\\x_1,x_2,x_3,x_4\geq 0\\x_1,x_2,x_3,x_4均为整数\end{array} \right.\]</span></p><h5id="将3式子减去2式子得到下面4式子让3式子加上32式子得到下面5式子">将3式子减去2式子得到下面4式子，让3式子加上3×2式子得到下面5式子：</h5><p><span class="math display">\[x_1-\frac{1}{4}x_3+\frac{1}{4}x_4=\frac{3}{4}\quad (4)\\x_2+\frac{3}{4}x_3+\frac{1}{4}x_4=\frac{7}{4}\quad (5)\]</span></p><h5id="把每个式子变量的系数和常量变成一个整数加上一个分数要求分数必须大于0整数无要求"><code>把每个式子变量的系数和常量变成一个整数加上一个分数，要求分数必须大于0，整数无要求:</code></h5><p><span class="math display">\[(1+0)x_1+(-1+\frac{3}{4})x_3+(0+\frac{1}{4})x_4=0+\frac{3}{4}\\(1+0)x_2+(0+\frac{3}{4})x_3+(0+\frac{1}{4})x_4=\frac{7}{4}\]</span></p><h5 id="整数放左边分数放右边"><code>整数放左边，分数放右边：</code></h5><p><span class="math display">\[x_1-x_3=\frac{3}{4}-(\frac{3}{4}x_3+\frac{1}{4}x_4)\\x_2=\frac{7}{4}-(\frac{3}{4}x_3+\frac{1}{4}x_4)\quad(6)\]</span></p><h5id="注意因为x_1-x_3为整数frac34x_3frac14x_4不可能为0大于等于1所以frac34-frac34x_3frac14x_4一定小于0"><code>注意</code>:因为x_1-x_3为整数，<spanclass="math inline">\((\frac{3}{4}x_3+\frac{1}{4}x_4)\)</span>（不可能为0）大于等于1，所以<spanclass="math inline">\(\frac{3}{4}-(\frac{3}{4}x_3+\frac{1}{4}x_4)\)</span>一定小于0：</h5><p><span class="math display">\[\frac{3}{4}-(\frac{3}{4}x_3+\frac{1}{4}x_4)\leq0\\则:3x_3+x_4\geq3\]</span></p><h5id="得到3x_3x_4geq3后6式可以变为x_2frac74-geq3则4x_2leq4x_2leq1">得到<spanclass="math inline">\(3x_3+x_4\geq3\)</span>后，6式可以变为<spanclass="math inline">\(x_2=\frac{7}{4}-(\geq3)\)</span>则：<spanclass="math inline">\(4x_2\leq4,x_2\leq1\)</span></h5><h4 id="最终得到x_2leq1"><code>最终得到：</code><spanclass="math inline">\(x_2\leq1\)</span></h4><p><span class="math display">\[x_i+\sum{a_{ik}x_k}=b_i\\a_ik=[a_{ik}]+(a_{ik}-La_{ik})+f_{ik}\quad f为小数部分，La为求整数以后\\b_i=[b_i]+(b_i-Lb_i)=[b_i]+f_i\\x_i+\sum[a{ik}]x_k+\sum{f_kx_k}=[b_i]+f_i\\x_i+\sum{[a_{ik}]}x_k-[b_i]=-\sum{[f_{ik}]x_k}+f_i\quad将整数与整数，小数与小数放在一起\]</span></p><h6id="例题1.2已知am工厂是一个拥有四个车间的玩具生产商该厂商今年新设计出abcdef六种玩具模型根据以前的生产情况及市场调查预测得知生产每单位产品所需要的工时每个车间在一季度的工时上限以及产品的预测价格如下表所示问每种设计产品在这个季度各应生产多少才能使am工厂这个季度的生产总值达到最大">例题1.2已知AM工厂是一个拥有四个车间的玩具生产商，该厂商今年新设计出A,B,C,D,E,F六种玩具模型，根据以前的生产情况及市场调查预测，得知生产每单位产品所需要的工时，每个车间在一季度的工时上限以及产品的预测价格，如下表所示。问：每种设计产品在这个季度各应生产多少，才能使AM工厂这个季度的生产总值达到最大？</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401191355464.png" /><span class="math display">\[max\quad Z=20x_1+14x_2+16x_3+36x_4+32x_5+30x_6\\s.t.\left \{ \begin{array}{lr**}0.01x_1+0.01x_2+0.01x_3+0.03x_4+0.03x_5+0.03x_6\leq 850\\0.02x_1+0.05x_4\leq 700\\0.02x_2+0.05x_5\leq 100\\0.03x_3+0.08x_6\leq 900\\x_i\geq0,且为整数,i=1,2,3,4,5,6\end{array} \right.\]</span></p><h5id="设置每个玩具生产的数量为决策变量x_1...x_6用切割平面得">设置每个玩具生产的数量为决策变量x_1,...,x_6,用切割平面得：</h5><p>$$ min-20x_1-14x_2-16x_3-36x_4-32x_5-30x_6+0x_7+0x_8+0x_9+0x_10\</p>s.t.{<span class="math display">\[\begin{array}{lr**}0.01x_1+0.01x_2+0.01x_3+0.03x_4+0.03x_5+0.03x_6+x_7=850\\0.02x_1+0.05x_4+x_8=700\\0.02x_2+0.05x_5+x_9=100\\0.03x_3+0.08x_6+x_10=900\\x_i\geq0,且为整数,i=1,2,3,4,5,6,...,10\end{array}\]</span><p>. $$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%DividePlane.m</span></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">[int x,intf]</span>=<span class="title">DividePlane</span><span class="params">(A,c,b,baseVector)</span></span></span><br><span class="line"><span class="comment">%功能：用割平面法求解整数规划</span></span><br><span class="line"><span class="comment">%调用格式：[intx,intf]=DividePlane(A,c,b,baseVector)</span></span><br><span class="line"><span class="comment">%其中，A：约束矩阵;</span></span><br><span class="line"><span class="comment">%     c:目标函数系数向量;</span></span><br><span class="line"><span class="comment">%     b:约束右端向量;</span></span><br><span class="line"><span class="comment">%     baseVector:初始基向量;</span></span><br><span class="line"><span class="comment">%     intx:目标函数取最小值时的自变量值</span></span><br><span class="line"><span class="comment">%     intf:目标函数的最小值</span></span><br><span class="line">sz=<span class="built_in">size</span>(A);</span><br><span class="line">nVia:sz(<span class="number">2</span>);<span class="comment">%获取有多少决策变量</span></span><br><span class="line">n=sz(<span class="number">1</span>);<span class="comment">%获取有多少约束条件</span></span><br><span class="line">xx=<span class="number">1</span>:nVia;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(baseVector)~=n</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;基变量的个数要与约束矩阵的行数相等&#x27;</span>);</span><br><span class="line">    mx=NaN;</span><br><span class="line">    mf=NaN;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">M=<span class="number">0</span>;</span><br><span class="line">sigma=-[transpose(c)<span class="built_in">zeros</span>(<span class="number">1</span>,(nVia-<span class="built_in">length</span>(c)))];</span><br><span class="line">xb=b;</span><br></pre></td></tr></table></figure><h5 id="解得intx35000-5000-30000-0-0-0intf-1250000">解得：intx=350005000 30000 0 0 0；intf=-1250000</h5><h2 id="匈牙利算法0-1规划问题">匈牙利算法（0-1规划问题）</h2><h3 id="投资问题">投资问题：</h3><h6id="例题1.1有600万元投资5个项目收益如表求最大利润方案">例题1.1有600万元投资5个项目，收益如表，求最大利润方案</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201323626.png" /></p><h5id="x_j为决策变量j12...5表示投资哪个项目">x_j为决策变量(j=1,2,...,5),表示投资哪个项目</h5><p><span class="math display">\[x_j=\left \{ \begin{array}{lr**}1\quad 选中第j个项目投资\\0\quad 不选中第j个项目投资\end{array} \right.\]</span></p><p><span class="math display">\[max \quad Z=160x_1+210x_2+60x_3+80x_4+180x_5\\\left \{ \begin{array}{lr**}210x_1+300x_2+150x_3+130x_4+260x_5\leq600\\x_1+x_2+x_3=1\\x_3+x_4=1\\x_5\leq x_1\\x_1,x_2,x_3,x_4,x_5=0或1\end{array} \right.\]</span></p><h6id="例题1.2某种工序的约束条件为4x_15x_2leq200另一种工序的约束条件是3x_15x_2leq180">例题1.2某种工序的约束条件为：<spanclass="math inline">\(4x_1+5x_2\leq200\)</span>另一种工序的约束条件是<spanclass="math inline">\(3x_1+5x_2\leq180\)</span></h6><p><span class="math display">\[y=\left \{ \begin{array}{lr**}1\quad 采用原工序\\0\quad 采用新工序\end{array} \right.\]</span></p><h5 id="m为的数">M为∞的数</h5><p><span class="math display">\[4x_1+5x_2\leq200+(1-y)M\\3x_1+5x_2\leq180+yM\]</span></p><h3 id="互斥约束的推广">互斥约束的推广：</h3><h6id="从下述p个约束条件中恰好选择q个约束条件">从下述p个约束条件中恰好选择q个约束条件：</h6><h6 id="sum_j1na_ijx_jleq-b_ii12...p"><spanclass="math inline">\(\sum_{j=1}^{n}{a_{ij}x_j}\leqb_i(i=1,2,...,p)\)</span></h6><h5 id="新增一个决策变量y_i">新增一个决策变量y_i</h5><p><span class="math display">\[y_i=\left \{ \begin{array}{lr**}0\quad 选第i个约束条件\\1\quad 不选第i个约束条件\end{array} \right.\]</span></p><p><span class="math display">\[\left \{ \begin{array}{lr**}\sum_{j=1}^{n}a_{ij}x_j\leq b_i+My_i\\\sum_{i=1}^{p}y_i=p-q\end{array} \right.\]</span></p><h3 id="固定费用问题">固定费用问题</h3><h6id="例题1.3服装公司租用生产线拟生产t恤衬衫和裤子每年可用劳动力8200h布料8800m2">例题1.3服装公司租用生产线拟生产T恤，衬衫和裤子。每年可用劳动力8200h，布料8800m^2</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201353661.png" /></p><h5 id="假设"><code>假设：</code></h5><p><span class="math display">\[y_j=1,要租用生产线j\\y_j=0.不租用生产线j\\第j种服装生产量为x_j\\M为∞\]</span></p><p><span class="math display">\[max\quad Z=150x_1+220x_2+300x_3-200000y_1-150000y_2-100000y_3\\\left \{ \begin{array}{lr**}3x_1+2x_2+6x_3\leq 8200\\0.8x_1+1.1x_2+1.5x_3\leq 8800\\x_1,x_2,x_3\leq0,且取整数\\y_1,y_2,y_3=0或1\\x_1\leq M_1y_1\\x_2\leq M_2y_2\\x_3\leq M_3y_3\end{array} \right.\]</span></p><h6id="售价减去可变成本就是利润"><code>售价减去可变成本就是利润</code></h6><h3 id="指派问题">指派问题</h3><h6id="例题1.4甲乙丙丁四个人abcd思乡工作要求每人只能做一项工作每项任务只由一人完成问如何指派总时间最短">例题1.4甲乙丙丁四个人，ABCD思乡工作，要求每人只能做一项工作，每项任务只由一人完成，问如何指派总时间最短</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201406109.png" /></p><h5 id="假设引入0-1变量x_ij">假设：引入0-1变量x_ij</h5><p><span class="math display">\[x_{ij}=1:第i人做第j项工作\\x_{ij}=0:第i人不做第j项工作\\min\quadZ=3x_{11}+5x_{12}+8x_{13}+4x_{14}\\+6x_{21}+8x_{22}+5x_{23}+4x_{24}\\+2x_{31}+5x_{32}+8x_{33}+5x_{34}\\+9x_{41}+2x_{42}+5x_{43}+2x_{44}\\s.t.\left \{ \begin{array}{lr**}x_{11}+x_{21}+x_{31}+x_{41}=1\\x_{12}+x_{22}+x_{32}+x_{42}=1\\x_{13}+x_{23}+x_{33}+x_{43}=1\\x_{14}+x_{24}+x_{34}+x_{44}=1\end{array} \right.\]</span></p><ul><li><p>人数和工作不等</p><p>人少工作多：添加虚拟的”人“，代价都为0</p><p>人多工作少：添加虚拟的工作，代价都为0</p></li><li><p>一个人可以做多项工作：该人可以化为几个相同的“人”</p></li><li><p>该工作一定不能由某人做：该人做该工作的代价应取足够大M</p></li></ul><h2 id="匈牙利解法的一般步骤">匈牙利解法的一般步骤：</h2><h5id="第一变换指派问题的系数也称效率矩阵c_ij为b_ij使在b_ij的各行各列中都出现0元素即从c_ij的每行元素都减去该行的最小元素再从所得新系数矩阵的每列元素中减去该列的最小元素">第一：变换指派问题的系数(也称效率)矩阵(c_ij)为(b_ij),使在(b_ij)的各行各列中都出现0元素即，从(c_ij)的每行元素都减去该行的最小元素，再从所得新系数矩阵的每列元素中减去该列的最小元素</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201441882.png" /></p><h5id="第二圈0找不同行不同列的独立0元素其它的0划掉">第二：圈0，找不同行，不同列的独立0元素，其它的0划掉</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201443764.png" /></p><h5id="第三试指派独立0元素的个数不够的情况">第三:试指派(独立0元素的个数不够的情况)</h5><ul><li>对不含有独立0元素的行标对号，再对画对号的这一行，有被划掉的0的列标对号，再对画对号的这一列中有的独立0元素的行标对号</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201447669.png" /></p><ul><li>对未标记对号的行画直线，和已经被标对号的列画直线</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201448500.png" /></p><h5id="第四变换矩阵在没有被划掉的元素中找到最小值为1对于标记对号的行减去最小值列加上最小值0不用进行加减没画对号的行列不用管">第四：变换矩阵，在没有被划掉的元素中找到最小值为1，对于标记对号的行减去最小值，列加上最小值（0不用进行加减），没画对号的行列不用管</h5><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401201451590.png" /></p><h6 id="例题2.1求解以下指派问题">例题2.1求解以下指派问题</h6><p><span class="math display">\[\left[\matrix{3&amp;8&amp;2&amp;10&amp;3\\8&amp;7&amp;2&amp;9&amp;7\\6&amp;4&amp;2&amp;7&amp;5\\8&amp;4&amp;2&amp;3&amp;5\\9&amp;10&amp;6&amp;9&amp;10}\right]\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c=[<span class="number">3</span> <span class="number">8</span> <span class="number">2</span> <span class="number">10</span> <span class="number">3</span>;<span class="number">8</span> <span class="number">7</span> <span class="number">2</span> <span class="number">9</span> <span class="number">7</span>;<span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span>;<span class="number">8</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span>;<span class="number">6</span> <span class="number">10</span> <span class="number">6</span> <span class="number">9</span> <span class="number">10</span>];</span><br><span class="line">c=c(:);<span class="comment">%把矩阵c转化为向量</span></span><br><span class="line">a=<span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">25</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">5</span> <span class="comment">%实现循环运算</span></span><br><span class="line">  a(<span class="built_in">i</span>,(<span class="built_in">i</span><span class="number">-1</span>)*<span class="number">5</span>+<span class="number">1</span>:<span class="number">5</span>*<span class="built_in">i</span>)=<span class="number">1</span>;</span><br><span class="line">  a(<span class="number">5</span>+<span class="built_in">i</span>,<span class="built_in">i</span>:<span class="number">5</span>:<span class="number">25</span>)=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="comment">%此循环把指派问题转化为线性规划问题</span></span><br><span class="line">b=<span class="built_in">ones</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">[x,y]=linprog(c,[],[],a,b,<span class="built_in">zeros</span>(<span class="number">25</span>,<span class="number">1</span>),<span class="built_in">ones</span>(<span class="number">25</span>,<span class="number">1</span>));</span><br><span class="line">X=<span class="built_in">reshape</span>(x,<span class="number">5</span>,<span class="number">5</span>) <span class="comment">%重构成5×5的矩阵</span></span><br><span class="line">opt=y <span class="comment">%输出</span></span><br><span class="line"><span class="comment">%求得最优指派方式为x_15=x_23=x_32=x_44=x_51=1,最优值为21</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="非线性规划模型np">非线性规划模型(NP)</h2><h5id="包含二次项及以上的项数就是非线性规划目标函数或限制条件中有非线性">包含二次项及以上的项数就是非线性规划(目标函数或限制条件中有非线性)</h5><h3 id="投资决策问题">投资决策问题</h3><h6id="例题1.1某企业有n个项目可供选择投资并且至少要对其中的一个项目投资已知该企业拥有总资金a元投资于第ii12...n个项目需花资金a_i元并预计可收益b_i元试选择最佳投资方案">例题1.1某企业有n个项目可供选择投资，并且至少要对其中的一个项目投资。已知该企业拥有总资金A元，投资于第i，i=1，2，...，n个项目需花资金a_i元，并预计可收益b_i元，试选择最佳投资方案。</h6><h5 id="设投资变量为"><code>设投资变量为：</code></h5><p><span class="math display">\[x_i=\left \{ \begin{array}{lr**}1\quad决定会投资第i个项目\\0\quad决定不投资第i个项目\end{array} \right.\\则投资总额为\sum_{i=1}^{n}{a_ix_i},投资总收益为\sum_{i=1}^{n}{b_ix_i}\]</span></p><h5id="因为该公司至少要对一个项目投资并且总的投资金额不能超过总资金a故有限制条件">因为该公司至少要对一个项目投资，并且总的投资金额不能超过总资金A，故有限制条件</h5><p><span class="math display">\[0&lt;\sum_{i=1}^{n}{a_ix_i}\leq A\]</span></p><h5id="另外由于x_i只能取0或1所以还有">另外由于x_i只能取0或1所以还有</h5><p><span class="math display">\[x_i(1-x_i)=0,i=1,2,...,n\]</span></p><h5id="投资资金固定用比值法看最合适最佳投资方案应是投资额最小而收益最大10万赚10万3万赚10万的区别所以这个最佳投资决策问题归结为总资金以及决策变量取0或1的限制条件下极大化总收益和总投资之比因为不考虑风险问题所以把资金投资完的收益一定最大所以不考虑全投资到一个">投资资金固定，用比值法看最合适,最佳投资方案应是投资额最小而收益最大(10万赚10万；3万赚10万的区别)，所以这个最佳投资决策问题归结为总资金以及决策变量(取0或1)的限制条件下，极大化总收益和总投资之比。(因为不考虑风险问题，所以把资金投资完的收益一定最大，所以不考虑全投资到一个)</h5><p><span class="math display">\[max=\frac{\sum_{i=1}^{n}{b_ix_i}}{\sum_{i=1}^{n}{a_ix_i}}\\s.t.\left \{ \begin{array}{lr**}0&lt;\sum_{i=1}^{n}{a_ix_i}\leq A\\x_i(1-x_i)=0,i=1,2,...,n\end{array} \right.\]</span></p><h6id="matlab中非线性规划的数学模型">matlab中非线性规划的数学模型：</h6><p><span class="math display">\[min\quad f(x)\\s.t.\left \{ \begin{array}{lr**}A·x\leq b\\Aeq·x=beq\\c(x)\leq0\\ceq(x)=0\\lb\leq x\leq ub\end{array} \right.\]</span></p><h6id="其中fx是标量函数abaeqbeqlbub是相应维数的矩阵和向量cxceqx是非线性向量函数">其中f(x)是标量函数，A，b,Aeq,beq,lb,ub是相应维数的矩阵和向量，c(x),ceq(x)是非线性向量函数</h6><h6 id="例题1.2-1">例题1.2</h6><p><span class="math display">\[min\quad f(x)=x_1^2+x_2^2+x_3^2+8\\s.t.\left \{ \begin{array}{lr**}x_1^2-x_2+x_3^2\geq 0\\x_1+x_2^2+x_3^2\leq20\\-x_1-x_2^2+2=0\\x_2+2x_3^2=3x_1,x_2,x_3\geq0\end{array} \right.\]</span></p><ul><li><h5id="编写m函数fun1.m定义目标函数">编写M函数fun1.m定义目标函数</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">fun1</span><span class="params">(x)</span>;</span></span><br><span class="line">f=sum(x.^<span class="number">2</span>)+<span class="number">8</span>;   <span class="comment">%1.x·2是矩阵×2;2.x^2是实数的平方;3.x.^2是矩阵中每个数的平方</span></span><br></pre></td></tr></table></figure></li><li><h5id="编写m函数fun2.m定义非线性约束条件">编写M函数fun2.m定义非线性约束条件</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">[g,h]</span>=<span class="title">fun2</span><span class="params">[x]</span>;</span></span><br><span class="line">g=[-x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)-x(<span class="number">3</span>)^<span class="number">2</span></span><br><span class="line">x(<span class="number">1</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)^<span class="number">3</span><span class="number">-20</span>];<span class="comment">%非线性不等式约束</span></span><br><span class="line">h=[-x(<span class="number">1</span>)-x(<span class="number">2</span>)^<span class="number">2</span>+<span class="number">2</span></span><br><span class="line">x(<span class="number">2</span>)+<span class="number">2</span>x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-3</span>];<span class="comment">%非线性等式约束</span></span><br></pre></td></tr></table></figure></li><li><h5 id="编写主程序文件如下">编写主程序文件如下</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,y]=fmincon(<span class="string">&#x27;fun1&#x27;</span>,<span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">1</span>),[],[],[],[],<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>),[],<span class="string">&#x27;fun2&#x27;</span>)<span class="comment">%rand是生成随机值有几个变量就是rand(x,1);如果有线性规划也要写，没有都标成[];zeros是生成初值里面值和rand中一样</span></span><br></pre></td></tr></table></figure>得到x_1=0.5522,x_2=1.2033,x_3=0.9478时，最小值y=10.6511</li></ul><h3id="二次规划若某非线性规划的目标函数是自变量的二次函数约束条件又全是线性的就称这种规划为二次规划">二次规划(若某非线性规划的目标函数是自变量的二次函数，约束条件又全是线性的，就称这种规划为二次规划)</h3><p><span class="math display">\[min\frac{1}{2}x^THx+f^{T}{x}\\s.t.\left \{ \begin{array}{lr**}Ax\leq b\\Aeq·x=beq\\lb\leq x\leq ub\end{array} \right.\]</span></p><h5id="这里h是实对称矩阵对角线元素随便但其他的元素沿对角线对称fbbeqlbub是列向量aaeq是相应维数的矩阵">这里H是实对称矩阵(对角线元素随便，但其他的元素沿对角线对称)，f,b,beq,lb,ub是列向量，A，Aeq是相应维数的矩阵</h5><h6id="matlab中求解二次规划的命令是">matlab中求解二次规划的命令是：</h6><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x,fval]=quadprog(H,f,A,b,Aeq,beqlb,ub,x_0,options)<span class="comment">%返回值x是决策向量x的值，返回值fval是目标函数在x处的值</span></span><br></pre></td></tr></table></figure><h6 id="例题2.1">例题2.1</h6><p><span class="math display">\[min\quad f(x)=2x_1^2-4x_1x_2+4x_2^2-6x_1-3x_2\\s.t.\left \{ \begin{array}{lr**}x_1+x_2\leq3\\4x_1+x_2\leq9\\x_1,x_2\geq0\end{array} \right.\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h=[<span class="number">4</span>,<span class="number">-4</span>;<span class="number">-4</span>,<span class="number">8</span>];</span><br><span class="line">f=[<span class="number">-6</span>;<span class="number">-3</span>];</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">1</span>;<span class="number">4</span>,<span class="number">1</span>];</span><br><span class="line">b=[<span class="number">3</span>;<span class="number">9</span>];</span><br><span class="line">[x,value]=quadprog(h,f,a,b,[],[],<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>求得x_1=1.9500,x_2=1.0500,minf(x)=-11.0250</p><h3 id="供应与选址问题">供应与选址问题</h3><h6id="应用例题2.2-某公司有6个建筑工地要开工每个工地的位置用平面坐标系ab表示距离单位千米及水泥日用量d吨由下表给出目前有两个临时料场位于a51b27日储量各有20吨假设从料场到工地之间均有直线道路相连-1试制定每天的供应计划即从ab两料场分别向各工地运送多少吨水泥使总的吨千米数最小-2为了进一步减少吨千米数打算舍弃两个临时料场改建两个新的日储量各为20吨问应建在何处节省的吨千米数有多大">应用例题2.2某公司有6个建筑工地要开工，每个工地的位置（用平面坐标系a,b表示，距离单位：千米）及水泥日用量d(吨)由下表给出。目前有两个临时料场位于A(5，1)，B(2，7)，日储量各有20吨。假设从料场到工地之间均有直线道路相连（1）试制定每天的供应计划，即从A,B两料场分别向各工地运送多少吨水泥，使总的吨千米数最小（2）为了进一步减少吨千米数，打算舍弃两个临时料场，改建两个新的，日储量各为20吨，问应建在何处，节省的吨千米数有多大？</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401221405981.png" /></p><h5id="记工地的位置为a_ib_i水泥日用量为d_ii1...料场位置为x_jy_j日储量为e_jj12从料场j向工地i的运送量为x_ij"><code>记工地的位置为(a_i,b_i),水泥日用量为d_i,i=1,...,;料场位置为(x_j,y_j)，日储量为e_j，j=1,2;从料场j向工地i的运送量为X_ij</code></h5><p><span class="math display">\[目标函数：min\quadf=\sum_{j=1}^{2}\sum_{i=1}^{6}X_{ij}\sqrt{(x_j-a_i)^2+(y_j-b_i)^2}\\约束条件：\sum_{j=1}^{2}{X_{ij}=d_i},i=1,2,...,6\\\sum_{i=1}^{6}{X_ij}\leq e_j,j=1,2\]</span></p><h5id="约束条件1.每天从两个料场运送到每个工地的用料要等于该建筑工地的水泥日用量-2.每天从每个料场运送到各个建筑工地的用料要小于该料场的日存储量">约束条件：1.每天从两个料场运送到每个工地的用料要等于该建筑工地的水泥日用量2.每天从每个料场运送到各个建筑工地的用料要小于该料场的日存储量</h5><h5id="当用临时料场时决策变量为x_ij当不用临时料场时决策变量为x_ijx_jy_j">当用临时料场时决策变量为：X_ij;当不用临时料场时决策变量为：X_ij,x_j,y_j</h5><h6 id="使用临时料场的情形"><code>使用临时料场的情形：</code></h6><h6id="使用两个临时料场a51b27求从料场j向工地i的运送看为x_ij在各个工地用量必须满足和各料场运送量不超过日储量的条件下使总的吨千米数最小">使用两个临时料场A(5,1),B(2,7)求从料场j向工地i的运送看为X_ij，在各个工地用量必须满足和各料场运送量不超过日储量的条件下，使总的吨千米数最小</h6><p><span class="math display">\[X_{11}=X_1,X_{21}=X_2,X_{31}=X_{3},X_{41}=X_4,X_{51}=X_5,X_{61}=X_6\\X_{12}=X_7,X_{22}=X_{8}X_{32}=X_9,X_{42}=X_{10},X_{52}=X_{11},X_{62}=X_{12}\]</span></p><p><span class="math display">\[min\quad f=\sum_{j=1}^{2}\sum_{i=1}^{6}{aa(i,j)}X_{ij}\quad其中i=1,2,...,6;j=1,2\\aa(i,j)=\sqrt{(x_j-a_i)^2+(y_j-b_i)^2}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">a=[<span class="number">1.25</span> <span class="number">8.75</span> <span class="number">0.5</span> <span class="number">5.75</span> <span class="number">3</span> <span class="number">7.25</span>];</span><br><span class="line">b=[<span class="number">1.25</span> <span class="number">0.75</span> <span class="number">4.75</span> <span class="number">5</span> <span class="number">6.5</span> <span class="number">7</span> <span class="number">75</span>];</span><br><span class="line">d=[<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>];</span><br><span class="line">x=[<span class="number">5</span> <span class="number">2</span>];</span><br><span class="line">y=[<span class="number">1</span> <span class="number">7</span>];</span><br><span class="line">e=[<span class="number">20</span> <span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">6</span></span><br><span class="line">  forj=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    aa(<span class="built_in">i</span>,<span class="built_in">j</span>)=<span class="built_in">sqrt</span>((x(<span class="built_in">j</span>)-a(<span class="built_in">i</span>))^<span class="number">2</span>+(y(<span class="built_in">j</span>)-b(<span class="built_in">i</span>))^<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">CC=[aa(:,<span class="number">1</span>);aa(:,<span class="number">2</span>)]&#x27;;</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> ];</span><br><span class="line">B=[<span class="number">20</span>;<span class="number">20</span>];</span><br><span class="line">Aeq=[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">%从第1，2料场运到工地1的料</span></span><br><span class="line">     <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> ];</span><br><span class="line">beq=[d(<span class="number">1</span>);d(<span class="number">2</span>);d(<span class="number">3</span>);d(<span class="number">4</span>);d(<span class="number">5</span>);d(<span class="number">6</span>)];</span><br><span class="line">VLB=[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">VUB=[];</span><br><span class="line">x_0=[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line">[xx,fval]=linprog(CC,A,B,Aeq,beq,VLB,VUB,x_0)</span><br></pre></td></tr></table></figure><h6id="使用两个新建料场的情况此时为非线性规划目标函数中非线性约束条件还是线性的">使用两个新建料场的情况,此时为非线性规划(目标函数中非线性，约束条件还是线性的)</h6><p><span class="math display">\[X_{11}=X_1,X_{21}=X_2,X_{31}=X_{3},X_{41}=X_4,X_{51}=X_5,X_{61}=X_6\\X_{12}=X_7,X_{22}=X_{8}X_{32}=X_9,X_{42}=X_{10},X_{52}=X_{11},X_{62}=X_{12}\\x_1=X_{13},y_1=X_{14},x_2=X_{15},y_2=X_{16}\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>=<span class="title">liaoch</span><span class="params">(x)</span></span></span><br><span class="line">a=[<span class="number">1.25</span> <span class="number">8.75</span> <span class="number">0.5</span> <span class="number">5.75</span> <span class="number">3</span> <span class="number">7.25</span>];</span><br><span class="line">b=[<span class="number">1.25</span> <span class="number">0.75</span> <span class="number">4.75</span> <span class="number">5</span> <span class="number">6.5</span> <span class="number">7.75</span>];</span><br><span class="line">d=[<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>];</span><br><span class="line">e=[<span class="number">20</span> <span class="number">20</span>];</span><br><span class="line">f1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">6</span></span><br><span class="line">  s(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="number">13</span>)-a(<span class="built_in">i</span>))^<span class="number">2</span>+(x(<span class="number">14</span>)-b(<span class="built_in">i</span>)^<span class="number">2</span>);</span><br><span class="line">  f1=s(<span class="built_in">i</span>)*x(<span class="built_in">i</span>)+f1;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">7</span>:<span class="number">12</span></span><br><span class="line">  s(<span class="built_in">i</span>)=<span class="built_in">sqrt</span>((x(<span class="number">15</span>)-a(<span class="built_in">i</span><span class="number">-6</span>))^<span class="number">2</span>+(x(<span class="number">16</span>)-b(<span class="built_in">i</span><span class="number">-6</span>))^<span class="number">2</span>);</span><br><span class="line">  f2=s(<span class="built_in">i</span>)*x(<span class="built_in">i</span>)+f2;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f=f1+f2;</span><br><span class="line"><span class="comment">%主程序</span></span><br><span class="line">x_0=[<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span> <span class="number">11</span> <span class="number">5.6348</span> <span class="number">4.8687</span> <span class="number">7.2479</span> <span class="number">7.7499</span>]&#x27;;</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">   <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> ];</span><br><span class="line">B=[<span class="number">20</span>;<span class="number">20</span>];</span><br><span class="line">Aeq=[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">%从第1，2料场运到工地1的料</span></span><br><span class="line">     <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">     <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">beq=[<span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>]&#x27;;</span><br><span class="line">vlb=[<span class="built_in">zeros</span>(<span class="number">12</span>,<span class="number">1</span>);-<span class="built_in">inf</span>;-<span class="built_in">inf</span>;-<span class="built_in">inf</span>;-<span class="built_in">inf</span>];</span><br><span class="line">vun=[];</span><br><span class="line">[x,fval,exitflag]=fmincon(<span class="string">&#x27;liaoch&#x27;</span>,x_0,A,B,Aeq,beq,vlb,vub)</span><br></pre></td></tr></table></figure><h1 id="层次分析法求解">层次分析法求解</h1><ul><li>用于最佳方案的选取(选择运动员，选择地址)</li><li>用于评价类问题(评价水质情况，评价环境)</li><li>用于指标体系的优选(兼顾科学和效率)</li></ul><h5id="构造判断矩阵成对比较用19标度方法给出"><code>构造判断矩阵(成对比较):用1~9标度方法给出</code></h5><p><code>C1(景色)，C2(费用),C3(居住),C4(饮食),C5(旅途)是五个准则</code>，以下来比较各准则对目标的重要性</p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401231441307.png" /></p><h6id="但是不难发现上图存在成对比较不一致的情况c1c212c1c341所以按道理c2c381但是图示为71注意这里允许不一致但要确定不一致的允许范围称满足a_ija_jka_ikijk12...n的正互反阵a称为一致阵上图为不一致阵">但是不难发现，上图存在成对比较不一致的情况：C1:C2=1:2;C1:C3=4:1所以按道理C2:C3=8:1，但是图示为7：1。<code>注意：</code>这里允许不一致，但要确定不一致的允许范围。称满足a_ij·a_jk=a_ik,i,j,k=1,2,...,n的正互反阵A称为<code>一致阵</code>,上图为不一致阵</h6><h3 id="层次单排序及其一致性检验">1.层次单排序及其一致性检验</h3><h5id="一致性检验是为了判断在什么程度下的不一致是可允许的范围内">一致性检验是为了判断在什么程度下的不一致是可允许的范围内</h5><h5id="定理n阶一致阵的唯一非零特征根为n">定理：n阶一致阵的唯一非零特征根为n</h5><p>定理：n阶正互反阵A的最大特征根<span class="math inline">\(\lambda\geqn\)</span>,当且仅当<spanclass="math inline">\(\lambda=n\)</span>时A为一致阵</p><h6id="定义一致性指标cifraclambda-nn-1ci0有完全的一致性ci接近于0有满意的一致性ci越大不一致越严重为衡量ci的大小引入随机一致性指标ri方法为随机构造500个成对矩阵">定义一致性指标：CI=<spanclass="math inline">\(\frac{\lambda-n}{n-1}\)</span>,CI=0，有完全的一致性，CI接近于0，有满意的一致性，CI越大，不一致越严重。为衡量CI的大小，引入<code>随机一致性指标RI</code>。方法为随机构造500个成对矩阵</h6><p><spanclass="math inline">\(RI=\frac{CI_1+CI_2+...+CI_{500}}{500}\)</span></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401241434180.png" /></p><h5id="一般当一致性比率crfracciri0.1认为a的不一致程度在被允许的范围内">一般当一致性比率<spanclass="math inline">\(CR=\frac{CI}{RI}&lt;0.1\)</span>,认为A的不一致程度在被允许的范围内</h5><h6id="例题1.1选择旅游地中准则层对目标层的权向量及一致性检验">例题1.1“选择旅游地”中准则层对目标层的权向量及一致性检验</h6><p><span class="math display">\[\left[\matrix{1&amp;1/2&amp;4&amp;3&amp;3\\2&amp;1&amp;7&amp;5&amp;5\\1/4&amp;1/7&amp;1&amp;1/2&amp;1/3\\1/3&amp;1/5&amp;2&amp;1&amp;1\\1/3&amp;1/5&amp;3&amp;1&amp;1}\right]\]</span></p><h6id="最大特征根lambda5.073权向量w0.2630.4750.0550.0900.110t一致性性指标cifrac5.073-55-10.018随机一致性指标ri1.12查表一致性比率cr0.0181.120.0160.1通过一致性检验">最大特征根<spanclass="math inline">\(\lambda=5.073\)</span>,权向量<spanclass="math inline">\(w=(0.263,0.475,0.055,0.090,0.110)^T\)</span>,一致性性指标<spanclass="math inline">\(CI=\frac{5.073-5}{5-1}=0.018\)</span>随机一致性指标RI=1.12（查表）。一致性比率CR=0.018/1.12=0.016&lt;0.1,通过一致性检验</h6><h3id="正互反阵最大特征根和特征向量的简化计算">2.正互反阵最大特征根和特征向量的简化计算</h3><h4 id="和法----取列向量的算数平均">和法----取列向量的算数平均</h4><p><span class="math display">\[A=\left[\matrix{1&amp;2&amp;6\\1/2&amp;1&amp;4\\1/6&amp;1/4&amp;1}\right]\\列向量归一化,让每一列按比例缩小到列和等于1：1/(1+1/2+1/6)=0.6\\\left[\matrix{0.6&amp;0.615&amp;0.545\\0.3&amp;0.308&amp;0.364\\0.1&amp;0.077&amp;0.091}\right]\\求行和归一化：每行加起来除以每行元素数\\\left[\matrix{0.587\\0.324\\0.089}\right]=\omega\\\]</span></p><p><span class="math display">\[A\omega=\left[\matrix{1.769\\0.974\\0.268}\right]\\A\omega=0.587*1+0.3234*2+0.089*6\\A\omega=\lambda \omega\\\lambda=\frac{1}{3}(1.769/0.587+0.974/0.324+0.268/0.089)=3.009\]</span></p><h3 id="层次总排序及其一次性检验">3.层次总排序及其一次性检验</h3><ul><li>计算某一层次所有因素对于最高层(总目标)相对重要性的权值，称为层次总排序</li><li>这一过程是从最高层次到最低层次依次进行的</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401241622950.png" /></p><p>A层m个因素A_1,A_2,...,A_m对总目标Z的排序为：a_1,a_2,...，a_m;B层n个因素对上层A中因素为A_j的层次单排序为：b_1j,b_2j,...,b_nj(j=1,2,...,m);B层的层次总排序为：<code>B_1=a_1*b_11+a_2*b_12+...+a_m*b_1m</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401241623003.png" /></p><h6 id="则层次总排序的一致性比率为">则层次总排序的一致性比率为：</h6><p><span class="math display">\[CR=\frac{a_1CI_1+a_2CI_2+...+a_mCI_m}{a_1RI_i+a_2RI_2+...+a_mRI_m}\]</span></p><h6 id="当cr0.1满足">当CR&lt;0.1满足</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401251130829.png" /></p><h6id="例题1.1记第2层准则对第一层目标的权向量为w20.2630.4750.0550.0900.110t同样求第三层方案对第二层每一元素准则的权向量准则层5件方案层3件">例题1.1记第2层(准则)对第一层(目标)的权向量为<spanclass="math inline">\(w^{(2)}=(0.263,0.475,0.055,0.090,0.110)^T\)</span>同样求第三层(方案)对第二层每一元素(准则)的权向量:(准则层5件，方案层3件)</h6><p><span class="math display">\[方案层对C_1(准则)的成对比较阵\\B_1=\left[\matrix{1&amp;2&amp;5\\1/2&amp;1&amp;5\\1/5&amp;1/2&amp;1}\right]\\方案层对C_2(费用)的成对比较阵\\B_2=\left[\matrix{1&amp;1/3&amp;1/8\\3&amp;1&amp;1/3\\8&amp;3&amp;1}\right]\\...\\方案层对C_5的成对比较阵\\B_5=...\]</span></p><p><span class="math display">\[最大特征根\lambda_1=3.005,\lambda_2=3.002,...\\权向量\omega_1^{(3)}=(0.595,0.277,0.219)\\\omega_2^{(3)}={0.082,0.236,0.682}\\...\]</span></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401241701072.png" /></p><h6id="方案p1对目标的组合权重为0.5950.2630.0820.4750.0550.4290.0900.6330.1100.1660.300">方案p1对目标的组合权重为：<spanclass="math inline">\(0.595*0.263+0.082*0.475+0.055*0.429+0.090*0.633+0.110*0.166=0.300\)</span></h6><h5id="方案层对目标的组合权向量为0.3000.2460.456t">方案层对目标的组合权向量为<spanclass="math inline">\((0.300,0.246,0.456)^T\)</span></h5><h6id="例题1.2设某学校数学建模教练根据实际需要拟从报名参赛的20名队员的基本条件的量化情况请根据这些条件对20名队员进行综合评价从中选出15名综合素质较高的优秀队员">例题1.2设某学校数学建模教练根据实际需要，拟从报名参赛的20名队员的基本条件的量化情况。请根据这些条件对20名队员进行综合评价，从中选出15名综合素质较高的优秀队员</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202401251214045.png" /></p><h5id="这是一个半定性的题目1建立层次结构图第一层为目标层选拔优秀参赛队员2准则层选拔优秀队员需要考虑的6个因素依次为学科知识竞赛成绩思维敏捷度知识面宽广度写作能力计算机应用能力协作能力3第三层为方案层参选的20名队员">这是一个半定性的题目(1)建立层次结构图：第一层为目标层，选拔优秀参赛队员(2)准则层，选拔优秀队员需要考虑的6个因素，依次为学科知识竞赛成绩，思维敏捷度，知识面宽广度，写作能力，计算机应用能力，协作能力(3)第三层为方案层：参选的20名队员</h5><p>根据假设，构造准则层C对目标层O的两两比较矩阵 <spanclass="math display">\[\left[\matrix{1&amp;2&amp;3&amp;4&amp;5&amp;6\\1/2&amp;1&amp;2&amp;3&amp;4&amp;5\\1/3&amp;1/2&amp;1&amp;2&amp;3&amp;4\\1/4&amp;1/3&amp;1/2&amp;1&amp;2&amp;3\\1/5&amp;1/4&amp;1/3&amp;1/2&amp;1&amp;2\\1/6&amp;1/5&amp;1/4&amp;1/3&amp;1/2&amp;1}\right]\\和法计算最大特征向量和特征根为:\\\lambda_{max}=6.1232\\\omega^{(2)}=(0.3794,0.2488,0.1604,0.10240.0655,0.0434)^T\\一致性指标为:CI^{(2)}=0.0246,随机性指标RI^{(2)}=1.24\\一致性比率:CR^{(2)}=0.0198&lt;0.1,通过一致性检验\]</span></p><h5id="根据表1和模型假设构造方案层p中20个队员对准则层c中各个因素c_k的两两比较">根据表1和模型假设，构造方案层P中20个队员对准则层C中各个因素C_k的两两比较</h5><p><span class="math display">\[B_k=(b_{ij}^{(k)})_{20×20},其中b_{ij}^{(k)}=\frac{r_i^{(k)}}{r_j^{(k)}},(ij=1,2,...,20,k=1,2,...,6)\]</span></p><h5id="显然所有的b_k均为一致阵一致阵的最大特征根n于是b_k的最大特征根为">显然，所有的B_k<code>均为一致阵(一致阵的最大特征根=n)</code>，于是B_k的最大特征根为：</h5><p><span class="math display">\[\lambda_{max}^{(k)}=20,CI_k=0,CR_k=0\]</span></p><h5id="b_k的任意一列向量都是lambda_max的特征向量将其归一化得到方案层p对c_k的权重向量omega_k3.于是方案层对准则层的权重向量矩阵">B_k的任意一列向量都是<spanclass="math inline">\(\lambda_{max}\)</span>的特征向量，将其归一化得到方案层P对C_k的权重向量<spanclass="math inline">\(\omega_k^{(3)}\)</span>.于是，方案层对准则层的权重向量矩阵：</h5><p><span class="math display">\[W^{(3)}=[\omega_1^{(3)},\omega_2^{(3)},...,\omega_6^{(3)}]\\一致性比率为CR_k=0(k=1,2,...6),通过一致性检验\]</span></p><p>方案层对目标层的组合权向量为： <span class="math display">\[\omega^{(3)}=W^{(3)}\omega^{(2)}=(0.00498,0.0474,0.0490,0.0513,\\0.0497,0.0517,0.0526,0.0504,\\0.0450,0.0464,0.0480,0.0523,\\0.0535,0.0511,0.0496,0.0505,\\0.05310.0500,0.0506,0.0481)^T\\组合一致性指标CI^{(3)}=0，组合一致性比率为：\\CR^{(3)}=CR^{(2)}+\frac{CI^{(3)}}{RI^{(3)}}=0.0198&lt;0.1\]</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性规划模型基本原理lp&quot;&gt;线性规划模型基本原理（LP）&lt;/h1&gt;
&lt;h3 id=&quot;在资源固定的利润最大化问题&quot;&gt;在资源固定的利润最大化问题:&lt;/h3&gt;
&lt;h6
id=&quot;例题1.1-某机床厂生产甲乙两种机床每台销售后的利润分别为4千元和3千元生产甲机床需要用</summary>
      
    
    
    
    <category term="数学建模学习" scheme="https://pipi1002.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构exam</title>
    <link href="https://pipi1002.github.io/2023/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84exam/"/>
    <id>https://pipi1002.github.io/2023/11/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84exam/</id>
    <published>2023-11-09T10:55:41.000Z</published>
    <updated>2023-12-25T15:52:21.113Z</updated>
    
    <content type="html"><![CDATA[<h2id="数据结构中与所使用的计算机无关的是数据的____结构">1.数据结构中，与所使用的计算机无关的是数据的____结构</h2><ul class="task-list"><li><label><input type="checkbox" />存储</label></li><li><label><input type="checkbox" />物理</label></li><li><label><input type="checkbox" checked="" />逻辑</label></li><li><label><input type="checkbox" />物理和逻辑</label></li></ul><h2id="计算机算法必须具备输入输出和____等5个特性">2.计算机算法必须具备输入，输出和____等5个特性</h2><ul class="task-list"><li><label><inputtype="checkbox" />可行性，可移植性和可扩充性</label></li><li><label><input type="checkbox"checked="" />可行性，确定性和有穷性</label></li><li><label><input type="checkbox" />确定性，有穷性和稳定性</label></li><li><label><input type="checkbox" />易读性，稳定性和安全性</label></li></ul><h2 id="顺序表表链表的特点">3.顺序表表，链表的特点</h2><ul><li>顺序表是顺序存储，在存储的时候，<code>插入和删除需要移动插入和删除点后面的数据</code>，不方便</li><li>在n个节点的顺序表上做插入，删除节点运算的时间复杂度为<code>O(n)</code>，在长度为n的顺序表的第i个位置上插入一个元素，元素的移动次数是<code>O(n-i+1)</code>.拥有n个元素的顺序表中插入一个新元素，平均移动<code>n/2</code>个元素</li><li>线性表中节点的集合是<code>有限的</code>，节点之间的关系是<code>一对一的</code></li><li>顺序表可以直接对节点进行存取，不需要访问之前的节点，所以于顺序表的长度N无关，因此在顺序表中访问任一节点的时间复杂度为<code>O(1)</code></li><li>链表中的节点可包含多个指针域，分别存放多个指针。例如双向链表中的节点含有两个指针，分别存放其直接前驱和直接后继节点的指针</li><li>链表的存储特点是无序，而链表示意图有序。</li><li>链表的节点不会移动，只是指针内容改变</li><li>顺序存储方式不仅用于存储线性结构还可以存储非线性结构，例如完全二叉树</li><li>在顺序表中访问第i个节点和求第i个节点的直接前驱算法时间复杂度为<code>O(1)</code>,所以若线性表最常用的操作是存取第i个元素及其前驱的值，则采用顺序表的存储方式</li><li>单链表的存储密度<code>小于1</code></li><li>链表不具有的特点是：不可以<code>随机访问</code>任一元素，<code>不适用于随机存取</code>，所以顺序表相对于链表优点是，存储密度高和随机存储</li><li>在某链表中最常用的操作是在最后一个节点之后插入一个节点和删除最后一个节点，则采用<code>带头节点的双循环链表</code></li><li>带头节点的单链表为空的条件是<code>head-&gt;next=NULL</code>，因为head指向头节点，head-&gt;next指向第一个元素节点，head-&gt;next==NULL代表该单链表为空.在单链表中，增加头节点的目的是为了<code>方便运算的实现</code></li></ul><h2 id="栈和队列的特点">4.栈和队列的特点</h2><ul><li><p>队列中的元素个数是<code>可变的</code></p></li><li><p>队列是一个<code>加了限制的</code>线性表结构</p></li><li><p><code>循环队列所占用的空间必须连续</code>，循环队列的引入，目的是为了克服<code>假溢出</code>现象</p></li><li><p>存放循环队列元素的数组data有10个元素，则data数组的下标范围是<code>0~9</code></p></li><li><p>在有n个元素的栈中，进栈操作的时间复杂度为<code>O(1)</code>，出栈操作的时间复杂度为<code>O(1)</code>n</p></li><li><p>在顺序栈中，当栈顶指针为top=-1时表示栈空，top=MAXLEN-1时栈满；在链栈中，当栈顶指针等于<code>NULL</code>时表示栈空</p></li><li><p>向栈中压入元素的操作是先<code>移动栈顶指针</code>，后<code>存入元素</code></p></li><li><p>从循环队列中删除一个元素时，其操作是先<code>移动队首指针，后取出元素</code>；在循环队列中，队首指针指向队首元素的<code>前一个</code>位置；在具有n个单元的循环队列中，队满时一共有n-1个元素</p></li><li><p>&lt;1&gt;数组Q[n]用来表示一个循环队列，f为当前队列头元素的前一位置，r为队尾元素的位置，假定队列中元素个数小于n，计算队列中元素的公式为<code>(n+r-f)%n</code></p></li><li><p>&lt;2&gt;判定一个循环队列QU为满队列的条件是<code>rear+1=front</code>或者<code>(QU-&gt;rear+1)%maxsize==QU-&gt;front</code></p></li><li><p>&lt;3&gt;判定一个循环队列为空的条件：<code>rear=front</code></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312241507158.jpg"alt="1a03eafbf2c497134896133bacbda77" /><figcaptionaria-hidden="true">1a03eafbf2c497134896133bacbda77</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312241507517.jpg"alt="e653c3162f8da4b8729779a3763431b" /><figcaptionaria-hidden="true">e653c3162f8da4b8729779a3763431b</figcaption></figure></li><li><p>如果一个栈A[n]为栈底，说明为<code>向下生成堆栈</code>，用A[T]表示栈顶元素，当推入一个新元素的时候，变量T<code>减一</code>,当弹出一个新元素的时候，变量T<code>加一</code></p></li><li><p>为了增加内存空间的利用率和减少溢出的可能性，由两个栈共享一片连续的内存空间时，应将这两栈的<code>栈底</code>分别设在这片内存空间的两端，这样，只有当<code>这两个栈的栈顶在到达栈空间的某一位置相遇时</code>，才产生上溢。top[i]代表第i个(i=1,2)栈顶，栈满的条件是top[1]+1=top[2].</p></li><li><p>带表头节点 的空循环双向链表的长度等于<code>0</code></p></li><li><p>用连接方式存储的队列，在进行删除运算时，头尾指针可能都要修改。(1.如果队列只有一个元素时，若这个元素出队，则队头队尾指针均要指向空，均要修改。2.如果队列有两个及以上元素时，则只需要修改队头指针不需要修改队尾指针)</p></li><li><p>用单链表表示的链式队列的队头在链表的<code>表头</code></p></li></ul><h2id="最大容量为n的循环队列队尾指针是rear队头是front则队空的条件是">5.最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是</h2><ul class="task-list"><li><label><input type="checkbox" />(rear+1)%n==front</label></li><li><label><input type="checkbox" checked="" />rear==front</label></li><li><label><input type="checkbox" />rear+1==front</label></li><li><label><input type="checkbox" />(rear-1)%n==front</label></li></ul><h2id="如果以链表作为栈的存储结构则出栈操作时">6.如果以链表作为栈的存储结构，则出栈操作时</h2><ul class="task-list"><li><label><input type="checkbox" />必须判别栈是否满</label></li><li><label><input type="checkbox"checked="" />必须判别栈是否为空</label></li><li><label><input type="checkbox" />必须判别栈元素类型</label></li><li><label><input type="checkbox" />队栈可以不做任何判别</label></li></ul><h2id="在c语言中一个顺序栈一旦被声明其占用空间的大小">7.在C语言中，一个顺序栈一旦被声明，其占用空间的大小</h2><ul class="task-list"><li><label><input type="checkbox" checked="" />已固定顺序栈的特点：顺序存储并空间固定</label></li><li><label><input type="checkbox" />不固定</label></li><li><label><input type="checkbox" />可以改变</label></li><li><label><input type="checkbox" />动态变化</label></li></ul><h2id="已知先后续遍历与中序遍历求后先序遍历">8.已知先/后续遍历与中序遍历求后/先序遍历</h2><ul><li>二叉树采用中序遍历可以得到接待你的有序序列</li></ul><h5id="例子设有一颗二叉树其先序遍历是abcdefg其中序遍历是cbaedfg则该二叉树的后续遍历为cbegfda">例子：设有一颗二叉树，其先序遍历是ABCDEFG，其中序遍历是CBAEDFG，则该二叉树的后续遍历为（CBEGFDA）</h5><h5id="设有一颗二叉树其后序遍历是dabec其中序遍历是debac则该二叉树的先续遍历为cedba">设有一颗二叉树，其后序遍历是DABEC，其中序遍历是DEBAC，则该二叉树的先续遍历为（CEDBA）</h5><p><code>方法如下：</code>1.先序遍历的第一个节点一定是根节点</p><p>​ 2.中序遍历的第一个节点一定是最左端的节点</p><p>​ 3.后续遍历是确定最后一个数为根节点（从下往上写）</p><p>例题1： (先序)</p><p>​ A A</p><p>​ B B</p><p>​ C C</p><p>​ D D</p><p>​ E E</p><p>​ F F</p><p>​ G G</p><p>​ C B A E D F G (中序)</p><h6id="注意左子树的所有节点在父母节点左方右子树的所有节点在父母节点右方这就说明f为什么是d的右子树而不是e的右子树因为如果f是e的右子树说明f也是d的左边但实际上不是">注意：左子树的所有节点在父母节点左方，右子树的所有节点在父母节点右方(这就说明F为什么是D的右子树而不是E的右子树，因为如果F是E的右子树说明F也是D的左边但实际上不是)</h6><p>例题2：（后序）</p><p>​ C C</p><p>​ E E</p><p>​ B B</p><p>​ A A</p><p>​ D D</p><p>​ D E B A C (中序)</p><h3id="已知二叉树求先根中根后根遍历">已知二叉树求先根，中根，后根遍历</h3><p><code>先根遍历</code>：先再每个节点的左边画一个圈，然后用一根线从左上方出发，把圈连起来，先连到的先写</p><p><code>中根遍历</code>：先再每个节点的下边画一个圈，然后用一根线从左上方出发，把圈连起来，先连到的先写</p><p><code>后根遍历</code>：先再每个节点的右边画一个圈，然后用一根线从左上方出发，把圈连起来，先连到的先写</p><h5id="例子如果是先根再左再根再右">例子：如果是<code>先根再左再根再右</code></h5><h6id="注意特点是凡是有左子树的节点必间隔左子树的所有节点再出现a-b-d反之就会马上重复出现c-e-f-g"><code>注意：</code>特点是凡是有左子树的节点，必间隔左子树的所有节点再出现(AB D)，反之就会马上重复出现(C E F G)</h6><p><code>答案：</code>ABCCEEBADFFDGG</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">BD</span><br><span class="line">CFG</span><br><span class="line">  E</span><br></pre></td></tr></table></figure><h2id="在下列存储形式中哪一种不是数的存储形式">9.在下列存储形式中，哪一种不是数的存储形式</h2><ul class="task-list"><li><label><input type="checkbox" />双亲表示法</label></li><li><label><input type="checkbox" />孩子链表表示法</label></li><li><label><input type="checkbox" />孩子兄弟链表表示法</label></li><li><label><input type="checkbox"checked="" />顺序存储表示法</label></li></ul><h2id="在一棵度为3的树中说明不是二叉树度为3的节点数为2个度为2的节点数为1个度为1的节点数为2个那么度为0的节点数为">10.在一棵度为3的树中（说明不是二叉树），度为3的节点数为2个，度为2的节点数为1个，度为1的节点数为2个，那么度为0的节点数为</h2><ul><li><p><label><input type="checkbox" />4</label></p></li><li><p><label><input type="checkbox" />5</label></p></li><li><p><label><input type="checkbox" checked="" />6</label></p></li><li><p><label><input type="checkbox" />7</label></p></li><li><p><code>树节点的度数是该节点字数或分支的个数</code>，树的度数是其中节点度数的最大值</p></li><li><p>边总数为3x2+2x1+1x2=10 (这个方法树和二叉树都适用)</p><ul><li>节点个数是（设度为0的节点个数是Q）2+1+2+Q<ul><li>由节点个数可以推出边的个数为2+1+2+Q-1（因为除了头节点上没有边，其它节点都有和父母节点相连的边）即：3x2+2x1+1x2=2+1+2+Q-1则Q=6</li></ul></li></ul></li></ul><h6id="如果该树为二叉树那么度为0的节点是度为2节点的个数加1">如果该树为二叉树那么度为0的节点是度为2节点的个数加1</h6><h2id="无向图的顶点个数为n则该图最多有条边">11.无向图的顶点个数为n，则该图最多有（）条边</h2><ul class="task-list"><li><label><input type="checkbox" />n-1</label></li><li><label><input type="checkbox"checked="" /><code>n(n-1)/2</code></label></li><li><label><input type="checkbox" />n(n+1)/2</label></li><li><label><input type="checkbox" />n^2</label></li></ul><h6id="一个无向图顶点为n个最多包含nn-12条边最少包含n-1条边">一个无向图顶点为n个，最多包含<code>n(n-1)/2</code>条边，最少包含n-1条边</h6><h2id="要联通具有n个顶点的有向图至少需要条边">12.要联通具有n个顶点的有向图至少需要（）条边</h2><ul class="task-list"><li><label><input type="checkbox" />n-1</label></li><li><label><input type="checkbox"checked="" /><code>n</code></label></li><li><label><input type="checkbox" />n+1</label></li><li><label><input type="checkbox" />2n</label></li></ul><h6id="n个节点的完全有向图含有边的数目为nn-1完全有向图的定义是在有向图中如果任意两给顶点之间都存在方向互为相反的两条弧则称该图为有向完全图">n个节点的完全有向图含有边的数目为<code>n*（n-1）</code>，完全有向图的定义是在有向图中，如果任意两给顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</h6><h2 id="查找">13.查找</h2><ul><li><p>查找表是以<code>集合</code>为查找结构的</p></li><li><p>顺序查找法适合于存储结构为<code>顺序存储或是链式存储</code>的线性表</p></li><li><p>折半查找：以顺序方式存储（一个有序的单链表不能用折半查找的方式查找），且结点按关键字有序排列。折半查找方法：偶数查找第n/2个奇数查找第n/2+1</p><p>用折半查找表的元素的速度比用顺序法查找<code>不能确定</code>,在有序的顺序储存表时，折半查找在大部分情况来说要快</p><h4id="有一个顺序表为139123241456275778295100当折半查找值为82的节点时要查找几次-4">有一个顺序表为{1，3，9，12，32，41，45，62，75，77，82，95，100}当折半查找值为82的节点时，要查找几次4</h4><ol type="1"><li>先查找到45（13/2+1=7）</li><li>再查找到77</li><li>再查找到95</li><li>最后查找到82</li><li>分块查找：数据分成若干块，每块内数据不必有序（任意存放），但块间必须有序（按关键字有序），每块内最大（或最小）的数据组成索引块，首先查找<code>索引表</code>，再查找<code>相应的块</code></li></ol></li><li><p>顺序查找，折半查找，分块查找都属于<code>静态查找</code></p></li><li><h5id="折半查找法的判定树和平均查找长度">折半查找法的判定树和平均查找长度</h5><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312251727195.jpg"alt="992cbaae8396f199c4a85f5f9591a05" /><figcaptionaria-hidden="true">992cbaae8396f199c4a85f5f9591a05</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312251728134.jpg"alt="1c791b0ca508d43a6a631f9f8931d35" /><figcaptionaria-hidden="true">1c791b0ca508d43a6a631f9f8931d35</figcaption></figure></li></ul><h2 id="哈希表">14.哈希表</h2><h3id="在线性表的哈希存储中装填因子ɑ又称装填系数若用m表示哈希表的长度n表示线性线性表元素中的个数则ɑnm">在线性表的哈希存储中，装填因子ɑ又称装填系数，若用m表示哈希表的长度n表示线性线性表元素中的个数，则<code>ɑ=n/m</code></h3><h6 id="构造哈希表的方法">构造哈希表的方法：</h6><p>1.ASL成功：每个元素的查找次数/元素个数</p><p>2.ASL失败：后<code>小于表长的最大素数</code>个格子里的数不需要看他的失败次数，空格代表失败次数。所有(前最大素数给元素个空格中元素)失败次数/最大素数</p><h6id="注意不成功的平均查找长度算式的分母一直是题目哈希函数里mod后面那个数题目给什么数据你就用什么如果要自己写哈希函数那分母就是小于等于表长的最小素数质数就是那个p">注意：不成功的平均查找长度，算式的分母一直是题目哈希函数里mod后面那个数（题目给什么数据你就用什么）如果要自己写哈希函数那分母就是小于等于表长的最小素数（质数）——就是那个p</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312251552436.jpg"alt="44bd411529b47903a4af66d6bd98b3d" /><figcaptionaria-hidden="true">44bd411529b47903a4af66d6bd98b3d</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312251551372.jpg"alt="ff4c675b0c0a4d266e8a5b655049393" /><figcaptionaria-hidden="true">ff4c675b0c0a4d266e8a5b655049393</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312251551898.jpg"alt="62bc78f2f4e98ddaa58760c64ec0007" /><figcaptionaria-hidden="true">62bc78f2f4e98ddaa58760c64ec0007</figcaption></figure><h2 id="树和森林与二叉树的转换">15.树和森林与二叉树的转换</h2><ul><li>树转化为二叉树<ol type="1"><li>给兄弟加线</li><li>给除长子外的孩子去线</li><li>层次调整</li></ol></li><li>森林转化成二叉树<ol type="1"><li>将森林中的每棵树转化为二叉树</li><li>将所有的二叉树合并成一个树（将第二个二叉树的根节点作为第一棵二叉树根节点的右孩子，将第三棵二叉树的根节点作为第二个二叉树的右孩子）</li></ol></li><li>二叉树转化成树<ol type="1"><li>如果一个节点的左孩子存在，则将左孩子的右孩子节点的右孩子节点都与该节点进行连线</li><li>去除右孩子的连线</li><li>层次调整</li></ol></li><li>二叉树转化成森林，看二叉树的根节点是否右右孩子，有就可以转化<ol type="1"><li>先把根节点的右孩子去线，去掉后形成两个树，继续把根节点的右孩子去线</li><li>将分离的二叉树转化成树</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312141227039.jpg" alt="IMG_20231213_230332" style="zoom: 25%;" /></p><h2 id="排序">16.排序</h2><h3id="插入排序--每次将一个待排序的记录按其关键字大小插入前面已经排好的子序列中直接插入排序最坏所需时间on2平均所需时间on2">插入排序--每次将一个待排序的记录按其关键字大小插入前面已经排好的子序列中（直接插入排序最坏所需时间O(n<sup>2);平均所需时间O(n</sup>2)）</h3><p><code>注意</code>：每个比较的元素是和前面排好序的最大的开始向前比较</p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312122029461.png" /></p><h3id="希尔排序--每次分组为第一次分组大小的一半奇数为n-12最坏所需时间on2">希尔排序--每次分组为第一次分组大小的一半（奇数为n-1/2）（最坏所需时间O(n^2)）</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312122029676.png"alt="CSDN_1702383846133" /><figcaption aria-hidden="true">CSDN_1702383846133</figcaption></figure><h3id="选择排序--有序区域初始为空位于左端无序区域位于右端从无序区中选择关键字值最小的记录将其与无序区第一个记录交换位置直到全部待排序的数据元素排完-直接选择排序最坏所需时间on2-关键字比较次数与记录初始排列无关">选择排序--有序区域初始为空，位于左端，无序区域位于右端，从无序区中选择关键字值最小的记录，将其与无序区第一个记录交换位置。直到全部待排序的数据元素排完(直接选择排序最坏所需时间O(n^2)) 关键字比较次数与记录初始排列无关</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312122040851.png"alt="CSDN_1702384800729" /><figcaption aria-hidden="true">CSDN_1702384800729</figcaption></figure><h3id="冒泡排序--将键值大的记录向序列的尾部移动键值小的向序列头部移动-最坏所需时间on2-当元素从小到大排列所需冒泡排序比较次数最少为n-1次当元素从大到小排列所需冒泡排序比较次数最多为n-1n2次">冒泡排序--将键值大的记录向序列的尾部移动，键值小的向序列头部移动(最坏所需时间O(n^2))当元素从小到大排列，所需冒泡排序比较次数最少为n-1次，当元素从大到小排列，所需冒泡排序比较次数最多为(n-1)*n/2次</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312122041666.png"alt="CSDN_1702384327083" /><figcaption aria-hidden="true">CSDN_1702384327083</figcaption></figure><h3id="归并排序最坏所需时间onlog2n">归并排序（最坏所需时间O(nlog2n)）</h3><ul><li>分解：将n个元素分成个含n/2个元素的子序列。</li><li>解决：用合并排序法对两个子序列递归的排序。</li><li>合并：合并两个已排序的子序列已得到排序结果。</li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312131254633.jpg" /></p><h3 id="快速排序">快速排序</h3><ul><li>随便找一个基准元素，将比这个基准元素小的放左边，大的放右边，相对顺序不变<ul><li>例如初始为50，20，10，40，70，80，90，60进行快速排序，以50为基准元素则第一次排序结果为20，10，40，<code>50</code>，70，80，90，60</li></ul></li><li>此时这个基准元素左右的元素，相当于被分成了两个子表，左表为20，10，40右表为70，80，90，60下一步就是分别在两个子表中各找一个基准元素，重复第一步（这时候不用管50的位置，50位置不变，相当于一个分界线）<ul><li>以20为左表的基准元素，则10要放在20左边，以70作为右表的基准元素则60要放在70左边。则第二次排序结果为10，<code>20</code>，40，<code>50</code>，60，<code>70</code>，80，90</li></ul></li><li>再把上一步的基准元素的左右两边（20的左边是10，右边是40；70的左边是60，右边是80，90）分成两个子表重复第二步<ul><li>（因为20的左，右子表和70的左子表就只剩一个元素，所以不用再管）70的右子表为80，90，再以80为基准元素，以上就排列完成了</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">例如：Q  H  C  Y  P  A  M  S  R  D  F X用快速排序</span><br><span class="line">    以Q为基准元素拿出来:  ()  H  C  Y  P  A  M  S  R  D  F  X</span><br><span class="line">          low high</span><br><span class="line">        因为X大于Q：(为保证low，high中有一个为空，high向左移动)：()  H  C  Y  P  A  M  S  R  D  F  X</span><br><span class="line">                                                         low   high</span><br><span class="line">        因为F小于Q，Q移到low：F  H  C  Y  P  A  M  S  R  <span class="title function_">D</span>  <span class="params">()</span>  X</span><br><span class="line">                          low    high</span><br><span class="line">        移动low：F  H  C  Y  P  A  M  S  R  <span class="title function_">D</span>  <span class="params">()</span>  X</span><br><span class="line">                 low            high</span><br><span class="line">        因为C小于Q，不动，继续移动low：F  H  C  Y  P  A  M  S  R  <span class="title function_">D</span>  <span class="params">()</span>  X</span><br><span class="line">           lowhigh</span><br><span class="line">        因为Y大于Q，所以把Y移到high：F  H  <span class="title function_">C</span>  <span class="params">()</span>  P  A  M  S  R  D  Y  X</span><br><span class="line">          low   high</span><br><span class="line">        移动high：F  H  <span class="title function_">C</span>  <span class="params">()</span>  P  A  M  S  R  D  Y  X</span><br><span class="line">          low    high</span><br><span class="line">        因为D小于Q，把D移动到low：F  H  C  D  P  A  M  S  <span class="title function_">R</span>  <span class="params">()</span>  Y  X</span><br><span class="line">           low     high</span><br><span class="line">        移动low：F  H  C  D  P  A  M  S  <span class="title function_">R</span>  <span class="params">()</span>  Y  X</span><br><span class="line">           low      high</span><br><span class="line">        因为P小于Q不移动，移动low：F  H  C  D  P  A  M  S  <span class="title function_">R</span>  <span class="params">()</span>  Y  X</span><br><span class="line">         low     high</span><br><span class="line">        因为A小于Q不移动，移动low：F  H  C  D  P  A  M  S  <span class="title function_">R</span>  <span class="params">()</span>  Y  X</span><br><span class="line">        low      high</span><br><span class="line">        因为M小于Q不移动，移动low：F  H  C  D  P  A  M  S  <span class="title function_">R</span>  <span class="params">()</span>  Y  X</span><br><span class="line">           low   high</span><br><span class="line">        因为S大于Q，移动S到high：F  H  C  D  P  A  <span class="title function_">M</span>  <span class="params">()</span>  R  S  Y  X</span><br><span class="line">          low    high</span><br><span class="line">        移动high：F  H  C  D  P  A  <span class="title function_">M</span>  <span class="params">()</span>  R  S  Y  X</span><br><span class="line">         low high</span><br><span class="line">        因为R大于Q不移动，移动<span class="title function_">high</span><span class="params">(此时high和low重合)</span>：F  H  C  D  P  A  <span class="title function_">M</span>  <span class="params">()</span>  R  S  Y  X</span><br><span class="line">                         <span class="title function_">high</span></span><br><span class="line">          <span class="params">(low)</span></span><br><span class="line">        把Q放入：F  H  C  D  P  A  M  Q  R  S  Y  X</span><br></pre></td></tr></table></figure><h3 id="堆排序">堆排序</h3><h6id="堆二叉树根节点的数值要比左右节点大">堆：二叉树，根节点的数值要比左右节点大</h6><h6id="把一个二叉树变换为堆的方法"><code>把一个二叉树变换为堆的方法：</code></h6><ul><li>编号最大的非叶子节点是最大编号的叶子节点编号的一半，向下取整（n/2）。第一个调整的就是编号最大的非叶子节点</li><li>接着调整其前面编号的其它节点，看是否满足<code>大根堆</code>（根节点要大于左右两字数，如不大于，选择最大的根节点与其交换位置）</li><li>调整为大根堆后，将序号最大的叶子节点和根节点交换，这个时候最大编号的叶子节点存放的就是最大值的元素，之后就不用将它继续排序，直接拿出来作为顺序表末尾。再把剩下的n-1个元素继续大根堆排序。再反复重复这一步骤。</li></ul><h3id="表中元素递增分别用冒泡排序堆排序快速排序归并排序---冒泡排序最快快速排序最慢">表中元素递增，分别用冒泡排序，堆排序，快速排序，归并排序---冒泡排序最快，快速排序最慢</h3><h2 id="算法">17.算法</h2><ul><li>算法的特性：<code>有穷性，确定性，可行性，输入，输出</code></li><li>算法效率的度量可以分为时间复杂度和空间复杂度</li><li>若一个算法中的<code>语句频度</code>之和为T(n)=7n+4n<sup>2,则算法的时间复杂度为O(n</sup>2)</li><li>数据的四种存储结构是：<code>顺序，链接，索引，散列</code></li></ul><h2 id="已知广义表求表头表尾">18.已知广义表，求表头表尾</h2><h3id="表头当广义表ls非空时称第一个元素为ls的表头">表头：当广义表LS非空时，称第一个元素为LS的表头</h3><h3id="表尾称广义表ls中去除表头后其余元素组成的广义表为ls的表尾">表尾：称广义表LS中去除表头后其余元素组成的广义表为LS的表尾</h3><h3id="表头是元素表尾是广义表"><code>表头是元素，表尾是广义表</code></h3><h5id="广义表abcde的表头和表尾分别是abcde">广义表((a),((b),(c,d,e)))的表头和表尾分别是<code>(a)</code>,<code>((b),(c,d,e))</code></h5><h5id="广义表abc的表头和表尾分别是abc">广义表(a,b,c)的表头和表尾分别是<code>a</code>,<code>(b,c)</code></h5><h5id="广义表ab的表头和表尾分别是ab">广义表(a,(b))的表头和表尾分别是<code>a</code>，<code>((b))</code></h5><h5id="广义表a的表头和表尾分别是a">广义表(a)的表头和表尾分别是<code>a</code>,<code>()</code></h5><ul><li>广义表可以递归</li></ul><h3 id="广义表的长度和深度"><code>广义表的长度和深度：</code></h3><h5id="对于广义表labc-l顶层就一个元素那就是abc这个广义表因此l的长度为1对于深度外面l是第一层内部的abc是第二层而abc都是原子元素所以没有更深的层因此深度为2">对于广义表L=((a,b,c));L顶层就一个元素那就是(a,b,c)这个广义表，因此L的长度为1，对于深度，外面L是第一层，内部的(a,b,c)是第二层，而a，b，c都是原子元素，所以没有更深的层，因此深度为2</h5><h2 id="二叉树">19.二叉树</h2><ul><li>对于一个二叉树来说，第i层最多有<code>2^(i-1)</code>个节点</li><li>由3个节点构成的二叉树共有5个不同的结构</li></ul><h2 id="已知广义表画出树">20.已知广义表画出树</h2><h5id="每一层是上一层的孩子节点每一层逗号左边是上一层的左节点逗号右边是上一层的右节点根左-右">每一层是上一层的孩子节点，每一层逗号左边是上一层的左节点，逗号右边是上一层的右节点（根（左，右））</h5><p>例如：(A ( B ( C , D ( E ) ) ) )</p><ul><li>A的左节点是B 因为B同层没有逗号，所以A没有右节点</li><li>C是B的左节点D是C的右节点</li><li>E是D的左节点</li></ul><h2id="哈夫曼树的构造和带权路径的求法">21.哈夫曼树的构造和带权路径的求法</h2><p>例如：W（权值集合）=（5，29，7，8，14，23，3，11）构造哈夫曼树</p><ul><li>把权值从小到大排序：3，5，7，8，11，14，23，29</li><li>找最小的两个权值：3，5</li><li>再把最小两个权值的和（8）放到权值集合当中，把已经找出的两个最小权值删除：8，7，8，11，14，23，29</li><li>构成新的权值集合后再重复第一步去排序：7，8，8，11，14，23，29<ul><li>把7，8删掉，求和为15，把15放入：15，8，11，14，23，29</li><li>排序：8，11，14，15，23，29</li><li>…………</li></ul></li></ul><h6id="注意重要的是层次排列每个放入哈夫曼树的值要找到其对应的求和">注意：重要的是层次排列，每个放入哈夫曼树的值要找到其对应的求和</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312131409203.png" /></p><h3 id="带权路径长度的求和左0右1">带权路径长度的求和（左0右1）</h3><p>把每个节点的左右分支标成0和1，哈夫曼编码就是从头到这个节点所经过路径用0，1代替。如图，7的哈夫曼编码是<code>1110</code></p><p>wpl（带权路径长度）：带权叶子节点×它的路径长度，再把每个相加起来。例如上图：3×4+5×4+11×3+23×2+29×2+14×3+7×4+8×4</p><ul><li>首先，哈夫曼树是一个二叉树，并且哈夫曼树的度只有两种情况，一个是只有两个度的节点，一个树没有度的节点。例如：如果一个哈夫曼树一共有11个节点，则叶子节点有（6）个（<code>哈夫曼树的节点有m个，则叶子节点有(m+1)/2个，分支节点有(m-1)/2个</code>）</li></ul><h2id="强连通分量的个数有向图中的定义">22.强连通分量的个数（有向图中的定义）</h2><h6id="强连通分量---有向图中极大联通子图">强连通分量---有向图中极大联通子图</h6><ul><li>找环（圈）</li><li>将整个环变成一个点</li><li>简化成新图后就方便找到强连通分量（有去有回）注意：<code>一个点也算一个强连通分量：图中v1，v5，v6就分别算一个强连通分量，加上可以被看做连通分量的环，一共四个强连通分量</code></li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312131447333.png"alt="26208517024498982_edit_208218952811641" /><figcaptionaria-hidden="true">26208517024498982_edit_208218952811641</figcaption></figure><h5id="连通分量是无向图中的定义连通分量指的是不互相连通的连通图的个数">连通分量是无向图中的定义，连通分量指的是不互相连通的连通图的个数</h5><ul><li>完全图：也称简单完全图。一个图任意两个顶点之间都有边的话，该图就称为完全图。</li><li></li></ul><h2id="图树邻接矩阵邻接表的深度遍历广度遍历-最小生成树的算法">23.图，树，邻接矩阵，邻接表的深度遍历/广度遍历最小生成树的算法</h2><h5 id="深度遍历走路径走过的不再走">深度遍历：走路径，走过的不再走</h5><h5id="广度遍历先遍历离根节点相距离为1的节点再遍历距离与这些节点相距为1的节点">广度遍历：先遍历离根节点相距离为1的节点，再遍历距离与这些节点相距为1的节点…………</h5><h6id="邻接树图矩阵的深度广度优先遍历很简单这里不多讲临界矩阵的遍历先画出图再遍历">邻接树，图，矩阵的深度广度优先遍历很简单，这里不多讲（临界矩阵的遍历，先画出图，再遍历）</h6><p><code>邻接表每一个链表后的节点相当于一层，反应出度情况</code></p><p>深度优先遍历：v1 v2 v4 v3 v5 v6</p><p>广度优先遍历：v1 v2 v3 v4 v5 v6</p><h5 id="逆邻接表反应顶点的入度情况">逆邻接表：反应顶点的入度情况</h5><h2 id="生成树">24.生成树</h2><h5id="连通图生成树-防止环路生成信息风暴非连通树生成森林-n个顶点的连通图的生成树含有n-1个边">连通图生成树（防止环路生成信息风暴），非连通树生成森林<code>N个顶点的连通图的生成树含有N-1个边</code></h5><h5id="注意生成树是对应连通图来说生成树就是极小连通子图包含n个顶点只有足以构成一棵树的n-1条边而生成森林是对应非连通图来说">注意：生成树是对应连通图来说，<code>生成树就是极小连通子图，包含n个顶点，只有足以构成一棵树的n-1条边</code>，而生成森林是对应非连通图来说</h5><h5id="一个无向连接图可能有多棵形态不同的树在一个赋权无向连通图的所有生成树中生成树各边上权值的总和最小的生成树称为最小生成树">一个无向连接图可能有多棵形态不同的树，在一个赋权无向连通图的所有生成树中，生成树各边上权值的总和最小的生成树称为<code>最小生成树</code></h5><h3 id="最小生成树">最小生成树</h3><ul><li>路径加起来权值是最小的</li><li>路径不能构成环路<ul><li>Prime算法是选项点，每次将最小权值的顶点连入成树。每次加入的点都看成一个整体，看连接这个整体的最小路径是和哪个节点连接，找到这个节点，再把这个节点和之前的整体构成一个新的整体。</li><li>Kruskal算法首先把节点画出来，先不要连接，然后依次找路径最小的节点，注意判断是否构成环路</li></ul></li></ul><h2 id="平衡二叉树">25.平衡二叉树</h2><ul><li><p>插入节点(记住要看顺序)</p><ul><li><p>先把插入的那个节点插入到应该插入的位置（按二叉排序树的特点插入）</p></li><li><p>从下往上找第一个的不平衡节点（编号最小的不平衡节点）（这个节点左右子树层数相减-1），把这个节点以及它不平衡（最长长度）的左子树或者右子树中拿出来包含这个不平衡节点的3个节点（进行平衡二叉树方式）调整，剩下子树的节点还是根据二叉排序树的特点（按每层从左到右）放入到这三个调整完的节点上去。</p></li></ul></li><li><p>一个表（数的集合）构造成平衡二叉树则相当于把每个节点插入到的树中，若插入某个节点时树不平衡则用上述方法</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202312141217964.jpg" style="zoom: 25%;" /></p><h3 id="二叉排序树--左边小右边大">二叉排序树--左边小右边大</h3><h5id="平均查找长度asl1第一行元素个数2第二行元素个数3第三行元素个数元素总个数">平均查找长度ASL=（1×第一行元素个数+2×第二行元素个数+3×第三行元素个数+……）/元素总个数</h5><h3id="折半查找的判定树--先把元素按升序排列以中间数据为根节点根节点左边是它的左子树右边是他的右子树">折半查找的判定树--先把元素按升序排列，以中间数据为根节点，根节点左边是它的左子树，右边是他的右子树</h3><h2 id="稀疏矩阵的两种表示方法">26.稀疏矩阵的两种表示方法</h2><ol type="1"><li><h3 id="三元组表">三元组表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知一个6×5的稀疏矩阵如下所示，写出它的三元组线性表</span></span><br><span class="line">| <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>|</span><br><span class="line">| <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>|</span><br><span class="line">| <span class="number">0</span> <span class="number">-1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>|</span><br><span class="line">| <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span> <span class="number">-2</span>|</span><br><span class="line">| <span class="number">5</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>|</span><br><span class="line">| <span class="number">0</span>  <span class="number">0</span>  <span class="number">7</span>  <span class="number">0</span>  <span class="number">0</span>|</span><br><span class="line">(i,j,e)<span class="comment">//i为行数，j为列数，e为元素，0行0列开始，转置前，行从0到5</span></span><br><span class="line"> <span class="number">0</span> <span class="number">4</span> <span class="number">1</span>       <span class="number">0</span> |<span class="number">0</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"> <span class="number">2</span> <span class="number">1</span> <span class="number">-1</span>   转置后(列从<span class="number">0</span>到<span class="number">5</span>)   <span class="number">1</span> |<span class="number">1</span> <span class="number">2</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">3</span> <span class="number">4</span> <span class="number">-2</span>   --------------&gt;  <span class="number">2</span> |<span class="number">2</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"> <span class="number">4</span> <span class="number">0</span> <span class="number">5</span>   <span class="number">3</span> |<span class="number">4</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span> <span class="number">7</span>   <span class="number">4</span> |<span class="number">4</span> <span class="number">3</span> <span class="number">-2</span> (j,i,e)</span><br><span class="line"> <span class="comment">//计算数组num和k的元素，col和num表示第几列有几个非零元素（看转置后的表），k[i]指的是每个列的第一个元素的标号值</span></span><br><span class="line">col   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">4</span></span><br><span class="line">num   <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">k[i]  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span> </span><br></pre></td></tr></table></figure></li><li><h3 id="十字链表法">十字链表法</h3></li></ol><h2id="设目标串abccdcdccbaa模式串adcc第几次匹配成功">27.设目标串“abccdcdccbaa”，模式串“adcc”第几次匹配成功</h2><ul class="task-list"><li><label><input type="checkbox" />5</label></li><li><label><input type="checkbox" checked="" />6</label></li><li><label><input type="checkbox" />7</label></li></ul><h2id="在单链表p所指节点之前插入一个s所指节点">28.在单链表p所指节点之前插入一个s所指节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为是单链表，所以找不到p节点的上一个节点，所以只能让s节点插入到p节点之后，然后s节点数据和p节点数据交换，从而达到前插的目的</span></span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">temp=p-&gt;data;</span><br><span class="line">p-&gt;data=s-&gt;data;<span class="comment">//相当于把p节点滞空</span></span><br><span class="line">s-&gt;data=temp;</span><br></pre></td></tr></table></figure><h2 id="栈的阅读题">29.栈的阅读题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    Char x,y;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    x=’c’;y=’k’; <span class="comment">//x=‘c’, y=‘k’</span></span><br><span class="line">    Push(S,x); <span class="comment">//x=‘c’,y=‘k’,S=“c”</span></span><br><span class="line">    Push(S,’a’); <span class="comment">//x=‘c’,y=‘k’,S=“ac”</span></span><br><span class="line">    Push(S,y); <span class="comment">//x=‘c’, y=‘k’, S=“kac”</span></span><br><span class="line">    Pop(S,x); <span class="comment">//x=‘k’,y=‘k’,S=“ac”</span></span><br><span class="line">    Push(S,’t’); <span class="comment">//x=‘k’,y=‘k’,S=“tac”</span></span><br><span class="line">    Push(S,x); <span class="comment">//x=‘k’,y=‘k’,S=“ktac”</span></span><br><span class="line">    Pop(S,x); <span class="comment">//x=‘k’,y=‘k’ S=“tac”</span></span><br><span class="line">    Push(S,’s’); <span class="comment">//x=‘k’,y=‘k’ S=“stac”</span></span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(S))\</span><br><span class="line">    &#123;</span><br><span class="line">       Pop(S,y); <span class="comment">//依次为y=‘s’,y=‘t’,y=‘a’,y=‘c’</span></span><br><span class="line">       <span class="built_in">printf</span>(y); <span class="comment">//打印依次为s,t,a,c\n&#125;\nPrintf(x);//x=‘k’\n</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串数组广义表">30.串，数组，广义表</h2><ul><li>串是一种特殊的线性表，其特殊性体现在<code>数据元素是一个字符</code></li></ul><h2id="设串s1abcdefgs2pqrst函数conxy返回x和y串的连接串subssij返回串s的从序号i开始的j个字符组成的子串lens返回串s的长度则consubss12lens2subs1lens22的结果串是">31.设串s1='ABCDEFG',s2='PQRST',函数con(x,y)返回x和y串的连接串，subs(s,i,j)返回串s的从序号i开始的j个字符组成的子串，len(s)返回串s的长度，则con(subs(s1,2,len(s2)),sub(s1,len(s2),2)）的结果串是：</h2><ul class="task-list"><li><label><input type="checkbox" />BCDEF</label></li><li><label><input type="checkbox" />BCDEFG</label></li><li><label><input type="checkbox" />BCPQRST</label></li><li><label><input type="checkbox" checked="" />BCDEFEF</label></li></ul><h2id="若以1234作为双端队列的输入序列则既不能由输入受限的双端队列得到也不能由输出受限的双端队列得到的输出序列是">32.若以1234作为双端队列的输入序列，则既不能由输入受限的双端队列得到，也不能由输出受限的双端队列得到的输出序列是</h2><ul><li><p><label><input type="checkbox" />1234</label></p></li><li><p><label><input type="checkbox" />4321</label></p></li><li><p><label><input type="checkbox" checked="" />4231</label></p></li><li><p><label><input type="checkbox" />4213</label></p></li><li><p>输入受限的双端队列是两端都可以删除，只有一端可以插入的队列</p></li><li><p>输出受限的双端队列是两端都可以插入，只有一端可以删除的队列</p></li></ul><h2 id="按行列存储">33.按行列存储</h2><ul><li>一般情况当<code>行与列的上下界都相同时</code>，按行存储的A[ I , J]，与按列存储的A[ J , I ]地址相等</li><li></li></ul><h2id="编写算法删除顺序表前面的8个元素如果顺序表中的元素少于8个则删完为止">34.编写算法，删除顺序表前面的8个元素。如果顺序表中的元素少于8个则删完为止</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(sequentlist *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;data&lt;=<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;last=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s-&gt;last<span class="number">-8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data[i]=s-&gt;data[i+<span class="number">8</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;last-=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写算法输出一棵二叉树的第i层的所有节点的值假设根节点是第1层">35.编写算法，输出一棵二叉树的第i层的所有节点的值，假设根节点是第1层</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typefef <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linkNode</span> *<span class="title">lchild</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="type">void</span> <span class="title function_">outi</span><span class="params">(Node *tree,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree-&gt;data)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    outi(tree-&gt;lchild,i<span class="number">-1</span>);</span><br><span class="line">    outi(tree-&gt;rchild,i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写算法判断单链表的元素值是不是递增的">36.编写算法，判断单链表的元素值是不是递增的</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isviset</span><span class="params">(L)</span></span><br><span class="line">linklist *L;</span><br><span class="line">&#123;</span><br><span class="line">    linklist *p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;p-&gt;next-&gt;data)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="section">37.</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2
id=&quot;数据结构中与所使用的计算机无关的是数据的____结构&quot;&gt;1.数据结构中，与所使用的计算机无关的是数据的____结构&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;存储&lt;/lab</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>OJ题</title>
    <link href="https://pipi1002.github.io/2023/09/25/OJ/"/>
    <id>https://pipi1002.github.io/2023/09/25/OJ/</id>
    <published>2023-09-25T11:00:56.000Z</published>
    <updated>2024-02-27T13:08:24.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="oj题">OJ题</h1><p>1.IO型:自己写头文件，main函数等等</p><p>测试用例：我们要去scanf获取</p><p>结果：用printf输出</p><p>2.接口型（实现已知函数）：不需要写头文件，主函数，提交了以后，会跟oj服务器上他准备好的代码合并</p><p>测试用例：通过参数传过来</p><p>结果：一般通过返回值拿的，也有可能是输出性参数</p><h2id="一个整形数组nums里除两个数字以外其它数字都出现了2次请写程序找出这两个只出现一次的数据">一个整形数组nums里除两个数字以外，其它数字都出现了2次，请写程序找出这两个只出现一次的数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言不支持返回两个值</span></span><br><span class="line"><span class="comment">//例如输入：nums=[4,1,4,6]  输出：[1,6]或者[6,1]</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">singleNumbers</span><span class="params">(int8 nums,<span class="type">int</span> numsSize,<span class="type">int</span> * returnSize)</span><span class="comment">//这个returnSize就叫输出型参数</span></span><br><span class="line">&#123;</span><br><span class="line">    *returnSize=<span class="number">2</span>;<span class="comment">//把返回数组的大小给他</span></span><br><span class="line">    <span class="type">int</span>* arr=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="给你一个数组nums和一个值val你需要原地溢出所有数值相等于val的元素并返回移除后数组的新长度">给你一个数组nums和一个值val，你需要原地溢出所有数值相等于val的元素，并返回移除后数组的新长度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.遇到和val相同的数组元素时，将其后所有元素向前移一位覆盖，找到所有的val，依次挪动数据覆盖删除。时间复杂度为O(n^2)最坏的情况数组中大部分值甚至全部都是val[(n-1)+(n-2)+...]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.建立一个temp数组，把不是val的值放在temp数组中，再把temp数组的值拷贝回去O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.定义src和dst为数组下标，用src找不等于 val的值(等于val dst不动，src继续向后找)，放到dst指向的位置中去，再++src，++dst。因为是常数个数所以可以认为O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272105155.png" /></p><p><imgsrc="C:\Users\王锐蕊\Pictures\Screenshots\屏幕截图_20231015_221742.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072012353.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numSize,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> src=<span class="number">0</span>,dst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(src&lt;numSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[src]!=val)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[dst]=nums[src]; </span><br><span class="line">            src++;</span><br><span class="line">            dst++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="去重删除有序数组中的重复数字双指针的变形">去重，删除有序数组中的重复数字（双指针的变形）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入：nums=[1,1,2]</span></span><br><span class="line"><span class="comment">输出：2，nums=[1,2]</span></span><br><span class="line"><span class="comment">解释：函数应返回新长度2，并且原数组nums的前两个元素被修改为1，2。。不需要考虑数组中超出新长度后面的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> numsSize)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(numsSize==<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> dst=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(j&lt;numsSize)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>(nums[i]==nums[j])</span><br><span class="line">         &#123;</span><br><span class="line">             ++j;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             nums[dst]=nums[i];</span><br><span class="line">             ++dst;</span><br><span class="line">             i=j;</span><br><span class="line">             j++</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     nums[dst]=nums[i];</span><br><span class="line">     ++dst;</span><br><span class="line">     <span class="keyword">return</span> dst;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//下图为两种情况[0,0,1,1,1,2,2,3,3,4]和[0,0,1,1,2,2,3,3]</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013850.png" /></p><h2 id="合并两个有序数组归并排序">合并两个有序数组（归并排序）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有序数组：非递减数组</span></span><br><span class="line"><span class="comment">输入：nums1=[1，2，3，0，0，0]，m=3,nums2=</span></span><br><span class="line"><span class="comment">[2,5,6]</span></span><br><span class="line"><span class="comment">输出：[1,2,2,3,5,6]</span></span><br><span class="line"><span class="comment">注意：最终，合并后的数组不应由函数返回，而是存储在数组num1中，为了应对这种情况，num1的初始长度为m+n，其中前m个元素表示应合并的元素，后n给元素为0，应忽略num2的长度为n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1,<span class="type">int</span> nums1Size,<span class="type">int</span> m,<span class="type">int</span>* nums2,<span class="type">int</span> nums2Size,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> end1=m<span class="number">-1</span>,end2=n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> end=m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end1&gt;=<span class="number">0</span> &amp;&amp; end2&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[end1]&gt;nums2[end2])<span class="comment">//num1大就把nums1的数据放end所对应的数组元素上，nums2数据大就把nums2的数据放end所对应的数组元素上</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums1[end]=nums1[end1];</span><br><span class="line">            --end2;</span><br><span class="line">            --end1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            nums1[end]=nums2[end2];</span><br><span class="line">            --end2;</span><br><span class="line">            --end1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(end2&gt;=<span class="number">0</span>)<span class="comment">//不可能同时结束,当nums2先结束时（图1），不用做后续处理;另一种情况(合并[2,2,3,0,0,0]和[1,1,6])时是num1先结束就要把nums2的剩余数据赋值给nums1</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums1[end]=nums[end2];</span><br><span class="line">        --end2;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013766.png" /></p><p><code>图2</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013093.png" /></p><p><code>此题是从后往前放数据从大到小开始放;而归并排序是从小到大比较从前往后放，并且归并排序是生成一个新数组存放排过序的元素</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="comment">//给两个指针分别指向两个数组的起始元素进行比较，小的放入第三个数组，并且这个数对应的指针++,再继续比较两个指针所指向的元素大小，把小元素的继续放在第三个数组中，再++它所对应的指针</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013713.png" /></p><h2id="移除链表元素给你一个链表的头节点head和一个整数val请你删除链表中所有满足node.valval的节点并返回新的头节点">移除链表元素（给你一个链表的头节点head和一个整数val，请你删除链表中所有满足Node.val==val的节点，并返回新的头节点）</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013898.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeElement</span><span class="params">(<span class="keyword">struct</span> ListNode* head,<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Listnode</span>* <span class="title">prev</span>=</span><span class="literal">NULL</span>,*cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当第一个都需要删除(头删)的时候就会报错例如[7，7，7，7]  7</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val==val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//头删</span></span><br><span class="line">            <span class="keyword">if</span>(cur==head)</span><br><span class="line">            &#123;</span><br><span class="line">                head=cur-&gt;next;<span class="comment">//head指向下一个节点</span></span><br><span class="line">                <span class="built_in">free</span>(cur);<span class="comment">//删除第一个节点</span></span><br><span class="line">                cur=head;<span class="comment">//删除完的第一个就是当前head指向的节点，再给cur</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//中间删除</span></span><br><span class="line">                prev-&gt;next=cur-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(cur);</span><br><span class="line">            </span><br><span class="line">                cur=prev-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//迭代往后走</span></span><br><span class="line">            prev=cur;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="翻转链表">翻转链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span><br><span class="line">    <span class="comment">//n1,n2用来翻转n3用来记录下一个节点，方便迭代的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果链表为空就不需要翻转</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">n1</span>,<span class="title">n2</span>,<span class="title">n3</span>;</span></span><br><span class="line">    n1=<span class="literal">NULL</span>;</span><br><span class="line">    n2=head;</span><br><span class="line">    n3=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(n2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//翻转</span></span><br><span class="line">        n2-&gt;next=n1;</span><br><span class="line">        <span class="comment">//迭代往后走</span></span><br><span class="line">        n1=n2;</span><br><span class="line">        n2=n3;</span><br><span class="line">        <span class="comment">//当n2为空时n3没有办法指向下一个节点因为之前n3已经为空</span></span><br><span class="line">        <span class="keyword">if</span>(n3!=<span class="literal">NULL</span>)</span><br><span class="line">            n3=n3-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013051.png" /></p><h6id="上图为基本翻转逻辑下图为for循环结束条件图示">上图为基本翻转逻辑，下图为for循环结束条件图示</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013940.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种算法:取原链表中节点，头插到newhead新链表中</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">cur</span>=</span>head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newhead</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>=</span>cur-&gt;next; </span><br><span class="line">        <span class="comment">//头插</span></span><br><span class="line">        cur-&gt;next=newhead;</span><br><span class="line">        newhead=cur;</span><br><span class="line">        <span class="comment">//迭代往后走</span></span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013581.png" /></p><h2id="返回链表的中间节点如果有两个中间节点则返回第二个中间节点-要求只能遍历链表一次">返回链表的中间节点(如果有两个中间节点则返回第二个中间节点)要求:只能遍历链表一次</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针问题:定义两个指针一个快指针fast一个慢指针slow，fast每次走两步，slow每次走一步，如果是奇数个数字fast走到最后一个数字的后一个指向空此时slow为第二个中间节点；如果是偶数给数字fast走到最后一个时slow正好走到中间节点</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span>,*<span class="title">fast</span>;</span></span><br><span class="line">    slow=fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)<span class="comment">//当发射台走到最后或者走到NULL时停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        slowslow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变形：求链表倒数第K个节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.先让fast走k步；slow和fast再一起走，fast==NULL时，slow为倒数第k个节点</span></span><br><span class="line"><span class="comment">2.先让fast走k-1步，slow和fast再一起走，fast-&gt;==NULL时，slow为倒数第k个节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">FindKthToTail</span><span class="params">(<span class="keyword">struct</span> ListNode* plistHead,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span>,*<span class="title">slow</span>;</span></span><br><span class="line">    slow=fast=plistHead;</span><br><span class="line">    <span class="keyword">while</span>(k--)<span class="comment">//循环k次</span></span><br><span class="line">    <span class="comment">//while(--k)//循环k-1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">        <span class="comment">//k大于链表的长度 当&#123;1,2,3,4,3,2&#125;，k=30时</span></span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            retuen <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013585.png" /></p><h6 id="上图为变形前的示意图">上图为变形前的示意图</h6><h2 id="合并两个有序列表">合并两个有序列表</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013210.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用返回值的方式就不需要用二级指针</span></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">mergeTwoLists</span><span class="params">(<span class="keyword">struct</span> ListNode* l1,<span class="keyword">struct</span> ListNode* l2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当其中一个链表为空，就返回另一个链表</span></span><br><span class="line"><span class="keyword">if</span>(l1==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line"><span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span>=</span><span class="literal">NULL</span>,*tail=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(li-&gt;val&lt;l2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=tail=l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next=l1;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l1=l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=tail=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next=l2;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l2=l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当某一个链表结束的时候把另外一个链接，由于不知道哪一个先结束于是用两个if语句</span></span><br><span class="line">    <span class="keyword">if</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next=l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next=l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;<span class="comment">//fan&#x27;hui</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(l1==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line"><span class="keyword">if</span>(l2==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span>=</span><span class="literal">NULL</span>,*tail=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//哨兵位的头节点</span></span><br><span class="line">head=tail=(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line"><span class="keyword">while</span>(l1&amp;&amp;l2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(li-&gt;val&lt;l2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next=l1;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">        l1=l1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next=l2;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">        l2=l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(l1)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next=l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2)</span><br><span class="line">    &#123;</span><br><span class="line">        tail-&gt;next=l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能直接返回哨兵位的头，要释放哨兵位的头，返回哨兵位的next</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">list</span>=</span>head-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(head);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2id="链表的分割现在有一链表的头指针listnode-phead给一定值x编写一段代码将所有小于x的节点排在其余节点之前且不能改变原来的数据顺序返回重新排列后的链表的头指针">链表的分割(现在有一链表的头指针ListNode*pHead,给一定值x，编写一段代码将所有小于x的节点排在其余节点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg:2  3  5  1  7  2    x=4</span></span><br><span class="line"><span class="comment">//结果:2 3 1 2 5 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//新定义两个链表，把比x小的放尾插在第一个链表中，把大于x的尾插在第二个链表中再把这两个链表链接</span></span><br><span class="line">ListNode* <span class="title function_">partition</span><span class="params">(ListNode* pHead,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">lessHead</span>,*<span class="title">lessTail</span>,*<span class="title">greaterHead</span>,*<span class="title">greaterTail</span>;</span></span><br><span class="line">    <span class="comment">//开一个哨兵位，方便尾插</span></span><br><span class="line">    lessHead=lessTail=(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(strcut ListNode*));</span><br><span class="line">    lessTail-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    greaterHead=lessTail=(<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(strcut ListNode*));</span><br><span class="line">    greaterTail-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span>=</span>pHead;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val&lt;x)</span><br><span class="line">        &#123;</span><br><span class="line">            lessTail-&gt;next=cur;</span><br><span class="line">            lessTail=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            greaterTail-&gt;next=cur;</span><br><span class="line">            greaterTail=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链接两个链表less和greater</span></span><br><span class="line">    lessTail-&gt;next=greaterHead-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//防止无限循环</span></span><br><span class="line">    greater-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//free两个哨兵节点，但是free之后就无法返回新链表(less和greater连接过后的链表)的头节点，所以需要提前记录lessHead的下一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span>=</span>lessHead-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(lessHead);</span><br><span class="line">    <span class="built_in">free</span>(greaterHead);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="图一初始步骤">图一：初始步骤</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072013202.png" /></p><h6 id="图二逻辑步骤">图二：逻辑步骤</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272108897.png" /></p><h6 id="图三逻辑结束">图三：逻辑结束</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014244.png" /></p><h6 id="报错原因"><code>报错原因：</code></h6><p>15本来指向4，现在4又指向12，无限循环，内存会超</p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014917.png" /></p><h2 id="链表的回文结构">链表的回文结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构，给定一个链表的头指针A，请返回一个bool值，代表其是否为回文结构，保证链表长度小于等于900</span></span><br><span class="line"><span class="comment">//例如：1-&gt;2-&gt;2-&gt;1  返回:true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法:把后半部分逆置(翻转)，然后用前半部分和后半部分进行比较(不用把前后两部分断开)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">mid</span>=</span>middleNode(A);<span class="comment">//之前题目的代码，找到中间节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">rHead</span>=</span>reverseList(mid);<span class="comment">//之前题目的代码，翻转链表从mid开始</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curA</span>=</span>A;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curR</span>=</span>rHead;</span><br><span class="line">    <span class="keyword">while</span>(curA &amp;&amp; curR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(curA-&gt;val!=curR-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            curA=curA-&gt;next;</span><br><span class="line">            curR=curR-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014562.png" /></p><h6id="不用断开原因本来中间的2就指向末尾的3奇数情况本来中间的2就指向末尾的1偶数情况">不用断开原因本来中间的2就指向末尾的3(奇数情况)，本来中间的2就指向末尾的1(偶数情况)</h6><h2id="链表相交一个节点只有一个next只能聚合不能分散">链表相交(一个节点只有一个next，只能聚合不能分散)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.判断两个链表是否相交  2.如果相交，求交点</span></span><br><span class="line"><span class="comment">//方法1: 依次取A链表中的每个节点跟B链表中的所有节点比较，如果有地址相同的节点，就是相交，第一个相同的就是交点    方法2: 尾节点相同就相交，否则就不相交 求焦点:长的链表先走长度差，再同时走，第一个相同就是焦点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2实现如下：</span></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">getIntersectionNode</span><span class="params">(<span class="keyword">struct</span> ListNode *headB)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tailA</span>=</span>headA;<span class="comment">//不用headA去迭代的原因是不方便找头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tailB</span>=</span>headB;</span><br><span class="line">    <span class="type">int</span> lenA=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tailA-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ++lenA;<span class="comment">//算出A链表的长度</span></span><br><span class="line">        tailA=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> lenB=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tailB-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        ++lenB;<span class="comment">//算出B链表的长度</span></span><br><span class="line">        tailB=tailB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不相交</span></span><br><span class="line">    <span class="keyword">if</span>(tailA!=tailB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> gap=<span class="built_in">abs</span>(lenA-lenB);<span class="comment">//两个链表的差距gab,abs是绝对值的意思</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">longList</span>=</span>headA;<span class="comment">//假设A长B短</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">shortList</span>=</span>headB;</span><br><span class="line">    <span class="keyword">if</span>(lenA&lt;lenB)</span><br><span class="line">    &#123;</span><br><span class="line">        shortList=headA;</span><br><span class="line">        longList=headB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//长的先走gap步</span></span><br><span class="line">    <span class="keyword">while</span>(gap--)</span><br><span class="line">    &#123;</span><br><span class="line">         longList=longList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(longList!=shortList)</span><br><span class="line">    &#123;</span><br><span class="line">        longList=Longlist-&gt;next;</span><br><span class="line">        shortList=shortList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    retuen longList; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环形链表">环形链表</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014892.png" /></p><h6 id="带环的三种情况">带环的三种情况</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.是否带环  2.找出带环链表的入口节点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">slow和fast指向链表的开始，slow一次走一步，fast一次走两步，不带环fast就会走向空，带环，fast就会在环里追上slow(zhui&#x27;ji)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> ListNode *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span>=</span>head,*fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="comment">//一个指针从相遇点开始走，一个指针从链表头开始走，它们会在环的入口点相遇</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">追上相遇的过程中，慢指针走的距离:L+X;快指针走到距离:L+n*X+C(C为环的长度，n是他们相遇之前，fast在环里面走的圈数，n&gt;=1)</span></span><br><span class="line"><span class="comment">在相遇时，慢指针不可能走在环内超过一圈，因为此时快指针已经走两圈了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">快指针走的路程是慢指针的二倍</span></span><br><span class="line"><span class="comment">2(L+X)=L+n*C+X</span></span><br><span class="line"><span class="comment">L+X=n*C</span></span><br><span class="line"><span class="comment">L=n*C-X</span></span><br><span class="line"><span class="comment">L=(n-1)*C+C-X</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">(n-1)*C指的是整数倍圈，相当于从meetNode又走到meetNode</span></span><br><span class="line"><span class="comment">C-X指的是从meetNode走到环入口点</span></span><br><span class="line"><span class="comment">所以 L=(n-1)*C+C-X 指的是一个指针从相遇点开始走，一个指针从链表头开始走，它们会在环的入口点相遇</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">detectCycle</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span>=</span>head,*fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相遇</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">meet</span>=</span>slow;</span><br><span class="line">            <span class="comment">//一个指针从相遇点开始走，一个指针从链表头开始走，它们会在环的入口点相遇     公式证明，看上面讲解</span></span><br><span class="line">            <span class="keyword">while</span>(meet!=head)</span><br><span class="line">            &#123;</span><br><span class="line">                meet=meet-&gt;next;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> meet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="延伸问题">延伸问题：</h6><h6id="为什么slow和fast一定会在环中相遇会不会在环里面错过永远遇不上-不会">1.为什么slow和fast一定会在环中相遇？会不会在环里面错过，永远遇不上？不会</h6><ul><li>第一步：slow和fast，fast一定先进环，这时slow走了入环前距离的一半</li><li>第二步：随着slow进环，fast已经在环里面走了一段，走了多少跟环的大小有关，假设slow进环的时候，slow跟fast的距离是N，fast开始追slow，slow每往前走一步，fast每次往前走两步，每追一次fast和slow的距离变化为N,N-1,N-2,N-3,......,1,0 所以会相遇</li></ul><h6id="为什么slow走一步fast走两步fast能不能一次走345...n-结论不一定会相遇">2.为什么slow走一步，fast走两步？fast能不能一次走3，4，5...n？结论：不一定会相遇</h6><ul><li>以fast走三步为例子<ul><li>N为偶数，每追一次fast和slow的距离变化为N,N-1,N-2,N-3,......,1,0可以追上</li><li>N为奇数 ，每追一次fast和slow的距离变化为N，N-2,N-4,N-6,......,1,-1这一次追不上。距离变成-1意味着他们之间的距离变成C-1(C是环的长度)<ul><li>如果C-1是奇数，那么就永远追不上了，陷入死循环</li><li>如果C-1是偶数，那么就可以追上</li></ul></li></ul></li></ul><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014088.png" /></p><h6 id="图一解决第一问">图一解决第一问</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014570.png" /></p><h6 id="图二解决第二问">图二解决第二问</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072014377.png" /></p><h6id="图三是第二个问题的第二种方法转换为链表相交问题相遇点下一个点为第二个链表的头节点把相遇点滞空">图三是第二个问题的第二种方法，转换为链表相交问题（相遇点下一个点为第二个链表的头节点，把相遇点滞空）</h6><h2id="复制带随机指针的链表复杂链表的复制">复制带随机指针的链表（复杂链表的复制）</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072016034.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给你一个长度为n的链表，每个节点包含一个额外增加的随机指针random，该指针可以指向链表中的任何节点或空节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">copyRandomList</span><span class="params">(<span class="keyword">struct</span> Node* head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.拷贝节点插入原节点后面</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">cur</span>=</span>head;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">copy</span>=</span>(<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        copy-&gt;val=cur-&gt;val;</span><br><span class="line">        <span class="comment">//插入copy节点</span></span><br><span class="line">        copy-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=copy;</span><br><span class="line">        </span><br><span class="line">        cur=copy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.根据原节点处理copy节点的random节点</span></span><br><span class="line">    cur=head;<span class="comment">//重新让cur指向头节点开始迭代</span></span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">copy</span>=</span>cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;random==<span class="literal">NULL</span>)<span class="comment">//如果被copy的指针的random指向空</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy-&gt;random=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copy-&gt;random=cur-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=copy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.复制节点解下来链接成一个新链表，恢复原链表链接关系</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">copyHead</span>=</span><span class="literal">NULL</span>,*copyTail;</span><br><span class="line">    cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">copy</span>=</span>cur-&gt;next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>=</span>copy-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(copyTail==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            copyHead=copyTail=copy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            copyTail-&gt;next=copy;</span><br><span class="line">            copyTail=copy;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next=next;</span><br><span class="line">        </span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311072017852.png" /></p><h6id="复制节点解下来链接成一个新链表恢复原链表链接关系">3.复制节点解下来链接成一个新链表，恢复原链表链接关系</h6><h2id="有效的括号-给定一个只包括-的字符串s判断是否有效-1.左括号必须和相同类型的右括号闭合2.左括号必须以正确的顺序闭合">有效的括号给定一个只包括‘（’ ，‘）’ ，‘[’ ,']' ,'{' ，‘}’的字符串s，判断是否有效1.左括号必须和相同类型的右括号闭合2.左括号必须以正确的顺序闭合</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左括号入栈,右括号取栈顶元素(括号)和这个右括号比较</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    ST st;</span><br><span class="line">    StackInit(&amp;st);</span><br><span class="line">    <span class="keyword">while</span>(*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*s==<span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            || (*s==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            || (*s==<span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            StackPush(&amp;st,*s);<span class="comment">//左括号入栈</span></span><br><span class="line">            ++s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果此时指针s指向右括号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遇到右括号了但栈里面没有数据，说明前面没有左括号，不匹配返回false    [[]]]或者]</span></span><br><span class="line">            <span class="keyword">if</span>(StackEmpty(&amp;st))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            STDataType top=StackTop(&amp;st);<span class="comment">//把栈顶数据复制给变量top</span></span><br><span class="line">            StackPop(&amp;st);<span class="comment">//删除栈顶数据，让可以被右括号匹配的左括号依次出栈</span></span><br><span class="line">            <span class="keyword">if</span>(*s==<span class="string">&#x27;)&#x27;</span>&amp;&amp;top！=<span class="string">&#x27;(&#x27;</span> || *s==<span class="string">&#x27;]&#x27;</span>&amp;&amp;top！=<span class="string">&#x27;[&#x27;</span> || *s==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;top！=<span class="string">&#x27;&#123;&#x27;</span>)<span class="comment">//不匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                StackDestory(&amp;st);<span class="comment">//注意释放空间</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果栈不是空，说明栈中还有左括号未出</span></span><br><span class="line">    <span class="comment">//没有匹配返回的是false</span></span><br><span class="line">    <span class="type">bool</span> ret=StackEmpt(&amp;st);</span><br><span class="line">    </span><br><span class="line">    StackDestory(&amp;st);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="请你仅使用两个队列实现一个后入先出的栈并支持普通栈的全部四种操作不能改变队列的结构只能去调用队列提供的接口去实现">请你仅使用两个队列实现一个后入先出的栈，并支持普通栈的全部四种操作(不能改变队列的结构只能去调用队列提供的接口去实现)</h2><ul><li>void push(int x)将元素x压入栈顶</li><li>int pop( )移除并返回栈顶元素</li><li>int top( )返回栈顶元素</li><li>boolean empty( )如果栈是空的，返回true；否则返回false</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//入数据，往不为空的队列入，保持另一个队列为空;出数据，依次出队头的数据，转移到另一个队列保存，只剩最后一个时，pop掉</span></span><br><span class="line">MyStack* <span class="title function_">myStackCreate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    MyStack* st=(Mystack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyStack));</span><br><span class="line">    QueueInit(&amp;st-&gt;q1);<span class="comment">//初始化第一个队列</span></span><br><span class="line">    QueueInit(&amp;st-&gt;q2);</span><br><span class="line">    <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哪个队列不为空就往这个队列入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myStackPush</span><span class="params">(MyStack* obj,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!QueueEmpty(&amp;obj-&gt;q1))</span><br><span class="line">    &#123;</span><br><span class="line">        QueuePush(&amp;obj-&gt;q1,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueuePush(&amp;obj-&gt;q2,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MyStackPop</span><span class="params">(MyStack* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue* emptyQ=&amp;obj-&gt;q1;</span><br><span class="line">    Queue* noneemptyQ=&amp;obj-&gt;q2;</span><br><span class="line">    <span class="keyword">if</span>(!QueueEmpty(&amp;obj-&gt;q2))</span><br><span class="line">    &#123;</span><br><span class="line">        emptyQ=&amp;obj-&gt;q1;</span><br><span class="line">        noneemptyQ=&amp;obj-&gt;q2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非空队列的数据导入空队列直到还剩一个</span></span><br><span class="line">    <span class="keyword">while</span>(QueueSize(noneemptyQ)&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把队头的数据依次添加到队列2(这时队列1中还有数据)，并且把队列1的数据删除。QueueFront找队头数据，QueuePush导数据</span></span><br><span class="line">        QueuePush(emptyQ,QueueFront(noneempty(Q)));</span><br><span class="line">        QueuePop(noneemptyQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存最后一个数据</span></span><br><span class="line">    <span class="type">int</span> top=QueueFront(noneemptyQ);</span><br><span class="line">    <span class="comment">//删除队1最后一个数据</span></span><br><span class="line">    QueuePop(noneemptyQ);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不仅可以取队头也可以取队尾，就是只能删队头不能删队尾</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">MyStackTop</span><span class="params">(Mystack* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!QueueEmpty(&amp;obj-&gt;q1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBack(&amp;obj-&gt;q2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBack(&amp;obj-&gt;q2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">myStackEmpty</span><span class="params">(MyStack* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//队列q1和q2都不为空</span></span><br><span class="line">    <span class="keyword">return</span> QueueEmpty(&amp;obj-&gt;q1)&amp;&amp; QueueEmpty(&amp;obj-&gt;q2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myStackFree</span><span class="params">(MyStack* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//分成两步一步链表删除，一步shan&#x27;ch</span></span><br><span class="line">    QueueDestory(&amp;obj-&gt;q1);</span><br><span class="line">    QueueDestory(&amp;obj-&gt;q2);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311141924966.png"alt="屏幕截图_20231113_181402" /><figcaption aria-hidden="true">屏幕截图_20231113_181402</figcaption></figure><h2 id="用栈实现队列">用栈实现队列</h2><ul><li>void push(int x)将元素x推到队的队尾</li><li>int pop( )从队列的开头移除并返回元素</li><li>int peak( )返回队列开头的元素</li><li>boolean empty( )如果队列为空，返回true，否则false</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出数据：把栈1的数据放到栈2，再由栈2出（栈2有数据就直接出，没数据就让栈1导入）    入数据：直接在栈1入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myQueuePush</span><span class="params">(MyQueue* obj,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    StackPush(&amp;obj-&gt;pushST,x)<span class="comment">//pushST指的是出数据的栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myQueuePop</span><span class="params">(MyQueue* obj)</span></span><br><span class="line">    <span class="comment">//如果popST中没有数据，将pushST的数据导过去</span></span><br><span class="line">    <span class="comment">//popST中的数据就符合先进先出的顺序了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(&amp;obj-&gt;popST))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!StackEmpty(&amp;obj-&gt;push))</span><br><span class="line">        &#123;</span><br><span class="line">            StackPush(&amp;obj-&gt;popST,StackTop(&amp;obj-&gt;pushST));</span><br><span class="line">            StackPop(&amp;obj-&gt;pushST);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> front=StackTop(&amp;obj-&gt;popST);</span><br><span class="line">    StackPop(&amp;obj-&gt;popST);</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myQueuePeek</span><span class="params">(MyQueue* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果popST中没有数据，将pushST的数据导过去</span></span><br><span class="line">    <span class="comment">//popST中的数据就符合先进先出的顺序了</span></span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(&amp;obj-&gt;popST))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!StackEmpty(&amp;obj-&gt;push))</span><br><span class="line">        &#123;</span><br><span class="line">            StackPush(&amp;obj-&gt;popST,StackTop(&amp;obj-&gt;pushST));</span><br><span class="line">            StackPop(&amp;obj-&gt;pushST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Peek和Pop的区别是不需要删只需要找队头数据</span></span><br><span class="line">    <span class="keyword">return</span> StackTop(&amp;obj-&gt;popST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">myQueueEmpty</span><span class="params">(MyQueue* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//两个栈都为空才为空</span></span><br><span class="line">    <span class="keyword">return</span> StackEmpty(&amp;obj-&gt;pushST) &amp;&amp; StackEmpty(&amp;obj-&gt;popST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311141911653.png" /></p><h6id="上图为逻辑图下图为结构图obj和两个栈popst和pushst的关系">上图为逻辑图，下图为结构图（obj和两个栈，popST和pushST的关系）</h6><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311141924199.png"alt="屏幕截图_20231114_192143" /><figcaption aria-hidden="true">屏幕截图_20231114_192143</figcaption></figure><h2 id="循环队列">循环队列</h2><ul><li>MyCircleQueue(k)：构造器，设置队列长度为k</li><li>Front:从对首取元素，如果队列为空，返回-1</li><li>Rear:获取队尾元素，如果队列为空，返回-1</li><li>enQueue(value):向循环队列插入一个元素，如果成功插入返回true</li><li>deQueue( ):从循环队列中删除一个元素，如果成功返回真</li><li>isEmpty( ):检查循环队列是否为空</li><li>isFull( ):检查队列是否已满</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  符合先进先出，队列空间大小是固定的，出数据也不删除节点</span></span><br><span class="line"><span class="comment">  tail和front这两个指针指向同一节点则队列为空</span></span><br><span class="line"><span class="comment">  在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间，但是使用循环队列，我们可以用这些空间去存储新的值</span></span><br><span class="line"><span class="comment">  删除节点front向前移动，插入节点tail向前移动</span></span><br><span class="line"><span class="comment">  循环队列可以用数组实现也可以用循环链表实现。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> tail;</span><br><span class="line">    <span class="type">int</span> k;<span class="comment">//k指存的数据个数，k+1指空间大小</span></span><br><span class="line">&#125;MyCircularQueue;</span><br><span class="line"></span><br><span class="line">MyCircularQueue* <span class="title function_">myCircularQueueCreate</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyCircularQueue* cq=(MyCircularQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyCircularQueue));</span><br><span class="line">    cq-&gt;a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(k+<span class="number">1</span>));</span><br><span class="line">    cq-&gt;front=cq-&gt;tail=<span class="number">0</span>;</span><br><span class="line">    cq-&gt;k=k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MyCircularQueueIsEmpty</span><span class="params">(CircularQueue* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;front==obj-&gt;tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MyCircularQueueIsFull</span><span class="params">(CircularQueue* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj-&gt;tail+<span class="number">1</span>)%(obj-&gt;k+<span class="number">1</span>)==obj-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入数据</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MyCircularQueueEnQueue</span><span class="params">(CircularQueue* obj,<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(MyCircularQueueIsFull(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//一定注意超出数组空间就将循环</span></span><br><span class="line">    obj-&gt;a[obj-&gt;tail]=value;</span><br><span class="line">    ++obj-&gt;tail;</span><br><span class="line">    obj-&gt;tail %= (k+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出数据</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">MyCircularQueueDeQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(MyCircularQueueIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ++obj-&gt;front;</span><br><span class="line">    obj-&gt;front %= (k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MyCircularQueueFront</span><span class="params">(MyCircularQueue* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(myCircularQueueIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj-&gt;a[onj-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MyCircularQueueRear</span><span class="params">(MyCircularQueue* obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(myCircularQueueIsEmpty(obj))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj-&gt;tail == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;a[k];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a[obj-&gt;tail<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>重点：</code>循环队列，无论使用数组实现还是循环链表实现，都要多开一个空间，也就意味着要是一个存k个数据的循环队列，要开k+1个空间，否则无法实现判空和判满，避开空和满是相同的情况</p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272107435.png" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;oj题&quot;&gt;OJ题&lt;/h1&gt;
&lt;p&gt;1.IO型:自己写头文件，main函数等等&lt;/p&gt;
&lt;p&gt;测试用例：我们要去scanf获取&lt;/p&gt;
&lt;p&gt;结果：用printf输出&lt;/p&gt;
&lt;p&gt;2.接口型（实现已知函数）：不需要写头文件，主函数，提交了以后，会跟oj服务</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>DataStructure</title>
    <link href="https://pipi1002.github.io/2023/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://pipi1002.github.io/2023/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-09-25T11:00:56.000Z</published>
    <updated>2023-12-11T11:06:00.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1><h2id="时间复杂度时间复杂度及空间复杂度">时间复杂度（时间复杂度及空间复杂度）</h2><h6id="摩尔定律每18个月运行内存都会更新空间复杂度不再特变关注">摩尔定律（每18个月运行内存都会更新，空间复杂度不再特变关注）</h6><ul><li>用常数1取代运行时间中所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算时间复杂度</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n-i;j++)  <span class="comment">//i=1时内循环执行n-1次;i=2时执行n-2次...;i=n-1时执行1次</span></span><br><span class="line">        x++;</span><br><span class="line"><span class="comment">//因为x++共执行了n-1+n-2+...+1=n(n-1)/2,所以执行时间为O(n^2)</span></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    i=i*<span class="number">3</span>;</span><br><span class="line"><span class="comment">//O(log3^n)</span></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Func4</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">00</span>;k&lt;<span class="number">100</span>;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(1)时间复杂度是只能运行常数次，不代表算法运行一次</span></span><br><span class="line"><span class="comment">//4.计算strchar的时间复杂度</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str ,<span class="type">int</span> character)</span></span><br><span class="line"><span class="comment">//strchar指的是在字符串中查找一个字符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hellow world</span></span><br><span class="line"><span class="comment">假设查找的是h  最好情况:任意输入规模最小运行次数</span></span><br><span class="line"><span class="comment">假设查找的是w  平均情况:任意输入规模期望运行次数</span></span><br><span class="line"><span class="comment">假设查找的是d  最坏情况:任意输入规模最大运行次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">while</span><span class="params">(*str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str==character)</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ++str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="comment">//当一个算法随着输入不同，时间复杂度不同，时间复杂度做悲观预期，看最坏情况</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算冒泡排序的时间复杂度 同上1.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> end=n;end&gt;<span class="number">0</span>;--end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> exchange=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">1</span>;i&lt;end;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(&amp;a[i<span class="number">-1</span>],&amp;a[i]);</span><br><span class="line">                exchange=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(exchange==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//n-1+n-2+...+1=n*(n-1)/2则时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">//看算法复杂度不能只看是几层循环</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BnarySearch</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(a);</span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end=n;</span><br><span class="line">    <span class="keyword">while</span>(begin&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=begin+((end-begin)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;x)</span><br><span class="line">            begin=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;x)</span><br><span class="line">            end=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度为log2^N;</span></span><br><span class="line"><span class="comment">//最好情况O(1);</span></span><br><span class="line"><span class="comment">//最坏情况O(log2^N);找不到的情况</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">假设找了x次，元素一共有N个</span></span><br><span class="line"><span class="comment">1*2*2*2……=N</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契算法的时间复杂度</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">Fib</span><span class="params">(<span class="type">size_t</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fib(N<span class="number">-1</span>)+Fib(N<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归算法时间复杂度:递归次数*每次递归调用的次数，在这里每次递归调用的次数为常数1</span></span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091921721.png" /></p><h3 id="消失的数字">消失的数字</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数，要求时间复杂度在O(n)内</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先给一个值x=0</span></span><br><span class="line"><span class="comment">x先跟[0,n]的所有值异或</span></span><br><span class="line"><span class="comment">x再跟数组中每个值异或</span></span><br><span class="line"><span class="comment">最后x就是缺的那个数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">异或:(先转化为2进制数)相同返回0，不同返回1,0和任何数字异或都为其本身,两个相同的数异或为0;异或满足交换律和结合律</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>* nums,intt numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//跟[0,n]异或</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=numsSize;++i)<span class="comment">//注意这里是&lt;=</span></span><br><span class="line">    &#123;</span><br><span class="line">        x^=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再跟数组中值异或</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x^=num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或问题的拓展</span></span><br><span class="line"><span class="comment">//找出一个数组中出现一次的数(其它数出现了2次)</span></span><br><span class="line"><span class="type">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    x=x^arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出数组当中出现两次的数</span></span><br><span class="line"><span class="type">int</span> []arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;<span class="comment">//x^x^y=y</span></span><br><span class="line"><span class="comment">//(A^B^C^B)^(A^B^C)=(A^C)^(A^B^C)=B</span></span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    x=x^arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    x=x^i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure><h3 id="旋转数组">旋转数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数  O(1)  相当于是旋转k次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">旋转数组的方法:</span></span><br><span class="line"><span class="comment">输入:nums=[1,2,3,4,5,6,7],k=3</span></span><br><span class="line"><span class="comment">输出:[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="comment">解释:</span></span><br><span class="line"><span class="comment">向右旋转1步:[7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">向右旋转2步:[6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="comment">向右旋转3步:[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入:num=[1,2,3,4,5,6,7],k=3</span></span><br><span class="line"><span class="comment">输出:num=[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="comment">方法:</span></span><br><span class="line"><span class="comment">( 4 3 2 1 ) 5 6 7   前n-k个逆置</span></span><br><span class="line"><span class="comment">4 3 2 1 ( 7 6 5 )   再后k个逆置</span></span><br><span class="line"><span class="comment">( 5 6 7 1 2 3 4 )   整体逆置</span></span><br><span class="line"><span class="comment">时间复杂度O(N) 空间复杂度O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(<span class="type">int</span>* nums,<span class="type">int</span> left,<span class="type">int</span> right)</span><span class="comment">//逆置算法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp=num[left];</span><br><span class="line">        num[left]=num[right];</span><br><span class="line">        num[right]=temp;</span><br><span class="line">        ++left;</span><br><span class="line">        --right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* num,<span class="type">int</span> numsSize,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=numsSize)</span><br><span class="line">        k%=numsSize;</span><br><span class="line">    <span class="comment">//前n-k个数逆置</span></span><br><span class="line">    Reverse(nums,<span class="number">0</span>,numsSize-k<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//后k个逆置</span></span><br><span class="line">    Reverse(num,numsSize-k,numsSize<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//整体逆置</span></span><br><span class="line">    Reverse(nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当k==n时，相当于不旋转</span></span><br><span class="line"><span class="comment">当k&gt;n时，相当于旋转k%n次</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="顺序表">顺序表</h2><h6id="本质就是数组但是存储的数据不能跳跃要连续">本质就是数组，但是存储的数据不能跳跃要连续</h6><h6 id="缺陷">缺陷：</h6><p>1.空间不够了需要增容，需要付出代价</p><p>2.为避免频繁扩容，我们基本都是扩2倍，空间浪费</p><p>3.顺序表要求数据从开始位置连续存储，那么我们在头部或者中间位置插入删除数据就需要挪动数据</p><p>realloc扩容有两种方式</p><ul><li>原地扩容，后面如果有足够大的内存空间，返回原空间地址，代价小</li><li>异地扩容，如果后面没有足够大的内存空间，会找一块足够大的空间，将原空间内容拷贝过来并释放原空间，返回的是新空间地址，代价大</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SeqList.h</span></span><br><span class="line"><span class="meta">#prama once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> SLDataTpye;</span><br><span class="line"><span class="comment">//动态顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SLDataType* a;</span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//表示数组中存储了多少个数据</span></span><br><span class="line">    <span class="type">int</span> capasity;<span class="comment">//数组实际能存储数据的空间容量是多大</span></span><br><span class="line">&#125;SL;</span><br><span class="line"><span class="comment">//接口函数--命名风格是跟着STL走的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInit</span><span class="params">(SL* ps)</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushBack</span><span class="params">(SL* ps,SLDataType x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopBack</span><span class="params">(SL* ps)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushFront</span><span class="params">(SL* ps,SLDataType x)</span>;<span class="comment">//前插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListCheckCapacity</span><span class="params">(SL* ps)</span>;<span class="comment">//检查是否需要增容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopFront</span><span class="params">(SL* ps)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SeqList.c</span></span><br><span class="line"><span class="comment">//顺序表初始化相当于尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInit</span><span class="params">(SL* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    ps.a=<span class="literal">NULL</span>;</span><br><span class="line">    ps.size=ps.capacity=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查是否需要增容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListCheckCapacity</span><span class="params">(SL* ps)</span>;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//如果没有空间或者空间不足，那么我们就扩容</span></span><br><span class="line">    <span class="keyword">if</span>(ps-&gt;size==ps-&gt;capasity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> capasity=ps-&gt;capasity==<span class="number">0</span>? <span class="number">4</span>:ps-&gt;capasity;</span><br><span class="line">        SLDataType* tmp=(SLDataType*)<span class="built_in">realloc</span>(ps-&gt;a,newcapacity*<span class="keyword">sizeof</span>(SLDataType));</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>) <span class="comment">//如果没有扩容成功，直接退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;realloc fail\n&quot;</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ps-&gt;a=tmp;</span><br><span class="line">        ps-&gt;capacity=newcapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushBack</span><span class="params">(SL* ps,SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqListCheckCapacity(ps);<span class="comment">//检查增容</span></span><br><span class="line">    ps-&gt;a[ps-&gt;size]=x;</span><br><span class="line">    ps-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushBack</span><span class="params">(SL* ps,SLDataType x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopBack</span><span class="params">(SL* ps)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushFront</span><span class="params">(SL* ps,SLDataType x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopFront</span><span class="params">(SL* ps)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SL s1;</span><br><span class="line">    SeqListInit(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TestSeqList1();</span></span><br><span class="line">    TestSeqList2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Text1.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SeqList.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestSeqList1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SL s1;</span><br><span class="line">    SeqListInit(&amp;s1);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">1</span>);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">2</span>);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">3</span>);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">4</span>);</span><br><span class="line">    SeqListPrint(&amp;s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法(把一个数据x插入最前面)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPushFront</span><span class="params">(SL* ps,SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当释放数据时会检查数据是否越界，越界就会报错，如果满了就需要增容</span></span><br><span class="line">    </span><br><span class="line">    SeqListCheckCapacity(ps);<span class="comment">//考虑是否需要增容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挪动数据</span></span><br><span class="line">    <span class="type">int</span> end=ps-&gt;size<span class="number">-1</span>;<span class="comment">//end开始指向最后数据的下标值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">endl</span>&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ps-&gt;a[end+<span class="number">1</span>]=ps-&gt;a[end];</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">    ps-&gt;a[<span class="number">0</span>]=x;</span><br><span class="line">    ps-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Text2.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestSeqList2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SL s1;</span><br><span class="line">    SeqListInit(&amp;s1);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">1</span>);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">2</span>);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">3</span>);</span><br><span class="line">    SeqListPushBack(&amp;s1,<span class="number">4</span>);</span><br><span class="line">    SeqListPrint(&amp;s1);</span><br><span class="line">    </span><br><span class="line">    SeqListPushFront(&amp;s1,<span class="number">10</span>);</span><br><span class="line">    SeqListPushFront(&amp;s1,<span class="number">20</span>);</span><br><span class="line">    SeqListPushFront(&amp;s1,<span class="number">30</span>);</span><br><span class="line">    SeqListPrint(&amp;s1);</span><br><span class="line">    SeqListPopFont(&amp;s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头删(因为顺序表要求从头开始存储，并且连续，所以size--是尾删)从前向后覆盖</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListPopFont</span><span class="params">(SL*)</span><span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps-&gt;size&gt;<span class="number">0</span>);<span class="comment">//(暴力方式)判断顺序表中有没有数据</span></span><br><span class="line">    <span class="comment">//挪动数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> begin=<span class="number">1</span>;<span class="comment">//使begin为下标1，也就是第二个数据的下标</span></span><br><span class="line">    <span class="keyword">while</span>(begin&lt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        ps-&gt;a[begin<span class="number">-1</span>]=ps-&gt;a[begin];</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找一个值x的位置，找到返回x位置下标，没有返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SeqListFind</span><span class="params">(SL* ps,SLDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ps-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ps-&gt;a[i]==x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//暴力求解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在pos位置前插入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListInsert</span><span class="params">(SL* ps,<span class="type">int</span> pos,SLDataType x)</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*1.</span></span><br><span class="line"><span class="comment">    if(pos&gt;ps-&gt;size||pose&lt;0)//pos可以等于size，选择尾插</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;pos invalid\n&quot;);</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    assert(pos&gt;=<span class="number">0</span>&amp;&amp;pos&lt;=ps-&gt;size)<span class="comment">//括号为假就报错</span></span><br><span class="line">        SeqListCheckCapacity(ps);<span class="comment">//考虑是否需要增容</span></span><br><span class="line">    <span class="type">int</span> end=ps-&gt;size<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end&gt;=pos)</span><br><span class="line">    &#123;</span><br><span class="line">        ps-&gt;a[end+<span class="number">1</span>]=ps-&gt;a[end];</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    ps-&gt;a[pos]=x;</span><br><span class="line">    ps-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除pos位置的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeqListEarse</span><span class="params">(SL* ps,<span class="type">int</span> pos)</span>; </span><br><span class="line">&#123;</span><br><span class="line">    assert(pos&gt;=<span class="number">0</span> &amp;&amp; pos&lt;ps-&gt;size);</span><br><span class="line">    <span class="type">int</span> begin=pos+<span class="number">1</span>;<span class="comment">//使begin指向要删除位置数据的后一位</span></span><br><span class="line">    <span class="keyword">while</span>(begin&lt;ps-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        ps-&gt;a[begin<span class="number">-1</span>]=ps-&gt;a[begin];</span><br><span class="line">        ++begin;</span><br><span class="line">    &#125;</span><br><span class="line">    ps-&gt;size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表">链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SList.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPrint</span><span class="params">(SLTNode* phead)</span></span><br><span class="line">&#123;</span><br><span class="line">    SLTNode* cur=phead;<span class="comment">//cur是一个指向结构体的指针</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,cur-&gt;data);</span><br><span class="line">        cur=cur-&gt;next;<span class="comment">//地址指针不连续</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void SListPushBack(SLTNode* phead,SLTDateType x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.尾插，为了解决插入第一个节点的问题要用二级指针，第二个就不用了，因为第二个改变的是结构体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushBack</span><span class="params">(SLTNode** pphead,SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    SLTNode* newnode=(SLTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SLNode));</span><br><span class="line">    newnode-&gt;data=x;</span><br><span class="line">    newnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(*pphead==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *pphead=newnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到尾节点</span></span><br><span class="line">    SLTNode* tail=*pphead;</span><br><span class="line">      <span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          tail=tail-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">    tail-&gt;next=newnode;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.头插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushFront</span><span class="params">(SLTNode** pphead,SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">   SLTNode* newnode=BuyListNode(x);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SLDNode* BuyListNode(SLTDateType x)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    SLTNode*newnode=(SLTNode*)malloc(sizeof(SLTNode));</span></span><br><span class="line"><span class="comment">    if(newnode==NULL)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      printf(&quot;malloc fail\n&quot;);</span></span><br><span class="line"><span class="comment">      exit(-1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    newnode-&gt;data=x;</span></span><br><span class="line"><span class="comment">    newnode-&gt;next=NULL;</span></span><br><span class="line"><span class="comment">    return newnode;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    newnode-&gt;next=*pphead;</span><br><span class="line">    *pphead=newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.尾删,如果删完就需要二级指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPopBack</span><span class="params">(SLTNode**pphead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*pphead==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((*pphead)-&gt;next==<span class="literal">NULL</span>)<span class="comment">//只有一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(*pphead);</span><br><span class="line">        *pphead=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SLTNode* prev=<span class="literal">NULL</span>;</span><br><span class="line">        SLTNode* tail=*pphead;</span><br><span class="line">        <span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        prev=tail;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="built_in">free</span>(tail);</span><br><span class="line">        tail=<span class="literal">NULL</span>;<span class="comment">//打印的时候要预防野指针问题，所以加下一行代码</span></span><br><span class="line">        prev-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.头删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPopFront</span><span class="params">(SLTNode** pphead)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(*pphead==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    SLTNode* next=(*pphead)-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(*pphead);</span><br><span class="line">    *pphezd=next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.查找</span></span><br><span class="line">SLTNode* <span class="title function_">SListFind</span><span class="params">(SLTNode* phead,SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    SLTNode* cur=phead;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;data==x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.在pos前插入一个节点</span></span><br><span class="line">SLTNode* <span class="title function_">SListInsert</span><span class="params">(SLTNode* phead,STNode* pos,SLTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    SLTNode* newnode=BuyListNode(x);</span><br><span class="line">    newnode-&gt;next=pos-&gt;next;</span><br><span class="line">    pos-&gt;next=newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.删除pos节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListEraes</span><span class="params">(SLTNode** pphead,SLTNode* pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//特殊情况要删除头节点</span></span><br><span class="line">    <span class="keyword">if</span>(*pphead==pos)</span><br><span class="line">    &#123;</span><br><span class="line">        *pphead=pos-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SListNode* prev=*pphead;</span><br><span class="line">        <span class="keyword">while</span>(prev-&gt;next!=pos)</span><br><span class="line">        &#123;</span><br><span class="line">            prev=prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next=pos-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(pos)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922723.png" /></p><h6 id="prev图如上">prev图如上</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SLisst.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SLDataType</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SLDataType data;<span class="comment">//定义一个数据类型为SLDataType的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span>* <span class="title">next</span>;</span><span class="comment">//节点(结构体)指针指向下一个节点，存的是下一个节点的地址</span></span><br><span class="line">&#125;SLTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPrint</span><span class="params">(SLTNode* phead)</span>;<span class="comment">//不会改变phead的值不用传二级</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushBack</span><span class="params">(SLTNode** pphead,SLTDateType x)</span>;<span class="comment">//尾插一个新节点1.找到原来的尾(尾的标志是该节点所存的地址是空)2.让原来最后节点指向要插入的节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SListPushFront</span><span class="params">(SLTNode** pphead,SLTDateType x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">SLTNode* <span class="title function_">SListFind</span><span class="params">(SLTNode* phead,SLTDataType x)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;SList.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestSList1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// SListNode* plist=NULL;phezd和plist都是指向首节点的指针  问题是形参phead的改变没有影响实参plist</span></span><br><span class="line">    SListNode* plist=<span class="literal">NULL</span>;</span><br><span class="line">    SListPushBack(&amp;plist,<span class="number">1</span>);</span><br><span class="line">    SListPushBack(&amp;plist,<span class="number">2</span>);</span><br><span class="line">    SListPushBack(&amp;plist,<span class="number">3</span>);</span><br><span class="line">    SListPushBack(&amp;plist,<span class="number">4</span>);</span><br><span class="line">    SListPrint(plist);</span><br><span class="line">    </span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">1</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">2</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">3</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestSList2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">1</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">2</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">3</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">4</span>);</span><br><span class="line">    SListPopBack(&amp;plist);</span><br><span class="line">    </span><br><span class="line">    SListPrint(plist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TestSList3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">1</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">2</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">3</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">2</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">4</span>);</span><br><span class="line">    SListPushFront(&amp;plist,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    SLTNode* pos=SListFind(plist,<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pos)<span class="comment">//当要寻找的值在链表中出现好几次时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个pos节点:%p-&gt;%d\n&quot;</span>,i++,pos,pos-&gt;data);</span><br><span class="line">        pos=SListFind(pos-&gt;next,<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改3-&gt;30</span></span><br><span class="line">    pos=SListFind(plist,<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">if</span>(pos)</span><br><span class="line">        &#123;</span><br><span class="line">            pos-&gt;data=<span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    SListPrint(plist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TestSList1();</span><br><span class="line">    TestSList2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922852.png" /></p><h6id="二级指针通过指针去改变指向空间的内容传一级指针改变指针的指向传二级指针">二级指针（通过指针去改变指向空间的内容传一级指针，改变指针的指向传二级指针）</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922752.png" /></p><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922211.png" /></p><h3id="哨兵位的头节点不需要存储有效数据">哨兵位的头节点不需要存储有效数据</h3><h6id="headtaillistnodemallocsizeoflistnode">head=tail=(ListNode*)malloc(sizeof(ListNode));</h6><h6id="但是不能直接返回head哨兵位头节点">但是不能直接返回head哨兵位头节点</h6><h2 id="带头的循环链表">带头的循环链表</h2><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922735.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListPushBack</span><span class="params">(LTNode* phead,LTDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(phead);</span><br><span class="line">    LTNode* tail=phead-&gt;prev;</span><br><span class="line">    LTNode* newnode=(LTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LTNode));</span><br><span class="line">    newnode-&gt;data=x;</span><br><span class="line">    </span><br><span class="line">    tail-&gt;next=newnode;</span><br><span class="line">    newnode-&gt;prev=tail;</span><br><span class="line">    newnode-&gt;next=phead;</span><br><span class="line">    phead-&gt;prev=newnode</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line"><span class="type">void</span> ListpopBack(LTNode* phead)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果继续删除会把哨兵位的头节点也删除所以要加断言</span></span><br><span class="line">    assert(phead);</span><br><span class="line">    assert(phead-&gt;next!=phead);</span><br><span class="line">    LTNode* tail=phead-&gt;prev;</span><br><span class="line">    LTNode* tail-&gt;prev;</span><br><span class="line">    <span class="comment">//先释放会产生野指针问题,所以要记录tail的前一个指针</span></span><br><span class="line">    <span class="built_in">free</span>(phead-&gt;prev);</span><br><span class="line">    </span><br><span class="line">    tailPrev-&gt;next=phead;</span><br><span class="line">    phead-&gt;prev=tailPrev;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插 </span></span><br><span class="line"><span class="comment">//phead指向哨兵位的头，next指针指向除了哨兵位的第一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LTNode* BuyListNode(LTDateType x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    LtNode* newnode=(LTNode*)malloc(sizeof(LTNode));</span></span><br><span class="line"><span class="comment">    newnode-&gt;data=x;</span></span><br><span class="line"><span class="comment">    newnode-&gt;next=NULL;</span></span><br><span class="line"><span class="comment">    newnode-&gt;prev=NULL;</span></span><br><span class="line"><span class="comment">    return newnode;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListPushFront</span><span class="params">(LTNode* phead,LTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(phead);</span><br><span class="line">    LTNode* newnode=BuyistNode(x);</span><br><span class="line">    LTNode* next=phead-&gt;next;</span><br><span class="line">    </span><br><span class="line">    phead-&gt;next=newnode;</span><br><span class="line">    newnode-&gt;prev=phead;</span><br><span class="line">    </span><br><span class="line">    newnode-&gt;next=next;</span><br><span class="line">    next-&gt;prev=newnode;</span><br><span class="line">    <span class="comment">//如果这个链表是一个空链表也不会有问题(此时phead的prev指向自己，phead的next也指向自己)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListPopFront</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(phead);</span><br><span class="line">    <span class="comment">//链表空</span></span><br><span class="line">    assert(phead-&gt;next!=phead);</span><br><span class="line">    </span><br><span class="line">    LTNode* next=phead-&gt;next;<span class="comment">//多定义一个变量</span></span><br><span class="line">    LTNode* nextNext=next-&gt;next;<span class="comment">//再多定义一个变量，就可以不用管是否先后释放内存</span></span><br><span class="line">    </span><br><span class="line">    phead-&gt;next=nextNext;</span><br><span class="line">    nextNext-&gt;prev=phead;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到值为x的节点</span></span><br><span class="line">LTNode* <span class="title function_">ListFind</span><span class="params">(LTNode* phead,LTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(phead);</span><br><span class="line">    LTNode* cur=phead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur!=phead)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span>(cur-&gt;data==x)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">return</span> cur;</span><br><span class="line">         &#125;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pos位置之前插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(LTNode* pos,LTDateType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pos);</span><br><span class="line">    LTNode* posPrev=pos-&gt;prev;</span><br><span class="line">    LTNode* newnode=BuyListNode(x);</span><br><span class="line">    </span><br><span class="line">    posPrev-&gt;next=newnode;</span><br><span class="line">    newnode-&gt;prev=posPrev;</span><br><span class="line">    newnode-&gt;next=pos;</span><br><span class="line">    pos-&gt;prev=newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="在pos位置插入">在pos位置插入</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922361.png" /></p><h6 id="下图相当于头插尾插">下图相当于头插尾插</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922639.png" /></p><h3id="相比于顺序表链表cup命中率不高有可能造成缓存污染连续的物理空间造成的">相比于顺序表链表cup命中率不高，有可能造成缓存污染(连续的物理空间造成的)</h3><h6id="访问存储数据的内存位置先看这个地址在不在缓存中在就直接访问不在就先加载到缓存再访问加载到缓存不只加载着一个数据位置而是预加载就近原则的一片数据内存位置">访问存储数据的内存位置，先看这个地址在不在缓存中，在就直接访问，不在就先加载到缓存再访问（加载到缓存不只加载着一个数据位置，而是预加载就近原则的一片数据内存位置）</h6><p><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202311091922876.png" /></p><h2 id="栈">栈</h2><h6id="进行数据的插入和删除操作的一端称为栈顶另一端为栈底">进行数据的插入和删除操作的一端称为栈顶，另一端为栈底</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stack.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> STDateType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    STDataType* a;<span class="comment">//栈用数组存储</span></span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">    <span class="type">int</span> capacity;<span class="comment">//空间长短</span></span><br><span class="line">&#125;ST;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(ST* ps)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestory</span><span class="params">(ST* ps)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(ST* ps,STDataType x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(ST* ps)</span>;</span><br><span class="line">STDataType <span class="title function_">StackTop</span><span class="params">(ST* ps)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(ST* ps)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">SackEmpty</span><span class="params">(ST* ps)</span>;<span class="comment">//判断栈是不是为空</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stack.c</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackInit</span><span class="params">(ST* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps);<span class="comment">//结构体指针不能为空</span></span><br><span class="line">    ps-&gt;a=<span class="literal">NULL</span>;</span><br><span class="line">    ps-&gt;top=<span class="number">0</span>;<span class="comment">//ps-&gt;top=-1; 初始化时top给的为0，意味着top指向栈顶数据的下一个  初始化时，top给的是-1，意味着top指向栈顶数据</span></span><br><span class="line">    ps-&gt;capacity=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPush</span><span class="params">(ST* ps,STDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ps-&gt;pop==ps-&gt;capacity)<span class="comment">//如果空间已经满了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> newCapacity=ps-&gt;capacity==<span class="number">0</span>?<span class="number">4</span>:ps-&gt;capacity*<span class="number">2</span>;<span class="comment">//如果空间满了就扩容到之前的二倍，如果初始空间是0就扩容到4</span></span><br><span class="line">        STDataType* tmp=<span class="built_in">realloc</span>(ps-&gt;a,<span class="keyword">sizeof</span>(STDataType)*newCapacity);</span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;realloc fail\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ps-&gt;a=tmp;</span><br><span class="line">        ps-&gt;capacity=newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(ps);</span><br><span class="line">    ps-&gt;a[ps-&gt;top]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackDestory</span><span class="params">(ST* ps)</span><span class="comment">//数据删空了还需要destory因为空间还没释放</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="built_in">free</span>(ps-&gt;a);</span><br><span class="line">    ps-&gt;a=<span class="literal">NULL</span>;</span><br><span class="line">    ps-&gt;capacity=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.删除数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPop</span><span class="params">(ST* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    assert(ps-&gt;top&gt;<span class="number">0</span>);</span><br><span class="line">    ps-&gt;top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.栈顶数据</span></span><br><span class="line">STDataType <span class="title function_">StackTop</span><span class="params">(ST* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    assert(!StackEmpty(ps));<span class="comment">//判断是否栈为空</span></span><br><span class="line">    <span class="keyword">return</span> ps-&gt;a[ps-&gt;top<span class="number">-1</span>];<span class="comment">//因为初始化top为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(ST* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="keyword">if</span>(ps-&gt;top==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackSize</span><span class="params">(ST* ps)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(ps);</span><br><span class="line">    <span class="keyword">return</span> ps-&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Text.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TextStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ST st;</span><br><span class="line">    StackInit(&amp;st);</span><br><span class="line">    </span><br><span class="line">    StackPush(&amp;st,<span class="number">1</span>);</span><br><span class="line">    StackPush(&amp;st,<span class="number">2</span>);</span><br><span class="line">    StackPush(&amp;st,<span class="number">3</span>);</span><br><span class="line">    StackPush(&amp;st,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!StackEmpty(&amp;st))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,StackTop(&amp;st));</span><br><span class="line">        StackPop(&amp;st);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列">队列</h2><h6id="只允许再一端进行插入操作在另一端就进行删除数据的操作先进先出进行插入操作的一端称为队尾进行删除一端的操作称为队头">只允许再一端进行插入操作，在另一端就进行删除数据的操作（先进先出）。进行插入操作的一端称为队尾，进行删除一端的操作称为队头。</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//queue.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QDataType;<span class="comment">//int可以写作QDataType</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> //队列用的是链表结构,这个结构体代表一个新节点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    QDataType data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.</span></span><br><span class="line"><span class="comment">这里的Queue代表结构体</span></span><br><span class="line"><span class="comment">typedef struct Queue</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;Queue;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">这里的Queue代表变量</span></span><br><span class="line"><span class="comment">struct Queue</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">&#125;Queue;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueueNode* head;</span><br><span class="line">    QueueNode* tail;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* pq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* pq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* pq,QDataType x)</span>;<span class="comment">//队尾插入数据x</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* pq)</span>;<span class="comment">//对头删除数据</span></span><br><span class="line">QDataType <span class="title function_">QueuFront</span><span class="params">(Queue* pq)</span>;<span class="comment">//取队头的数据</span></span><br><span class="line">QDataType <span class="title function_">QueuBack</span><span class="params">(Queue* pq)</span>;<span class="comment">//取队尾的数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* pq)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* pq)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//queue.c</span></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">    arrert(pq);</span><br><span class="line">    qp-&gt;head=<span class="literal">NULL</span>;</span><br><span class="line">    pq-&gt;tail=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pq);</span><br><span class="line">    QueueNode* cur=pq-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        QueueNode* next=pq-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* pq,QDataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pq);</span><br><span class="line">    QueueNode* newnode=(QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newnode-&gt;data=x;</span><br><span class="line">    newnode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pq-&gt;head==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pq-&gt;head=pq-&gt;tail=newnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pq-&gt;tail-&gt;next=newnode;</span><br><span class="line">        pq-&gt;tail=newnode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pq);</span><br><span class="line">    assert(QueueEmpty(pq));</span><br><span class="line">    QueueNode* next=pq-&gt;head-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(pq-&gt;head);</span><br><span class="line">    pq-&gt;head=next;</span><br><span class="line">    <span class="comment">//tail可能为野指针</span></span><br><span class="line">    <span class="keyword">if</span>(pq-&gt;head==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pq-&gt;tail=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pq);</span><br><span class="line">    <span class="keyword">return</span> pq-&gt;head==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(pq);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    QueueNode* cur=pq-&gt;head;</span><br><span class="line">    <span class="keyword">while</span>(cur)</span><br><span class="line">    &#123;</span><br><span class="line">        ++n;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TextQueue1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    QueueInit(&amp;q);<span class="comment">//改变一级就传二级，改变结构体就传结构体的指针</span></span><br><span class="line">    QueuePush(&amp;q,<span class="number">1</span>);</span><br><span class="line">    QueuePush(&amp;q,<span class="number">2</span>);</span><br><span class="line">    QueuePush(&amp;q,<span class="number">3</span>);</span><br><span class="line">    QueuePush(&amp;q,<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!=QueueEmpty(&amp;q))</span><br><span class="line">    &#123;</span><br><span class="line">        QDataType front=QueueFront(&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,front);</span><br><span class="line">        QueuePop(&amp;q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">TextQueue1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串数组和广义表">串数组和广义表</h2><h6id="子串一个串中任意个连续字符组成的子序列称为子串">子串：一个串中任意个连续字符组成的子序列称为子串</h6><h6id="子串子串第一个字符在主串中的位置">子串：子串第一个字符在主串中的位置</h6><h6id="串相等当且仅当两个串的长度相等并且各个对应位置上的字符都相同时这两个串才是相等的-所有的空串都是相等的">串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的所有的空串都是相等的</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据结构&quot;&gt;数据结构&lt;/h1&gt;
&lt;h2
id=&quot;时间复杂度时间复杂度及空间复杂度&quot;&gt;时间复杂度（时间复杂度及空间复杂度）&lt;/h2&gt;
&lt;h6
id=&quot;摩尔定律每18个月运行内存都会更新空间复杂度不再特变关注&quot;&gt;摩尔定律（每18个月运行内存都会更新，空间复杂度</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>MatlabClass</title>
    <link href="https://pipi1002.github.io/2023/07/17/MatlabClass/"/>
    <id>https://pipi1002.github.io/2023/07/17/MatlabClass/</id>
    <published>2023-07-17T06:33:43.000Z</published>
    <updated>2024-02-27T13:21:48.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="matlab-的学习">Matlab 的学习</h1><h2 id="matlab系统环境">matlab系统环境</h2><h6 id="matlab的搜索路径为">matlab的搜索路径为：</h6><p>变量，内部函数，程序文件（先搜索当前文件再在文件搜索路径下搜索）</p><ul><li>如果在当前文件夹和搜索路径文件夹下建立了一个同名的M文件，那么在命令行窗口输入文件名时，会执行哪个文件？<ul><li>答：执行当前文件夹下的文件</li></ul></li><li>如果用户建立的文件既没有保存在当前文件夹下，又没有保存在文件搜索路径中，那么在命令行窗口输入文件名时会出现什么信息？<ul><li>答：系统找不到，会报错</li></ul></li></ul><h2 id="matlab数值数据">matlab数值数据</h2><ul><li>整型数据MatLab提供了数据类型转换函数来实现数据类型的转换。例如uint8函数将数值数据转换为无符号8位整数，int8函数将数值数据转换为带符号8位整数</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;x=int8(<span class="number">129</span>)</span><br><span class="line">x=</span><br><span class="line">  <span class="number">127</span>      //因为带符号整数取值为<span class="number">-2</span>的<span class="number">7</span>次方到+<span class="number">2</span>的<span class="number">7</span>次方减<span class="number">1</span>(<span class="number">-128</span>~<span class="number">127</span>),所以转换成带 &gt;&gt;x=uint8(<span class="number">129</span>)     符号数的最大值<span class="number">127</span></span><br><span class="line">x=</span><br><span class="line">  <span class="number">129</span>   //不带符号数的取值为<span class="number">0</span>~<span class="number">2</span>的<span class="number">8</span>次方减<span class="number">1</span>(<span class="number">0</span>~<span class="number">255</span>)</span><br></pre></td></tr></table></figure><ul><li>浮点型在matlab中数值数据默认为浮点型，浮点型数据分为双精度和单精度两种，单精度占4个字节，双精度占8个字节，所以双精度型的数据精度更高。<ul><li>single函数：将其他类型的数据转换为单精度型</li><li>double函数：将其他类型的数据转换为双精度型</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;class(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">double</span><br><span class="line">&gt;&gt;class(single(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">single</span><br></pre></td></tr></table></figure><ul><li>复型数据复型数据包括实部和虚部两个部分，实部和虚部默认为双精度类型，叙述单位用i或者j来表示<ul><li>real函数：求复数的实部</li><li>imag函数：求负数的虚部</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="number">6</span>+<span class="number">5</span><span class="built_in">i</span></span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">6.0000</span>+<span class="number">5.0000</span><span class="built_in">i</span></span><br><span class="line">&gt;&gt;<span class="number">6</span>+<span class="number">5</span><span class="built_in">j</span></span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">6.0000</span>+<span class="number">5.0000</span><span class="built_in">i</span>  //这两个表示的是同一个负数</span><br></pre></td></tr></table></figure><ul><li><h4id="format命令的格式formt格式符">format命令的格式：formt格式符</h4></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;format long</span><br><span class="line">&gt;&gt;<span class="number">50</span>/<span class="number">3</span></span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">16.666666666666668</span>  //小数点后<span class="number">15</span>位</span><br><span class="line">&gt;&gt;format  //默认short型</span><br><span class="line">&gt;&gt;<span class="number">50</span>/<span class="number">3</span></span><br><span class="line"><span class="built_in">ans</span>=<span class="number">16.66667</span>  //小数点后<span class="number">5</span>位</span><br></pre></td></tr></table></figure><h6id="format命令只影响数据输出格式而不影响数据的计算和存储">format命令只影响数据输出格式而不影响数据的计算和存储</h6><h4 id="常用数学函数">常用数学函数</h4><ul><li>函数的调用格式为：</li></ul><p>函数名（函数自变量的值）函数的自变量规定为矩阵变量，当然也可以是标量，标量本身是矩阵的一种特例。函数在运算时是将函数逐项作用于矩阵的每个元素上，所以最后遇的结果就是一个与自变量同型的矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">4</span>  <span class="number">2</span></span><br><span class="line">  <span class="number">3</span>  <span class="number">6</span></span><br><span class="line">&gt;&gt;B=<span class="built_in">exp</span>(A)    //A把调用结果赋给B</span><br><span class="line">B=<span class="number">54.5982</span>  <span class="number">7.3891</span>  //B最后结果也为和A一样的同型矩阵，并且对应的每个数字都是求对数字求自然指数得来的</span><br><span class="line">  <span class="number">20.0855</span>  <span class="number">403.4288</span></span><br></pre></td></tr></table></figure><h2 id="matlab变量与数值语句">matlab变量与数值语句</h2><ul><li>在matlab中，变量以字母开头，后接数字或下划线，最多63给字符<ul><li>变量=表达式</li><li>表达式赋值给matlab预定义变量ans</li></ul></li></ul><p>注意：如果在赋值语句后加；那么matlab仅仅执行赋值操作，不会显示运算后变量的结果</p><p><imgsrc="https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/屏幕截图_20230723_073027.png" /></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;x=<span class="built_in">sqrt</span>(<span class="number">7</span>)<span class="number">-2</span><span class="built_in">i</span>;</span><br><span class="line">&gt;&gt;y=<span class="built_in">exp</span>(<span class="built_in">pi</span>/<span class="number">2</span>);</span><br><span class="line">&gt;&gt;z=(<span class="number">5</span>+<span class="built_in">cosd</span>(<span class="number">47</span>)/(<span class="number">1</span>+<span class="built_in">abs</span>(x-y)))</span><br></pre></td></tr></table></figure><ul><li>ans是默认赋值变量</li><li>i和j代表虚数单位</li><li>pi代表圆周率</li><li>NaN代表非数</li></ul><h5 id="变量的管理">变量的管理：</h5><p>（1）变量的删除和修改：可在工作区进行</p><ul><li>who命令可以显示出驻留变量的名称</li><li>whos命令不仅显示出名称还会给出它们的大小、所占字节数及数据类型等信息</li></ul><p>（2）内存变量文件：用于保存matlab工作区变量的文件叫做内存变量文件，其扩展名为.mat，也叫MAT文件（标准二进制文件）</p><ul><li>save命令：创建内存变量文件</li><li>load命令：装入内存变量文件<ul><li>若变量a和变量x存在matlab工作空间中，可以执行命令 &gt;&gt;save mydatea x 这样就会把a和x保存在mydate.mat文件中</li><li>在下一次重新进入matlab时，输入&gt;&gt;loadmydate,就把mydate.mat文件中的内容装入matlab工作空间，那么在当前matlab工作环境中a和x已知</li></ul></li></ul><h2 id="matlab矩阵的表示">matlab矩阵的表示</h2><ul><li>利用直接输入法建立矩阵：将矩阵的元素用中括号括起来，按矩阵行的顺序输入各个元素，同一行的各元素之间用逗号或空格分隔，不同行的元素之间用分号分隔</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">  <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">  <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><ul><li>利用已经建立好的矩阵建立更大的矩阵：一个大矩阵由两个小的拼接而成</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">&gt;&gt;B=[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>;<span class="number">-4</span>,<span class="number">-5</span>,<span class="number">-6</span>;<span class="number">-7</span>,<span class="number">-8</span>,<span class="number">-9</span>];</span><br><span class="line">&gt;&gt;C=[A,B;B,A]</span><br><span class="line">C=</span><br><span class="line">  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span></span><br><span class="line">  <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">-4</span> <span class="number">-5</span> <span class="number">-6</span></span><br><span class="line">  <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">-7</span> <span class="number">-8</span> <span class="number">-9</span></span><br><span class="line">  <span class="number">-1</span> <span class="number">-2</span> <span class="number">-3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">  <span class="number">-4</span> <span class="number">-5</span> <span class="number">-6</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">  <span class="number">-7</span> <span class="number">-8</span> <span class="number">-9</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h5id="可以用实部矩阵和虚部矩阵构成复数矩阵">可以用实部矩阵和虚部矩阵构成复数矩阵</h5><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;B=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">&gt;&gt;C=[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>];</span><br><span class="line">&gt;&gt;A=B+<span class="built_in">i</span>*C</span><br><span class="line">A=</span><br><span class="line"><span class="number">1.0000</span>+<span class="number">6.0000</span><span class="built_in">i</span>  <span class="number">2.0000</span>+<span class="number">7.0000</span><span class="built_in">i</span>  <span class="number">3.0000</span>+<span class="number">8.0000</span><span class="built_in">i</span></span><br><span class="line"><span class="number">4.0000</span>+<span class="number">9.0000</span><span class="built_in">i</span>  <span class="number">5.0000</span>+<span class="number">10.0000</span><span class="built_in">i</span>  <span class="number">6.0000</span>+<span class="number">11.0000</span><span class="built_in">i</span></span><br></pre></td></tr></table></figure><h6id="向量是矩阵的特殊类型可以由冒号表达式产生行向量也可用linspace函数产生一个行向量">向量是矩阵的特殊类型，可以由冒号表达式产生行向量,也可用linspace函数产生一个行向量</h6><p><code>格式：</code>e1:e2:e3//e1为初始值，e2为步长可省略默认为1，e3为终止值</p><p>​linspace（a,b,n）,a为第一个元素，b为最后一个元素，n为元素总数当n省略时将自动产生100个元素</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;t=<span class="number">0</span>:<span class="number">1</span>:<span class="number">5</span></span><br><span class="line">t=</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">  </span><br><span class="line">&gt;&gt;x=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="built_in">pi</span>,<span class="number">6</span>)</span><br><span class="line">x=</span><br><span class="line">  <span class="number">0</span> <span class="number">0.6283</span> <span class="number">1.2566</span> <span class="number">1.8850</span> <span class="number">2.5133</span> <span class="number">3.1416</span></span><br></pre></td></tr></table></figure><h3 id="结构矩阵和单元矩阵">结构矩阵和单元矩阵</h3><h4id="结构矩阵数据类型不同而逻辑相关的数据组成一个有机整体其中每个数据又构成了结构数据的一个成员学生学号姓名性别学生这个结构数据包含了这三个成员">结构矩阵：数据类型不同而逻辑相关的数据组成一个有机整体，其中每个数据又构成了结构数据的一个成员（学生：学号，姓名，性别），学生这个结构数据，包含了这三个成员</h4><p><code>格式：</code>结构矩阵元素.成员名=表达式</p><p>eg.例如要建立含有三个元素的结构矩阵a，每个元素包含三个数据类型</p><p><code>我们只需要分别给结构矩阵a中的每个元素里的每个成员赋值就可以了</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;a(<span class="number">1</span>).x1=<span class="number">10</span>;a(<span class="number">1</span>).x2=<span class="string">&#x27;liu&#x27;</span>;a(<span class="number">1</span>).x3=[<span class="number">11</span>,<span class="number">21</span>;<span class="number">34</span>,<span class="number">78</span>];</span><br><span class="line">&gt;&gt;a(<span class="number">2</span>).x1=<span class="number">12</span>;a(<span class="number">2</span>).x2=<span class="string">&#x27;wang&#x27;</span>;a(<span class="number">2</span>).x3=[<span class="number">34</span>,<span class="number">191</span>;<span class="number">27</span>,<span class="number">578</span>];</span><br><span class="line">&gt;&gt;a(<span class="number">3</span>).x1=<span class="number">10</span>;a(<span class="number">3</span>).x2=<span class="string">&#x27;liu&#x27;</span>;a(<span class="number">3</span>).x3=[<span class="number">13</span>,<span class="number">890</span>;<span class="number">67</span>,<span class="number">231</span>];</span><br></pre></td></tr></table></figure><h4id="单元矩阵单元数据类型也是把不同数据类型放在一个变量中单元矩阵的各个元素就是不同类型的数据每个元素就是由不同数据类型组成的而结构数据矩阵下的元素是由名字不同的成员构成-建立单元矩阵和一般矩阵相似直接输入就可以只是单元矩阵元素用大括号括起来">单元矩阵：单元数据类型也是把不同数据类型放在一个变量中，单元矩阵的各个元素就是不同类型的数据，每个元素就是由不同数据类型组成的（而结构数据矩阵下的元素是由名字不同的成员构成）建立单元矩阵和一般矩阵相似，直接输入就可以，只是单元矩阵元素用大括号括起来。</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;b=&#123;<span class="number">10</span>,<span class="string">&#x27;liu&#x27;</span>,[<span class="number">11</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">78</span>];<span class="number">12</span>,<span class="string">&#x27;wang&#x27;</span>,[<span class="number">34</span>,<span class="number">191</span>;<span class="number">27</span>,<span class="number">578</span>];<span class="number">14</span>,<span class="string">&#x27;cai&#x27;</span>,[<span class="number">13</span>,<span class="number">890</span>;<span class="number">67</span>,<span class="number">231</span>]&#125;</span><br><span class="line">b=</span><br><span class="line">  [<span class="number">10</span>]  <span class="string">&#x27;liu&#x27;</span>  [<span class="number">2</span>*<span class="number">2</span> double]</span><br><span class="line">  [<span class="number">12</span>]  <span class="string">&#x27;wang&#x27;</span> [<span class="number">2</span>*<span class="number">2</span> double]</span><br><span class="line">  [<span class="number">14</span>]  <span class="string">&#x27;cai&#x27;</span>  [<span class="number">2</span>*<span class="number">2</span> double]</span><br></pre></td></tr></table></figure><h2 id="矩阵元素的引用">矩阵元素的引用</h2><ul><li>通过下标来引用矩阵元素 A(4,5)第四行第五列</li></ul><p><span class="math display">\[&gt;&gt;A=[1,2,3;4,5,6];&gt;&gt;A(4,5)=10;A=  1 2 3 0 0  4 5 6 0 0  0 0 0 0 0  0 0 0 0 10  //自动补0\]</span></p><ul><li>通过序号引用在matlab中矩阵元素按列存储，即首先存储矩阵的第一列元素，然后存储第二列元素一直存储到最后一列矩阵元素的序号就是矩阵元素在内存中的排列顺序<ul><li>序号与下标是一一对应的，以m×n矩阵A为例，矩阵元素A(i,j)的序号为(j-1)×m+i</li><li>矩阵元素的序号可以与下标可以利用sub2ind和ind2sub函数实现相互转换。<ul><li><code>sub2ind函数</code>:将矩阵中指定元素的行，列下标转换成存储的序号。调用格式为：D=sub2ind(S,I,J)<code>S:</code>行数和列数组成的向量 <code>I:</code>转换矩阵元素的行下标<code>J:</code>转换矩阵元素的列下标<code>D:</code>对应下标元素的序号</li><li><code>ind2sub函数:</code>将把矩阵元素的序号转换成对应的下标。调用格式为：[i,j]=ind2sub(S,D)<code>S:</code>行数和列数组成的向量 <code>D:</code>对应下标元素的序号<code>I:</code>转换矩阵元素的行下标<code>J:</code>转换矩阵元素的列下标</li></ul></li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">  <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">&gt;&gt;A(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">2</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">//<span class="built_in">size</span>函数的结果是由这个矩阵的行数和列数组成的一个矩阵</span><br><span class="line">//<span class="built_in">sub2ind</span>函数举例</span><br><span class="line">&gt;&gt;A=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">  <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">&gt;&gt;D=<span class="built_in">sub2ind</span>(<span class="built_in">size</span>(A),[<span class="number">1</span>,<span class="number">2</span>;<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>;<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">D=</span><br><span class="line">  <span class="number">1</span> <span class="number">2</span></span><br><span class="line">  <span class="number">6</span> <span class="number">4</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&gt;&gt;[I,J]=<span class="built_in">ind2sub</span>([<span class="number">3</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>])  //求一个三行三列矩阵的第一个第三个第五个元素的下标</span><br><span class="line">I=</span><br><span class="line">  <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">J=</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3id="利用冒号表达式获得子矩阵子矩阵是指矩阵中的一部分元素构成的矩阵">利用冒号表达式获得子矩阵（子矩阵是指矩阵中的一部分元素构成的矩阵）</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A(<span class="built_in">i</span>,:)           //第<span class="built_in">i</span>行的全部元素</span><br><span class="line">A(:,<span class="built_in">j</span>)           //第<span class="built_in">j</span>列的全部元素</span><br><span class="line">A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,k:k+m)   //第<span class="built_in">i</span>~<span class="built_in">i</span>+m行内且在第k~k+m列中的所有元素</span><br><span class="line">A(<span class="built_in">i</span>:<span class="built_in">i</span>+m,:)       //第<span class="built_in">i</span>~<span class="built_in">i</span>+m行的全部元素</span><br></pre></td></tr></table></figure><p><code>end运算符：</code>表示某一维的末尾元素下标</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>;<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>];</span><br><span class="line">&gt;&gt;A(<span class="keyword">end</span>,:)</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br><span class="line">&gt;&gt;A([<span class="number">1</span>,<span class="number">4</span>],<span class="number">3</span>:<span class="keyword">end</span>)  //第一行到第四行的第三列到最后一列的元素</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line">  <span class="number">18</span> <span class="number">19</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><h3id="利用空矩阵删除矩阵的元素空矩阵是指没有任何元素的矩阵">利用空矩阵删除矩阵的元素，空矩阵是指没有任何元素的矩阵</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;x=[]</span><br><span class="line">x=</span><br><span class="line">  []</span><br><span class="line">x是一个空矩阵</span><br><span class="line"></span><br><span class="line">&gt;&gt;A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">6</span>;<span class="number">1</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">1</span> <span class="number">2</span>  <span class="number">3</span>  <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">7</span> <span class="number">0</span>  <span class="number">9</span>  <span class="number">2</span> <span class="number">6</span></span><br><span class="line">  <span class="number">1</span> <span class="number">4</span> <span class="number">-1</span>  <span class="number">1</span> <span class="number">8</span></span><br><span class="line">&gt;&gt;A(:,[<span class="number">2</span>,<span class="number">4</span>])=[]  //删除第二列和第四列的元素</span><br><span class="line">A=</span><br><span class="line">  <span class="number">1</span>  <span class="number">3</span> <span class="number">0</span></span><br><span class="line">  <span class="number">7</span>  <span class="number">9</span> <span class="number">6</span></span><br><span class="line">  <span class="number">1</span> <span class="number">-1</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="改变矩阵的形状">改变矩阵的形状</h3><p><code>reshape:</code>在矩阵总元素保持不变的前提下，将矩阵A重新排成m×n的二维矩阵。<code>reshape函数只是改变原矩阵的行数和列数，但并不改变原矩阵元素个数及其存储顺序</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;x=[<span class="number">23</span>,<span class="number">45</span>,<span class="number">65</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">34</span>,<span class="number">98</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">65</span>,<span class="number">43</span>,<span class="number">76</span>];</span><br><span class="line">&gt;&gt;y=<span class="built_in">reshape</span>(x,<span class="number">3</span>,<span class="number">4</span>)  //就是把x矩阵变为<span class="number">3</span>×<span class="number">4</span>的矩阵</span><br><span class="line">y=</span><br><span class="line">  <span class="number">23</span> <span class="number">34</span> <span class="number">98</span> <span class="number">65</span></span><br><span class="line">  <span class="number">45</span> <span class="number">65</span> <span class="number">45</span> <span class="number">43</span></span><br><span class="line">  <span class="number">65</span> <span class="number">34</span> <span class="number">78</span> <span class="number">76</span></span><br></pre></td></tr></table></figure><p><code>A(:):</code>将矩阵A的每一列元素堆叠起来，成为一个列向量</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">-45</span>,<span class="number">65</span>,<span class="number">71</span>;<span class="number">27</span>,<span class="number">35</span>,<span class="number">91</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">-45</span> <span class="number">65</span> <span class="number">71</span></span><br><span class="line">   <span class="number">27</span> <span class="number">35</span> <span class="number">91</span></span><br><span class="line">&gt;&gt;B=A(:)    A(:)等价于<span class="built_in">reshape</span>(A,<span class="number">6</span>,<span class="number">1</span>)</span><br><span class="line">B=</span><br><span class="line">  <span class="number">-45</span></span><br><span class="line">   <span class="number">27</span></span><br><span class="line">   <span class="number">65</span></span><br><span class="line">   <span class="number">35</span></span><br><span class="line">   <span class="number">71</span></span><br><span class="line">   <span class="number">91</span></span><br></pre></td></tr></table></figure><h2id="matlab基本运算matlab的运算都是根据矩阵而言的">matlab基本运算（matlab的运算都是根据矩阵而言的）</h2><ul><li><p>算数运算</p><ul><li>基本算数运算：基本运算符:+ ， -， * ， /(右除) ，  (左除)，^(乘方)<code>matlab的算数运算是在矩阵意义下进行的。单个数据的算数运算只是矩阵运算的一种特例</code><ul><li>加减运算必须是同型矩阵</li><li>两矩阵相乘要求矩阵A的列数和矩阵B的行数相同</li><li>有两种矩阵除法，如果A矩阵是非奇异方阵，则B/A等效于B<em>inv(A),A(A)</em>B</li><li>A^x乘方运算要求A为方阵，x为标量</li></ul></li><li>点运算：点运算符：.* , ./ , .  ,.^<ul><li>要求两个矩阵同型</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line">&gt;&gt;B=[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">&gt;&gt;C=A.*B</span><br><span class="line">C=</span><br><span class="line">  <span class="number">-1</span>  <span class="number">0</span> <span class="number">3</span> </span><br><span class="line">   <span class="number">4</span> <span class="number">-5</span> <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>  <span class="number">8</span> <span class="number">9</span></span><br><span class="line">&gt;&gt;D=A*B</span><br><span class="line">D=</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//当x=<span class="number">0.1</span>、<span class="number">0.4</span>、<span class="number">0.7</span>、<span class="number">1</span>时，分别求y=sinxcosx的值</span><br><span class="line">&gt;&gt;x=<span class="number">0.1</span>:<span class="number">0.3</span>:<span class="number">1</span>;</span><br><span class="line">&gt;&gt;y=<span class="built_in">sin</span>(x).*<span class="built_in">cos</span>(x);  //这里必须用点乘，因为x是一个向量，<span class="built_in">sin</span>(x)和<span class="built_in">cos</span>(x)是和x同长度的向量,如果用乘法没用点乘就会出现不相容(A行不等B列)的情况</span><br></pre></td></tr></table></figure></li><li><p>关系运算</p><ul><li>关系运算符：&lt;, &gt;, &lt;= ,&gt;= ,==,~=(不等于)若两个数是标量时，直接比较两个数大小，若关系成立则为1否则为0<ul><li>当参与比较的是两个同型的矩阵时，比较是对两矩阵位置的元素按标量关系运算规则逐个进行，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成</li><li>当参与比较的一个是标量，而另一个是矩阵时，则把标量与矩阵的每个元素按标量关系运算规则逐个比较，最终的关系运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成</li></ul></li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//<span class="built_in">rem</span>(A,<span class="number">2</span>)是求A中每个元素除二的余数矩阵</span><br><span class="line">&gt;&gt;A=[<span class="number">24</span>,<span class="number">35</span>,<span class="number">13</span>;<span class="number">22</span>,<span class="number">63</span>,<span class="number">23</span>;<span class="number">39</span>,<span class="number">47</span>,<span class="number">80</span>]</span><br><span class="line">A=</span><br><span class="line">  <span class="number">24</span> <span class="number">35</span> <span class="number">13</span> </span><br><span class="line">  <span class="number">22</span> <span class="number">63</span> <span class="number">23</span></span><br><span class="line">  <span class="number">39</span> <span class="number">47</span> <span class="number">80</span></span><br><span class="line">&gt;&gt;P=<span class="built_in">rem</span>(A,<span class="number">2</span>)==<span class="number">0</span></span><br><span class="line">P=</span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">  //P中元素为<span class="number">1</span>的矩阵就是元素为偶数的位置</span><br></pre></td></tr></table></figure><ul><li>逻辑运算<ul><li>逻辑运算符：&amp;，|，~<ul><li>a&amp;b a和b要全是1，才为1</li><li>a|b a和b一个为1就是1</li><li>~a a为0，运算结果为1；a为非0，运算结果为0</li><li>当参与逻辑运算的是两个同型的矩阵时，比较是对两矩阵位置的元素按逻辑关系运算规则逐个进行，最终的逻辑运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成</li><li>当参与逻辑运算的一个是标量，而另一个是矩阵时，则把标量与矩阵的每个元素按逻辑关系运算规则逐个比较，最终的逻辑运算的结果是一个与原矩阵同型的矩阵，它的元素由0或1组成</li></ul></li></ul></li></ul><p><code>算数运算的优先级最高，逻辑运算优先级最低，但逻辑非运算是单目运算，它的优先级比双目运算要高</code></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//水仙花数</span><br><span class="line">&gt;&gt;m1=<span class="number">100</span>:<span class="number">999</span></span><br><span class="line">&gt;&gt;m2=<span class="built_in">rem</span>(<span class="built_in">fix</span>(m/<span class="number">10</span>),<span class="number">10</span>);</span><br><span class="line">&gt;&gt;m3=<span class="built_in">fix</span>(m/<span class="number">100</span>);</span><br><span class="line">&gt;&gt;k=<span class="built_in">find</span>(m==m1.*m1.*m1+m2.*m2.*m2+m3.*m3.*m3)</span><br><span class="line">k=</span><br><span class="line">  <span class="number">54</span> <span class="number">271</span> <span class="number">272</span> <span class="number">308</span></span><br><span class="line">&gt;&gt;s=m(k)</span><br><span class="line">s=</span><br><span class="line">  <span class="number">153</span> <span class="number">370</span> <span class="number">371</span> <span class="number">407</span></span><br></pre></td></tr></table></figure><h2 id="字符串的处理">字符串的处理</h2><ul><li>在matlab中，字符串是用单引号括起来的字符序列</li><li>若字符串中的字符有单引号，则该单引号字符要用两个单引号来表示</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;xm=<span class="string">&#x27;Central South University&#x27;</span></span><br><span class="line">&gt;&gt;xm(<span class="number">1</span>:<span class="number">3</span>)  //取字符串的第<span class="number">1</span>到第<span class="number">3</span>个字符</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">Cen</span><br><span class="line"></span><br><span class="line">&gt;&gt;<span class="string">&#x27;I &quot;m a teacher.&#x27;</span></span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">I&#x27;m a teacher.</span><br></pre></td></tr></table></figure><ul><li>matlab中可以建立多行字符串，形成字符串矩阵，字符串就相当于一个行向量，每个字符就是其中一个元素</li></ul><p><imgsrc="https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230727_235647.jpg" /></p><h3 id="字符串的操作">字符串的操作</h3><ul><li>字符串的执行：<code>eval(s)  这里的s是一个字符串</code></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;t=<span class="built_in">pi</span>;</span><br><span class="line">&gt;&gt;m=<span class="string">&#x27;[t,sin(t),cos(t)]&#x27;</span>;</span><br><span class="line">&gt;&gt;y=eval(m)</span><br><span class="line">y=</span><br><span class="line">  <span class="number">3.1416</span> <span class="number">0.0000</span> <span class="number">-1.0000</span></span><br></pre></td></tr></table></figure><ul><li>字符串与数值之间的转换<ul><li>abs和double函数都可以用来获取字符串矩阵所对应的ASCII码数值矩阵</li><li>char函数可以把ASCII码矩阵转换为字符串矩阵</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;s1=<span class="string">&#x27;MATLAB&#x27;</span>;</span><br><span class="line">&gt;&gt;a=<span class="built_in">abs</span>(s1)</span><br><span class="line">a=</span><br><span class="line">  <span class="number">77</span> <span class="number">65</span> <span class="number">84</span> <span class="number">76</span> <span class="number">65</span> <span class="number">66</span></span><br><span class="line">&gt;&gt;char(a+<span class="number">32</span>)</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">matlab</span><br></pre></td></tr></table></figure><ul><li>字符串的比较<ul><li>关系运算符：两个字符串的每个字符依次按ASCII值大小逐个进行比较，比较的结果是一个数值向量，向量中的元素要么是1，要么是0</li><li>字符串比较函数<ul><li>strcmp(s1,s2):用来比较字符串s1和s2是否相等，相等返回1，否则0</li><li>strncmp(s1,s2,n):用来比较两个字符串前n个字符是否相等，相等返回1，否则0</li><li>strcmpi(s1,s2):在忽略字母大小写前提下来比较字符串s1和s2是否相等，相等返回1，否则0</li><li>strncmpi(s1,s2,n)：在忽略字母大小写前提下比较两个字符串前n个字符是否相等，相等返回1，否则0</li></ul></li></ul></li><li>字符串的查找与替换<ul><li>findstr(s1,s2):返回段字符串在长字符串中的开始位置</li><li>strrep(s1,s2,s3):将字符串s1中的所有字符串s2替换成字符串s3</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;p=findstr(<span class="string">&#x27;This is test!&#x27;</span>,<span class="string">&#x27;is&#x27;</span>)</span><br><span class="line">p=</span><br><span class="line">  <span class="number">3</span> <span class="number">6</span></span><br><span class="line">&gt;&gt;&gt;p=findstr(<span class="string">&#x27;is&#x27;</span>,<span class="string">&#x27;This is test!&#x27;</span>)</span><br><span class="line">p=</span><br><span class="line">  <span class="number">3</span> <span class="number">6</span></span><br><span class="line">&gt;&gt;result=strrep(<span class="string">&#x27;This is a test!&#x27;</span>,<span class="string">&#x27;text&#x27;</span>,<span class="string">&#x27;class&#x27;</span>)</span><br><span class="line">result=</span><br><span class="line">This is a class</span><br></pre></td></tr></table></figure><h2 id="特殊矩阵调用方式相似">特殊矩阵（调用方式相似）</h2><ul><li><p>zreos函数：产生全0矩阵，即零矩阵</p><ul><li><p>zero(m):产生m×m零矩阵</p></li><li><p>zeros(m,n):产生m×n零矩阵</p></li><li><p>zero(size(A)):产生与矩阵A同样大小的零矩阵</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;A=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">A=</span><br><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">&gt;&gt;<span class="built_in">zeros</span>(<span class="built_in">size</span>(<span class="built_in">reshape</span>(A,<span class="number">3</span>,<span class="number">2</span>)))  //把矩阵A变为三行两列的矩阵并产生和改变后的矩阵A相同的大小的零矩阵</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>ones函数：产生全1矩阵，即幺矩阵</p></li><li><p>eye函数：产生对角线为1的矩阵，当矩阵是方阵时，得到一个单位矩阵</p></li><li><p>rand函数：产生（0，1）区间均匀分布的随机矩阵</p></li><li><p>randn函数：产生均值为0，方差为1的标准正太分布随机矩阵</p></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//首先产生<span class="number">5</span>阶两位随机整数矩阵A，再产生均值为<span class="number">0.6</span>，方差为<span class="number">0.1</span>的<span class="number">5</span>阶正太分布矩阵B，最后验证(A+B)I=IA+BI(I为单位矩阵)</span><br><span class="line">//<span class="built_in">rand</span>函数：产生（<span class="number">0</span>，<span class="number">1</span>）区间均匀分布的随机数</span><br><span class="line">//<span class="built_in">fix</span>(a+(b-a+<span class="number">1</span>)*x):产生[a,b]区间上均匀分布的随机整数</span><br><span class="line">//<span class="built_in">rand</span>函数:产生均值为<span class="number">0</span>，方差为<span class="number">1</span>的标准正太分布随机矩阵</span><br><span class="line">//μ+σx:得到均值为μ，方差为σ^<span class="number">2</span>的随机数</span><br><span class="line">&gt;&gt;A=<span class="built_in">fix</span>(<span class="number">10</span>+(<span class="number">99</span><span class="number">-10</span>+<span class="number">1</span>)*<span class="built_in">rand</span>(<span class="number">5</span>)); //产生<span class="number">5</span>行<span class="number">5</span>列的矩阵其值时<span class="number">10</span>到<span class="number">99</span>之间的矩阵A</span><br><span class="line">&gt;&gt;B=<span class="number">0.6</span>+<span class="built_in">sqrt</span>(<span class="number">0.1</span>)*<span class="built_in">randn</span>(<span class="number">5</span>);  //产生均值为<span class="number">0.6</span>方差为<span class="number">0.1</span>的<span class="number">5</span>行<span class="number">5</span>列的正态分布随机矩阵矩阵B</span><br><span class="line">&gt;&gt;C=<span class="built_in">eye</span>(<span class="number">5</span>);  //产生<span class="number">5</span>阶单位阵</span><br><span class="line">&gt;&gt;(A+B)*C==C*A+B*C</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="用于专门学科的特殊矩阵">用于专门学科的特殊矩阵</h3><ul><li>魔方矩阵<ul><li>n阶魔方阵由1，2，3……n<sup>2共n</sup>2个整数组成，且每行，每列以及主副对角线上各n个元素之和都相等</li><li>n阶魔方阵每行每列元素的和为(1+2+3+……+n<sup>2)/n=(n+n</sup>3)/2</li><li>MATLAB函数magic(n)产生一个特定的魔方阵</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//产生<span class="number">8</span>阶魔方阵，求其每行每列元素的和</span><br><span class="line">&gt;&gt;M=<span class="built_in">magic</span>(<span class="number">8</span>);</span><br><span class="line">&gt;&gt;sum(M(<span class="number">1</span>,:));</span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">260</span></span><br><span class="line">&gt;&gt;sum(M(:,<span class="number">1</span>))</span><br><span class="line"><span class="built_in">ans</span>=</span><br><span class="line">  <span class="number">260</span></span><br></pre></td></tr></table></figure><ul><li><p>范德蒙矩阵</p><ul><li><imgsrc="https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_170619.jpg" /></li><li><imgsrc="https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_170604.jpg" /></li></ul></li><li><p>希尔伯特矩阵</p><p><imgsrc="https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_170954.jpg" /></p></li></ul><h2 id="矩阵变换">矩阵变换</h2><ul><li><p>对角阵</p><ul><li><p>对角矩阵：只有对角线上有非零元素的矩阵</p></li><li><p>数量矩阵：对角线上的元素相等的对角矩阵</p></li><li><p>单位矩阵：对角线上的元素都为1的矩阵</p><ul><li><h5 id="提取矩阵的对角线元素">提取矩阵的对角线元素</h5></li><li><h6id="规定与主对角线平行向上为第1条对角线向下为第-1条主对角线为第0条对角线">规定与主对角线平行向上为第1条对角线，向下为第-1条，主对角线为第0条对角线</h6></li><li><p>diag(A):提取矩阵A主对角线元素，产生一个列向量</p></li><li><p>diag(A,k):提取矩阵A第k条对角线的元素，产生一个列向量</p></li><li><h5 id="构造对角矩阵">构造对角矩阵</h5></li><li><p>diag(V):以向量V为主对角线元素，产生对角矩阵</p></li><li><p>diag(V,k):以向量V为第k条对角线元素，产生对角矩阵</p></li><li><p>```matlab//先建立5×5矩阵A，然后将A的第一行元素乘以1，第二行元素乘以2……，第五行乘以5//方法：提取一个列向量，元素为1，2，3……5，接着让这个列向量的第一行的第一个元素乘以A的第一行，第二行第二个元素乘以A的第二行…………即让这个列向量左乘矩阵A&gt;&gt;A=[7,0,1,0,5;3,5,7,4,1;4,0,3,0,2;1,1,9,2,3;1,8,5,2,9] A= 7 0 1 05 3 5 7 4 1 4 0 3 0 2 1 1 9 2 3 1 8 5 2 9 &gt;&gt;D=diag(1;5)&gt;&gt;D*A ans= 7 0 1 0 5 6 10 14 8 2 12 0 9 0 6 4 4 36 8 12 5 40 25 1045 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```matlab</span><br><span class="line">  //要将A的各列元素分别乘以对角阵的对角线元素，如何实现?  右乘矩阵</span><br><span class="line">  &gt;&gt;A=[7,0,1,0,5;3,5,7,4,1;4,0,3,0,2;1,1,9,2,3;1,8,5,2,9]</span><br><span class="line">  A=</span><br><span class="line">    7 0 1 0 5 </span><br><span class="line">    3 5 7 4 1 </span><br><span class="line">    4 0 3 0 2</span><br><span class="line">    1 1 9 2 3 </span><br><span class="line">    1 8 5 2 9</span><br><span class="line">  &gt;&gt;D=diag(1:5);</span><br><span class="line">  &gt;&gt;A*D</span><br><span class="line">  ans=</span><br><span class="line">    7  0  3  0 25</span><br><span class="line">    3 10 21 16  5</span><br><span class="line">    4  0  9  0 10</span><br><span class="line">    1  2 27  8 15</span><br><span class="line">    1 16 15  8 45</span><br></pre></td></tr></table></figure></p></li></ul></li></ul></li><li><p>三角阵</p><ul><li><p>上三角矩阵</p><ul><li><p>triu(A):提取矩阵A的主对角线以及以上元素</p></li><li><p>triu(A,k):提取矩阵A的第k条对角线及以上的元素</p></li><li><p>```matlab &gt;&gt;triu(ones(4),-1) ans= 1 1 1 1 1 1 1 1 0 1 1 1 00 1 1 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 下三角矩阵</span><br><span class="line"></span><br><span class="line">    - tril函数和triu用法一样</span><br><span class="line"></span><br><span class="line">### 矩阵转置</span><br><span class="line"></span><br><span class="line">- 转置运算符是小数点后面接单引号(.&#x27;)</span><br><span class="line">- 共轭转置，其运算符是单引号(&#x27;),它在转置的基础上还要取每个数的复共轭</span><br><span class="line">- ![](https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_174731.jpg)</span><br><span class="line"></span><br><span class="line">### 矩阵的旋转和旋转（上下翻转后主副对角线互换）</span><br><span class="line"></span><br><span class="line">![](https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_174757.jpg)</span><br><span class="line"></span><br><span class="line">![](https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_174844.jpg)</span><br><span class="line"></span><br><span class="line">![](https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/Screenshot_20230729_175149.jpg)</span><br><span class="line"></span><br><span class="line">### 矩阵求逆（inv函数）</span><br><span class="line"></span><br><span class="line">![](https://cdn.staticaly.com/gh/pipi1002/markdown_pic@main/qq_pic_merged_1690624552843.jpg)</span><br><span class="line"></span><br><span class="line">```matlab</span><br><span class="line">&gt;&gt;A=[1,2,3;1,4,9;1,8,27];</span><br><span class="line">&gt;&gt;b=[5;-2;6];</span><br><span class="line">&gt;&gt;x=inv(A)*b</span><br><span class="line">x=</span><br><span class="line">  23.0000</span><br><span class="line"> -14.5000</span><br><span class="line">  3.6667</span><br><span class="line">  </span><br><span class="line">//也可以用左除运算符  </span><br><span class="line">&gt;&gt;x=A\b</span><br><span class="line">x=</span><br><span class="line">  23.0000</span><br><span class="line"> -14.5000</span><br><span class="line">  3.6667</span><br></pre></td></tr></table></figure></p></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;matlab-的学习&quot;&gt;Matlab 的学习&lt;/h1&gt;
&lt;h2 id=&quot;matlab系统环境&quot;&gt;matlab系统环境&lt;/h2&gt;
&lt;h6 id=&quot;matlab的搜索路径为&quot;&gt;matlab的搜索路径为：&lt;/h6&gt;
&lt;p&gt;变量，内部函数，程序文件（先搜索当前文件再</summary>
      
    
    
    
    <category term="数学建模学习" scheme="https://pipi1002.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ mistakes</title>
    <link href="https://pipi1002.github.io/2023/05/04/C++mistakes/"/>
    <id>https://pipi1002.github.io/2023/05/04/C++mistakes/</id>
    <published>2023-05-04T04:41:44.000Z</published>
    <updated>2024-02-27T13:11:11.841Z</updated>
    
    <content type="html"><![CDATA[<h2id="关于函数下列表述错误的是">1.关于函数<返回值类型>,下列表述错误的是：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A &lt;返回类型&gt;中有可能包含关键字<span class="type">int</span></span><br><span class="line">B &lt;返回类型&gt;中有可能包含自定义标识符  <span class="comment">//B</span></span><br><span class="line">C &lt;返回类型&gt;中有可能包含字符 *</span><br><span class="line">D &lt;返回类型&gt;中有可能包含 []</span><br></pre></td></tr></table></figure><p>注意：这里的类型可以是预定义类型（如int），复合类型（如double*），用户自定义类型（如枚举类），若返回值只做更新（或设置）等操作，则该函数返回类型是void，<code>函数类型和内置数组不能作为返回值类型</code></p><h2 id="程序阅读">2.程序阅读</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> a = <span class="number">10</span>, b = <span class="number">30</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>) a++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> m=a;m&lt;=b;m+=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fun</span>(m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l++ % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fun</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sqrtm = (<span class="type">int</span>)<span class="built_in">sqrt</span>(n);  <span class="comment">//sprt:求参数的平方根，并且其参数是一个double类型，返回值也是double类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqrtm; i++)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//11 ，13 ，17 ，19 ，23 ，29</span></span><br></pre></td></tr></table></figure><h2id="假定一个类的构造函数为aint-i4int-j0ainj则执行a-x1语句后x.a和x.b的值分别为">3.假定一个类的构造函数为“A（inti=4，int j=0）{a=i;n=j;}”,则执行"Ax(1);"语句后，x.a和x.b的值分别为（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A <span class="number">1</span>和<span class="number">0</span></span><br><span class="line">B <span class="number">1</span>和<span class="number">4</span></span><br><span class="line">C <span class="number">4</span>和<span class="number">0</span></span><br><span class="line">D <span class="number">4</span>和<span class="number">1</span></span><br><span class="line"><span class="comment">//带默认的构造函数，对应实参没有值时就采用形参值。调用构造函数时，i=1，不采用默认值，而只有一个参数，j采用默认值0，因此a=1，b=0；</span></span><br></pre></td></tr></table></figure><h2id="派生类构造函数的成员初始化列表中不能包含的初始化项是">4.派生类构造函数的成员初始化列表中，不能包含的初始化项是：</h2><p><code>A：</code>基类的构造函数</p><p><code>B：</code>基类的子对象 //B</p><p><code>C：</code>派生类的子对象</p><p><code>D：</code>派生类自身的数据成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为在C++中，构造函数不能被继承，因此，派生类的构造函数必须通过调用基类的构造函数来初始化基类子对象（在派生类初始化列表直接初始化基类的成员，被称为“越级初始化”）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//基类的子对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> temp):<span class="built_in">n</span>(temp)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//    B(int temp):n(temp)&#123;&#125;   对基类子对象进行初始化“越级初始化”</span></span><br><span class="line">    <span class="comment">//但是可以&quot;越级赋值&quot;</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> temp)&#123;n=temp&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">B</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="多继承派生类构造函数构造对象时b被最先调用">5.多继承派生类构造函数构造对象时，（B）被最先调用</h2><p><code>A:</code>派生类自己的构造函数</p><p><code>B:</code>虚基类的构造函数</p><p><code>C:</code>非虚基类的构造函数</p><p><code>D:</code>派生类中子对象类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先调用（构造函数）所有基类的构造函数；再调用派生类中子对象类的构造函数（如派生类的子对象）（在一个类中内嵌另一个类的对象作为数据成员,称为类的组合。该内嵌对象称为对象成员,也称为子对象。）</span></span><br><span class="line">；最后调用派生类构造函数</span><br><span class="line"><span class="comment">//`注意`：处于同一层次的各基类构造函数的调用顺序取决于派生类所指定的的基类顺序，与派生类构造函数中所定义的成员函数初始化无关</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">        a=i;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Constructing Base1 a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">        b=i;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Constructing Base1 b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derivedclass</span>:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derivedclass</span>(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line">Derivedclass::<span class="built_in">Derivedclass</span>(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k):<span class="built_in">Base2</span>(i),<span class="built_in">Base1</span>(j)  <span class="comment">//先调用Base1再调用Base2，虽然在初始化列表顺序中，先调用了Base2再调用了Base1，但是根据前文介绍先调用Base1</span></span><br><span class="line">&#123;</span><br><span class="line">    d=k;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Constructing Derivedcalss d=&quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derivedcalss <span class="title">x</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果派生类有一个虚基类作为祖先类，那么在派生类构造函数的初始化列表中需要对虚基类构造函数的调用，如果未列出则表明用的是虚基类的无参构造函数</span></span><br><span class="line"><span class="comment">//注意：不管初始化列表中次序如何，对虚基类构造函数的调用总是先于普通基类的构造函数（虚基类的唯一副本只被初始化一次）</span></span><br><span class="line">例如；</span><br><span class="line">    带有基类的多层派生类构造函数的成员初始化列表中都要列出虚基类的构造函数，这样将对虚基类的子对象初始化<span class="number">1</span>次</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()&#123;cout&lt;&lt;<span class="string">&quot;Constructing Base1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()&#123;cout&lt;&lt;<span class="string">&quot;Constructing Base2&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span>:<span class="keyword">public</span> Base2,<span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>()&#123;cout&lt;&lt;<span class="string">&quot;Constructing Derived1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span>:<span class="keyword">public</span> Base2,<span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>()&#123;cout&lt;&lt;<span class="string">&quot;Constructing Derived2&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span>:<span class="keyword">public</span> Derived1,<span class="keyword">virtual</span> <span class="keyword">public</span> Derived2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>()&#123;cout&lt;&lt;<span class="string">&quot;Constructing Derived3&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived3 obj;</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line">Constructing Base1</span><br><span class="line">Constructing Base2</span><br><span class="line">Constructing Derived2</span><br><span class="line">Constructing Base2</span><br><span class="line">Constructing Derived1</span><br><span class="line">Constructing Derived3</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有多个子对象的类的构造函数如何定义</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">X</span> &#123;</span><br><span class="line">   类名<span class="number">1</span>  对象成员名<span class="number">1</span>;</span><br><span class="line">   类名<span class="number">2</span>  对象成员名<span class="number">2</span>;</span><br><span class="line">           …</span><br><span class="line">   类名n  对象成员名n;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">//则类X的构造函数应该这样定义</span></span><br><span class="line">X∷<span class="built_in">X</span>(参数表<span class="number">0</span>)：对象成员名<span class="number">1</span>(参数表<span class="number">1</span>)，对象成员名<span class="number">2</span></span><br><span class="line">       (参数表<span class="number">2</span>)，…，对象成员名<span class="built_in">n</span>(参数表n) </span><br><span class="line">  &#123;</span><br><span class="line">     类X的构造函数体</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//参数表1、参数表2 、… 、参数表n的数据，一般来自参数表0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用构造函数D∷D( )时:</span></span><br><span class="line"><span class="comment">   首先按各对象成员在类定义中的顺序依次调用它们的构造函数，对这些对象初始化。</span></span><br><span class="line"><span class="comment">   最后再执行D∷D( )的函数体。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//撤销类D的对象d1时,调用析构函数的调用顺序与调用构造函数的顺序相反。</span></span><br></pre></td></tr></table></figure><h2 id="程序阅读题">6.程序阅读题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>(<span class="type">int</span> i) &#123; cout &lt;&lt; i; &#125;</span><br><span class="line">  ~<span class="built_in">Base</span> () &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base1</span>(<span class="type">int</span> i, <span class="type">int</span> j=<span class="number">0</span>) : <span class="built_in">Base</span>(j) &#123; cout &lt;&lt; i; &#125;</span><br><span class="line">  ~<span class="built_in">Base1</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base2</span>(<span class="type">int</span> i, <span class="type">int</span> j=<span class="number">0</span>) : <span class="built_in">Base</span>(j) &#123; cout &lt;&lt; i; &#125;</span><br><span class="line">  ~<span class="built_in">Base2</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d) : <span class="built_in">mem1</span>(a), <span class="built_in">mem2</span>(b), <span class="built_in">Base1</span>(c), </span><br><span class="line">                                         <span class="built_in">Base2</span>(d), <span class="built_in">Base</span>(a) </span><br><span class="line">    &#123; cout &lt;&lt; b; &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  Base2 mem2;</span><br><span class="line">  Base1 mem1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="function">Derived <span class="title">objD</span> <span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14302012</span></span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272111814.png"alt="CSDN_1683445174034" /><figcaption aria-hidden="true">CSDN_1683445174034</figcaption></figure><h2 id="不能在类声明中给成员赋值">7.不能在类声明中给成员赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">abc</span> </span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> a=<span class="string">&#x27;q&#x27;</span>; <span class="comment">//错误     </span></span><br><span class="line"><span class="type">int</span>  b=<span class="number">33</span>; <span class="comment">//错误     </span></span><br><span class="line"><span class="keyword">public</span>:       </span><br><span class="line">    … </span><br><span class="line">&#125;;</span><br><span class="line">   <span class="comment">// C++规定，只有在对象定义之后才能给数据成员赋初值</span></span><br></pre></td></tr></table></figure><p>注意：<code>声明了一个类便声明了一种类型，这时没有给它分配存储空间，只有定义了对象后，系统才为对象分配存储空间</code></p><h2id="数据成员是按照它们在类中声明的顺序进行初始化的与它们在成员初始化列表中列出的顺序无关">8.数据成员是按照它们在类中声明的顺序进行初始化的,与它们在成员初始化列表中列出的顺序无关</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">   <span class="type">int</span> mem1;</span><br><span class="line">   <span class="type">int</span> mem2;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">D</span>(<span class="type">int</span> i):<span class="built_in">mem1</span>(i),<span class="built_in">mem2</span>(mem1+<span class="number">1</span>)</span><br><span class="line">   &#123; cout&lt;&lt;<span class="string">&quot;mem1: &quot;</span>&lt;&lt;mem1&lt;&lt;endl;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;mem2: &quot;</span>&lt;&lt;mem2&lt;&lt;endl; &#125; &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  <span class="function">D <span class="title">d</span><span class="params">(<span class="number">15</span>)</span></span>; &#125; </span><br><span class="line"><span class="comment">//运行结果为 mem1: 15 mem2: 16</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">D</span> &#123;</span><br><span class="line">   <span class="type">int</span> mem1;</span><br><span class="line">   <span class="type">int</span> mem2;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">D</span>(<span class="type">int</span> i):<span class="built_in">mem2</span>(i),<span class="built_in">mem1</span>(mem2+<span class="number">1</span>)</span><br><span class="line">   &#123; cout&lt;&lt;<span class="string">&quot;mem1: &quot;</span>&lt;&lt;mem1&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;mem2:&quot;</span>&lt;&lt;mem2&lt;&lt;endl; &#125; &#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;  <span class="function">D <span class="title">d</span><span class="params">(<span class="number">15</span>)</span></span>; &#125; </span><br><span class="line"><span class="comment">//注意：运行结果为 mem1: 858993459 mem2: 15</span></span><br><span class="line"><span class="comment">//初始化过程:</span></span><br><span class="line"><span class="number">1.</span>mem1=mem2+<span class="number">1</span>=随机数</span><br><span class="line"><span class="number">2.</span>mem2=i=<span class="number">15</span></span><br></pre></td></tr></table></figure><h2id="在一个类中定义了全部是默认参数的构造函数后-不能同时再声明无参数的默认构造函数或其他重载构造函数">9.在一个类中定义了全部是默认参数的构造函数后,不能同时再声明无参数的默认构造函数，或其他重载构造函数。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个类中有以下构造函数的声明:</span></span><br><span class="line">   <span class="built_in">Box</span>(<span class="type">int</span> h=<span class="number">10</span>,<span class="type">int</span> w=<span class="number">10</span>,<span class="type">int</span> len=<span class="number">10</span>); </span><br><span class="line"><span class="comment">//就不能再声明无参数的构造函数：</span></span><br><span class="line">   <span class="built_in">Box</span>( ); </span><br><span class="line"><span class="comment">//否则,如用下面的语句建立对象</span></span><br><span class="line">   Box box1;</span><br><span class="line"><span class="comment">//box1不知道调用哪个构造函数，会产生二义性</span></span><br></pre></td></tr></table></figure><h2 id="对象数组">10.对象数组</h2><p>定义一维对象数组的格式如下:</p><p><code>类名 数组名[下标表达式];</code></p><p>例如:</p><p>exam ob[4];</p><h6id="说明共建立了四个对象即每一个数组元素是一个对象即ob0ob1ob2-ob3共调用了4次构造函数">说明：共建立了四个对象,即每一个数组元素是一个对象(即ob[0]、ob[1]、ob[2]、ob[3])，共调用了4次构造函数。</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span>    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exam</span>&#123;</span><br><span class="line">    <span class="type">int</span> x; </span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">exam</span>( )&#123; x=<span class="number">123</span>;&#125;</span><br><span class="line">  <span class="built_in">exam</span>(<span class="type">int</span> n) &#123; x=n;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;&#125;;      </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  exam ob[<span class="number">4</span>]=&#123;<span class="number">55</span>,<span class="number">66</span>&#125;;   <span class="comment">//ob[0]和ob[1]调用带参构造函数，ob[2]和ob[3]调用无参构造函数</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cout&lt;&lt;ob[i].<span class="built_in">get_x</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;  &#125;</span><br><span class="line"><span class="comment">//55 66 123 123</span></span><br></pre></td></tr></table></figure><h2 id="对象指针">11.对象指针</h2><p>声明对象指针的一般语法形式为:</p><p><code>类名* 对象指针名;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setRec</span><span class="params">(<span class="type">int</span> len,<span class="type">int</span> wid)</span>      </span></span><br><span class="line"><span class="function">  </span>&#123; length=len; width=wid; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span> </span>&#123;  cout&lt;&lt;length&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;width&lt;&lt;endl; &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> length,width; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; Rectangle rec ;        <span class="comment">//定义类Rectangle 的对象rec</span></span><br><span class="line">  Rectangle *pr;         <span class="comment">//定义pr为指向类Rectangle的对象指针变量</span></span><br><span class="line">  rec.<span class="built_in">setRec</span>(<span class="number">20</span>,<span class="number">30</span>);     <span class="comment">//调用对象rec中的函数setRec</span></span><br><span class="line">  pr=&amp;rec;               <span class="comment">// 将对象rec的起始地址赋给pr</span></span><br><span class="line">  pr-&gt;<span class="built_in">disp</span>();    <span class="comment">// 调用pr所指向的对象rec中的函数disp；用对象指针访问对象成员时，不能用“.”操作符，而应使用“-&gt; ”操作符</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;   &#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下:</span><br><span class="line"><span class="number">20</span> <span class="number">30</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2id="静态数据成员的应用在类student中声明数据成员count希望每定义一个对象count加1从而达到统计学生的总数的目的">12.静态数据成员的应用（在类Student中，声明数据成员count，希望每定义一个对象count加1，从而达到统计学生的总数的目的。）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span>      </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">int</span> count;          <span class="comment">//声明数据成员count，表示学生数,用于统计学生的总数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Student</span>( ) &#123; count++;  &#125;  <span class="comment">//   构造函数,希望每定义一个学生对象，学生数count加1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span>              <span class="comment">// 成员函数，显示当前学生数</span></span></span><br><span class="line"><span class="function"> </span>&#123;  cout&lt;&lt;<span class="string">&quot;count= &quot;</span>&lt;&lt; count &lt;&lt;endl;  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"> <span class="built_in">main</span>( )</span><br><span class="line"> &#123; <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">   Student Stu1;  <span class="comment">//定义第1个学生对象Stu1,第1次调用构造函数</span></span><br><span class="line">   Student Stu2;  <span class="comment">//定义第2个学生对象Stu2,第2次调用构造函数</span></span><br><span class="line">   Stu1.<span class="built_in">print</span>();</span><br><span class="line">   Stu2.<span class="built_in">print</span>();  <span class="comment">//希望打印的结果为：count=2 count=2  实际打印的结果为： count= -858993459 count= -858993459</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//注意：出现错误的原因是:</span></span><br><span class="line"><span class="comment">// count  Stu1.count  Stu2,count  三者是独立的，互不相干  </span></span><br><span class="line"><span class="comment">//    一个学生对象的count仅仅属于这个学生对象,而不是所有学生对象所共享的,因此count不能表示所有学生的总人数。</span></span><br><span class="line"><span class="comment">// 解决方法：   为了实现同一个类的多个对象之间的数据共享,C++提出了静态数据成员的概念。 </span></span><br></pre></td></tr></table></figure><h6 id="更改后为">更改后为：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span>      </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count;     <span class="comment">//声明静态数据成员count，被所有的对象共享, 用于统计学生的总数                       </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Student</span>()&#123; count++;&#125;     <span class="comment">//构造函数,每创建一个学生对象,学生数count加1</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;  cout&lt;&lt;<span class="string">&quot;count= &quot;</span>&lt;&lt; count &lt;&lt;endl;  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::count=<span class="number">0</span>;   <span class="comment">//给静态数据成员count赋初值0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; Student Stu1; <span class="comment">//定义第1个学生对象Stu1,第1次调用构造函数Student Stu2;    //定义第2个学生对象Stu1,第2次调用构造函数</span></span><br><span class="line">  Stu1.<span class="built_in">print</span>();      </span><br><span class="line">  Stu2.<span class="built_in">print</span>();   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure><ol type="1"><li>静态数据成员属于类(准确地说，是属于类中一个对象集合)，而不像普通数据成员那样属于某一对象，因此可以使用“类名∷”访问静态的数据成员。用类名访问静态数据成员的格式如下:</li></ol><p>​ 类名::静态数据成员名</p><ol start="2" type="1"><li>静态数据成员初始化应在类外单独进行,而且应在定义对象之前进行。一般在主函数main之前,类声明之后的特殊地带为它提供定义和初始化（如果末对静态数据成员赋初值,则编译系统会自动赋予初值0）</li><li>公有静态数据成员可以在对象定义之前被访问</li><li>公有静态数据成员可通过对象进行访问</li></ol><h2 id="调用拷贝构造函数的时机">13.调用拷贝构造函数的时机</h2><h3id="下列情况中哪种情况不会调用拷贝构造函数">下列情况中，哪种情况不会调用拷贝构造函数</h3><ul class="task-list"><li><label><inputtype="checkbox" />用派生类的对象去初始化该基类对象时</label></li><li><label><input type="checkbox"checked="" /><em>将类的一个对象赋值给该类的另一个对象时</em></label></li><li><label><inputtype="checkbox" />函数的形参是类的对象，调用函数进行形参和实参结合时</label></li><li><label><inputtype="checkbox" />函数的返回值是类的对象，调用函数进行形参和实参结合时</label></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将类的一个对象赋值给该类的另一个对象时，不用调用拷贝构造函数，是用赋值运算符重载实现的：</span></span><br><span class="line"><span class="function">MyClass <span class="title">a</span><span class="params">(b)</span></span>;</span><br><span class="line">或者 MyClass a=b;<span class="comment">//就会调用 赋值重载 operator=来赋值，对象a已经存在了，调用普通的赋值运算符就可以了，不用再调用构造函数</span></span><br></pre></td></tr></table></figure><ul><li>程序中需要创建一个新的对象，并用另一个对象对它初始化</li><li>函数的参数为类的对象</li><li>函数的返回值是类的对象</li></ul><h2 id="下列关于对象的描述错误的是">14.下列关于对象的描述错误的是</h2><ul class="task-list"><li><label><inputtype="checkbox" />定义对象时系统会自动进行初始化</label></li><li><label><inputtype="checkbox" />对象成员的表示与C语言中结构变量的成员表示相同</label></li><li><label><inputtype="checkbox" />属于同一个类的对象占有内存字节数相同</label></li><li><label><input type="checkbox"checked="" />一个类所能创建对象的个数是有限制的</label></li></ul><h2 id="程序阅读题-1">15.程序阅读题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="built_in">point</span>()&#123;number++;&#125;</span><br><span class="line">    ~<span class="built_in">point</span>()&#123;number--;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> point::number=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point *ptr;<span class="comment">//指针不会调用构造函数和析构函数，只是定义了一个指针，没有申请内存</span></span><br><span class="line">    point A,B;<span class="comment">// +2</span></span><br><span class="line">    &#123;</span><br><span class="line">        point *ptr_point=<span class="keyword">new</span> point[<span class="number">3</span>];<span class="comment">//使用new创建对象时，申请分配内存，调用构造函数  +3</span></span><br><span class="line">        ptr=ptr_point;</span><br><span class="line">    &#125;</span><br><span class="line">    point C;  <span class="comment">// +1</span></span><br><span class="line">    <span class="keyword">delete</span>[]ptr; <span class="comment">//释放空间会调用构造函数  -3</span></span><br><span class="line">    cout&lt;&lt;point::number&lt;&lt;endl;  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Point *ptr_point = new Point[3];动态创建3个对象实例，调用默认构造函数3次。而ptr=ptr_point语句让ptr指向ptr_point动态数组，不会调用构造函数。ptr_point指针本身被释放的时，不会销毁指向的实例。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">CT</span>  &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> <span class="built_in">CT</span> () &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Default constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">CT</span> (<span class="type">const</span> CT &amp;rhs) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> CT ct;</span><br><span class="line"> CT *p;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Step1&quot;</span> &lt;&lt; endl;</span><br><span class="line"> p = <span class="keyword">new</span> CT;     <span class="comment">//动态创建一个对象实例，调用默认构造函数1次</span></span><br><span class="line"> <span class="function">CT <span class="title">ct3</span> <span class="params">(*p)</span></span>;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Step2&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">delete</span> p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Default constructor called </span></span><br><span class="line"><span class="comment">//Step1</span></span><br><span class="line"><span class="comment">//Default constructor called</span></span><br><span class="line"><span class="comment">//Copy constructor called</span></span><br><span class="line"><span class="comment">//Step2</span></span><br></pre></td></tr></table></figure><h2 id="理解int-p3和int-p3的意思">16.理解int(* p)[3]和int*p[3]的意思</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列程序输出结果是:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n[][<span class="number">3</span>]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span>(*p)[<span class="number">3</span>];</span><br><span class="line">    p=n;</span><br><span class="line">    cout&lt;&lt;p[<span class="number">0</span>][<span class="number">0</span>]&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;*(p[<span class="number">0</span>]+<span class="number">1</span>)&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;(*p)[<span class="number">2</span>]&lt;&lt;endl; <span class="comment">//10，20，30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int(*p)[3]数组指针，p是一个指针，指向一个有3个变量的一维数组</span></span><br><span class="line"><span class="comment">//int *p[3]指针数组，p是一个有三个元素的数组，每个元素的类型都是整形指针</span></span><br><span class="line"><span class="comment">//因为定义数组[]的优先级高于定义指针*的优先级</span></span><br></pre></td></tr></table></figure><h2 id="程序阅读-1">17.程序阅读</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>; &#125;  <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Base</span>(<span class="type">char</span> c) &#123; cout &lt;&lt; c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Derived</span>(<span class="type">char</span> c) &#123; cout &lt;&lt; c; &#125;   <span class="comment">//派生类构造函数中无基类参数表则调用无参的基类构造函数  //2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Derived <span class="title">d1</span><span class="params">(<span class="string">&#x27;B&#x27;</span>)</span></span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AB</span></span><br></pre></td></tr></table></figure><h2id="带有基类的多层派生类构造函数的成员初始化列表中都要列出虚基类的构造函数这样将对虚基类的子对象初始化">18.带有基类的多层派生类构造函数的成员初始化列表中都要列出虚基类的构造函数，这样将对虚基类的子对象初始化（）</h2><ul class="task-list"><li><label><inputtype="checkbox" />与虚基类下面的派生类个数有关</label></li><li><label><input type="checkbox" />多次</label></li><li><label><input type="checkbox" />二次</label></li><li><label><input type="checkbox" checked="" />一次</label></li></ul><h2 id="程序阅读-2">19.程序阅读</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> i) :<span class="built_in">a</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A:constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A:Destructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> i = <span class="number">0</span>, <span class="type">int</span> j = <span class="number">0</span>) :<span class="built_in">A</span>(i),<span class="built_in">a</span>(j), <span class="built_in">b</span>(i + j)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B:Constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">B</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B:Destructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A::<span class="built_in">Print</span>();</span><br><span class="line">cout &lt;&lt; b &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; a.<span class="built_in">Geta</span>()&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">A a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">B <span class="title">b1</span><span class="params">(<span class="number">8</span>)</span>, <span class="title">b2</span><span class="params">(<span class="number">12</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">b1.<span class="built_in">Print</span>();</span><br><span class="line">b2.<span class="built_in">Print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">A:constructor called.</span></span><br><span class="line"><span class="comment">A:constructor called.</span></span><br><span class="line"><span class="comment">B:Constructor called.</span></span><br><span class="line"><span class="comment">A:constructor called.</span></span><br><span class="line"><span class="comment">A:constructor called.</span></span><br><span class="line"><span class="comment">B:Constructor called.</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">8,0</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">27,15</span></span><br><span class="line"><span class="comment">B:Destructor called.</span></span><br><span class="line"><span class="comment">A:Destructor called.</span></span><br><span class="line"><span class="comment">A:Destructor called.</span></span><br><span class="line"><span class="comment">B:Destructor called.</span></span><br><span class="line"><span class="comment">A:Destructor called.</span></span><br><span class="line"><span class="comment">A:Destructor called.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">test</span>(<span class="type">int</span> i=<span class="number">0</span>):<span class="built_in">x</span>(i)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;text::x&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ft</span> :<span class="keyword">public</span> test</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ft::y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ft</span>(<span class="type">int</span> i=<span class="number">2</span>):<span class="built_in">test</span>(i),<span class="built_in">y</span>(i)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ft <span class="title">ft1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span>(test:: * p)();</span><br><span class="line">p = test::fun1;  <span class="comment">//p指向fun1函数</span></span><br><span class="line">(ft1.* p)();   <span class="comment">//（ft1.*p）实际上就算调用ft1对象的fun1（）函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ft::y=3</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::~A() called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span>* buf;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">buf = <span class="keyword">new</span> <span class="type">char</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">B</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]buf;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::~B() called&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(A* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">fun</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B::~B() called</span></span><br><span class="line"><span class="comment">//A::~A() called</span></span><br></pre></td></tr></table></figure><h2 id="运算符的使用">20.运算符的使用</h2><h3 id="插入符-和-提取符">插入符&lt;&lt; 和 提取符&gt;&gt;</h3><p>下列关于C++程序中使用提取符和插入符的输入/输出语句的描述中，错误的是（C）</p><ul class="task-list"><li><label><inputtype="checkbox" />提取符是对右移运算符（&gt;&gt;）重载得到的</label></li><li><label><inputtype="checkbox" />插入符是对左移运算符（&lt;&lt;）重载得到的</label></li><li><label><input type="checkbox"checked="" />提取符和插入符都是双目运算符，它们要求有两个操作数</label></li><li><label><inputtype="checkbox" />提取符和插入符在输入/输出语句中不可以连用</label></li></ul><h6id="注意操作数是指参与运算操作的源数据通常由指令的地址部分标识出来-提取符和插入符都是单目运算符">注意:操作数是指，参与运算操作的源数据，通常由指令的地址部分标识出来提取符和插入符都是单目运算符</h6><h3 id="不能用浮点数操作的运算符">不能用浮点数操作的运算符</h3><p>1.&amp; 双目</p><p>2.%</p><p>3.== !=</p><h3 id="类型转换运算符的使用">类型转换运算符的使用</h3><ul class="task-list"><li><label><inputtype="checkbox" />类型转换运算符是(<类型>)</label></li><li><label><inputtype="checkbox" />类型转换运算符是单目运算符</label></li><li><label><input type="checkbox"checked="" />类型转换运算符通常用于保值转换</label></li><li><label><inputtype="checkbox" />类型转换运算符作用与表达式左边</label></li></ul><h6id="注意类型转换运算符通常用于赋值中">注意：类型转换运算符通常用于赋值中</h6><h2 id="返回类型">21.返回类型</h2><p>关于函数中的<返回类型>，下列表述中错误的是（ B ）</p><ul class="task-list"><li><label><inputtype="checkbox" /><返回类型>中有可能包含关键字int</label></li><li><label><input type="checkbox"checked="" /><返回类型>中有可能包含自定义标识符</label></li><li><label><inputtype="checkbox" /><返回类型>中有可能包含字符</label></li><li><label><inputtype="checkbox" /><返回类型>中可能包含［］</label></li></ul><h6id="注意又称函数类型表示一个函数所计算或运行的结果值类型这里的类型可以是预定义类型如int复合类型如double用户定义类型如枚举类若返回值只做更新或设置等操作则该函数返回值类型为void类型函数类型和内置数组不能作为返回类型但类类型可以被直接返回">注意：<返回类型>又称函数类型，表示一个函数所计算（或运行）的结果值类型，这里的类型可以是预定义类型（如int），复合类型（如double*），用户定义类型（如枚举类），若返回值只做更新（或设置）等操作，则该函数返回值类型为void类型，函数类型和内置数组不能作为返回类型，但类类型可以被直接返回</h6><h2 id="虚函数-下列关于虚函数的说明中正确的是-b">22.虚函数下列关于虚函数的说明中，正确的是（ B ）</h2><ul class="task-list"><li><label><inputtype="checkbox" />从虚基类继承的函数都是虚函数</label></li><li><label><input type="checkbox"checked="" />虚函数不得是静态成员函数</label></li><li><label><inputtype="checkbox" />只能通过指针或引用调用虚函数</label></li><li><label><inputtype="checkbox" />抽象类中的成员函数都是虚函数</label></li></ul><h6id="注意1.虚函数是被virtual关键字修饰的成员函数且不能是静态成员函数">注意：1.虚函数是被virtual关键字修饰的成员函数，且不能是静态成员函数</h6><h6id="实现多态性之后不再定义声明继承也为虚函数">2.实现多态性之后不再定义声明，继承也为虚函数</h6><h6id="动态联编只能通过指针或引用标识对象操作虚函数">3.动态联编只能通过指针或引用标识对象操作虚函数</h6><h2id="函数模板关于函数模板描述错误的是">23.函数模板，关于函数模板,描述错误的是（）。</h2><ul class="task-list"><li><label><input type="checkbox"checked="" />函数模板必须由程序员实例化为可执行的函数模板</label></li><li><label><inputtype="checkbox" />函数模板的实例化由编译器实现</label></li><li><label><inputtype="checkbox" />一个类定义中,只要有一个函数模板,则这个类是类模板</label></li><li><label><inputtype="checkbox" />类模板的成员函数都是函数模板,类模板实例化后,成员函数也随之实例化</label></li></ul><h6id="注意成员函数模板当编译器遇到程序中对函数模板的调用是由编译器实例化为可执行的模板函数">注意：成员函数模板当编译器遇到程序中对函数模板的调用是，由<em>编译器</em>实例化为可执行的模板函数</h6><h2id="已知funint是类test的公有成员函数p是指向成员函数fun的指针采用d是正确的">24.已知fun(int)是类Test的公有成员函数，p是指向成员函数fun()的指针，采用（D）是正确的:</h2><ul class="task-list"><li><label><input type="checkbox" />p=fun;</label></li><li><label><input type="checkbox" />p=Test::fun();</label></li><li><label><input type="checkbox" />p=fun();</label></li><li><label><input type="checkbox"checked="" /><strong>p=Test::fun;</strong></label></li></ul><h6id="注意首先fun是类text的成员函数因此在使用时需要加上类名否则当类外有同名的fun函数的时候p将指向类外的fun函数其次fun的函数名代表的是2函数的首地址用首地址赋值给指针变量是正确的而b是缺少实参的函数调用">注意：首先fun是类Text的成员函数，因此在使用时需要加上类名，否则当类外有同名的fun函数的时候，p将指向类外的fun函数。其次，fun的函数名代表的是2函数的首地址，用首地址赋值给指针变量是正确的。而B，是缺少实参的函数调用</h6><h2 id="程序设计结果">25.程序设计结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">num</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;sa[] = &#123; &#123;<span class="number">2</span>,<span class="number">32</span>&#125;,&#123;<span class="number">8</span>,<span class="number">16</span>&#125;,&#123;<span class="number">4</span>,<span class="number">48</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">num</span>* p = sa + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">x = p-&gt;y / sa[<span class="number">0</span>].x * ++p-&gt;x;    <span class="comment">//先计算p-&gt;y=16  sa[0].x=2  所以p-&gt;y/sa[0].x=8  再计算++p-&gt;x 先算p-&gt;x=8再++就x=9 最后计算 8*++p-&gt;x为8*9=72</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;p-&gt;x=&quot;</span> &lt;&lt; p-&gt;x &lt;&lt; endl;  <span class="comment">//x=9  p-&gt;x=72</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> x=<span class="number">3</span>,y=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">switch</span>(x%<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="keyword">switch</span> (y)</span><br><span class="line"> &#123;   <span class="keyword">case</span> <span class="number">0</span>:cout&lt;&lt;<span class="string">&quot;first\t&quot;</span>;   <span class="comment">//\t相当于键盘上的Tab键，通常宽度相当于8个空格的位置</span></span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>:cout&lt;&lt;<span class="string">&quot;second\t&quot;</span>;<span class="keyword">break</span>; </span><br><span class="line"> <span class="keyword">default</span>: cout&lt;&lt;<span class="string">&quot;hellow\t&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:cout&lt;&lt;<span class="string">&quot;third\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//hellow        third</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2
id=&quot;关于函数下列表述错误的是&quot;&gt;1.关于函数&lt;返回值类型&gt;,下列表述错误的是：&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>EXAM-NOTE-C++</title>
    <link href="https://pipi1002.github.io/2023/02/23/EXAM-NOTE-C++/"/>
    <id>https://pipi1002.github.io/2023/02/23/EXAM-NOTE-C++/</id>
    <published>2023-02-23T09:40:52.000Z</published>
    <updated>2024-02-27T13:18:54.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数分文件编写">函数分文件编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建.h后缀名头文件</span><br><span class="line">创建.cpp后缀名源文件</span><br><span class="line">在头文件中写函数的声明</span><br><span class="line">在源文件中写函数的定义</span><br></pre></td></tr></table></figure><h5id="指针在32位机器下86通通占4个字节不管是什么数据类型">指针在32位机器下(×86)通通占4个字节，不管是什么数据类型</h5><h5id="指针在64位机器下通通占8个字节不管是什么数据类型">指针在64位机器下通通占8个字节，不管是什么数据类型</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//指针所在内存空间</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p=&amp;a;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(int *)=&quot;</span><span class="built_in">sizeof</span>(<span class="type">int</span> *)&lt;&lt;endl;  <span class="comment">//4</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(float *)=&quot;</span><span class="built_in">sizeof</span>(<span class="type">float</span> *)&lt;&lt;endl;  <span class="comment">//4</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(double *)=&quot;</span><span class="built_in">sizeof</span>(<span class="type">double</span> *)&lt;&lt;endl; <span class="comment">//4</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(char *)=&quot;</span><span class="built_in">sizeof</span>(<span class="type">char</span> *)&lt;&lt;endl;  <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空指针和野指针">空指针和野指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针：指针变量指向内存中编号为0的空间</span></span><br><span class="line"><span class="comment">//用途：初始化指针变量</span></span><br><span class="line"><span class="comment">//注意：空指针指向的内存是不可以访问的（因为0~ 255的内存是系统占用的，如果访问会报错）</span></span><br><span class="line"><span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//如果*p=100;这样就会冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//野指针(获取访问权限冲突)</span></span><br><span class="line"><span class="comment">//*p=(int *)0×1100;</span></span><br></pre></td></tr></table></figure><p>总结：空指针和野指针都不是我们申请访问的空间，因此不要访问</p><h2 id="const修饰指针">const修饰指针</h2><h5id="const修饰指针-----常量指针-指针指向可以改指针的指向值不可以改">1.const修饰指针-----常量指针指针指向可以改，指针的指向值不可以改</h5><h5id="const修饰常量-----指针常量-指针指向不可以改指针的指向值可以改-引用的本质在c内部实现是一个指针常量引用一旦初始化就不能发生改变变成别的变量的别名所有的指针操作都是编译器做的">2.const修饰常量-----指针常量指针指向不可以改，指针的指向值可以改引用的本质在C++内部实现是一个指针常量(引用一旦初始化就不能发生改变，变成别的变量的别名)所有的指针操作都是编译器做的</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ref=<span class="number">100</span>;<span class="comment">//ref是引用，转换为*ref=100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref=&amp;a;指针常量是指针指向不可以改，也说明为什么引用不可以改</span></span><br><span class="line">    <span class="type">int</span>&amp; ref=a;</span><br><span class="line">    ref=<span class="number">20</span>;<span class="comment">//内部发现ref是引用，自动帮我们转换成:*ref=20;</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ref:&quot;</span>&lt;&lt;ref&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fun</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5id="const既可以修饰指针也可以修饰常量-指针指向和指针的指向都不可以改">3.const既可以修饰指针也可以修饰常量指针指向和指针的指向都不可以改</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;a;</span><br><span class="line">*p=<span class="number">20</span>;  <span class="comment">//错误</span></span><br><span class="line">p=&amp;b;  <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p=&amp;a;</span><br><span class="line">*p=<span class="number">20</span>;  <span class="comment">//正确</span></span><br><span class="line">p=&amp;b;  <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p=&amp;a;</span><br><span class="line">*p=<span class="number">20</span>;  <span class="comment">//错误</span></span><br><span class="line">p=&amp;b;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h3id="结构体中const的使用场景const用来防止误操作">结构体中const的使用场景(const用来防止误操作)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//分数</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数中的形参改为指针，可以减少内存空间，而且不会复制新的副本出来,但是只要在自定义函数中不小心误操作导致s变量的值更改的话，外部结构体变量信息也会更改，所以可以在形参前加一个const，这时候如果再更改结构体的数据时就会提示错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s-&gt;age=150;</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;姓名&quot;</span>&lt;&lt;s.name&lt;&lt;<span class="string">&quot;年龄&quot;</span>&lt;&lt;s.age&lt;&lt;s.age&lt;&lt;<span class="string">&quot;得分：&quot;</span>&lt;&lt;s.score&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void printStudent(student s)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;&quot;姓名&quot;&lt;&lt;s.name&lt;&lt;&quot;年龄&quot;&lt;&lt;s.age&lt;&lt;s.age&lt;&lt;&quot;得分：&quot;&lt;&lt;s.score&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> s=&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">15</span>,<span class="number">70</span>&#125;;</span><br><span class="line">    <span class="comment">//通过函数打印结构体变量的信息</span></span><br><span class="line">    <span class="comment">// printStudents(s);</span></span><br><span class="line">    <span class="built_in">printStudents</span>(&amp;s);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main中张三的年龄为&quot;</span>&lt;&lt;s.age&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常量引用使用场景是-用来修饰形参防止误操作">常量引用：使用场景是用来修饰形参，防止误操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//val=1000;//在形参上加上const就可以防止误操作，这时修改引用的别名就会报错:表达式必须是可以修改的左值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;val=&quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// int &amp;ref=10;//引用必须引一块合法的内存空间，这样的写法是错误的，要么引用栈上的内存空间要么引用堆上的内存空间，而10存放在常量池中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加上const之后 编译器将代码修改 int temp=10;const int &amp; ref=temp;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;ref=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;<span class="comment">//打印a的值</span></span><br><span class="line">    <span class="built_in">showValue</span>(a);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a:&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存分区模型">内存分区模型</h2><ul><li><p>代码区：存放函数体的二进制代码，由操作系统进行管理（共享和只读）</p></li><li><p>全局区：存放全局变量和静态变量以及常量（字符串常量和其他常量，const修饰的变量）（这个区域的数据在程序结束后由操作系统释放）</p><ul><li><p>const修饰的全局变量 int c_g_a=10 //c-const g-global</p></li><li><p>const修饰的局部变量int c_l_b=10 //c-const l-local</p><ul><li><h6id="注意const修饰局部变量是和局部变量放在一起而const修饰的全局变量我们称之为全局常量在全局区内存放">注意：const修饰局部变量是和局部变量放在一起；而const修饰的全局变量，我们称之为全局常量，在全局区内存放</h6></li></ul></li></ul></li><li><p>栈区：由编译器自动分配释放，存放函数的函数值，局部变量等</p></li><li><p>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统自动回收</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//利用new关键字  可以将数据开辟到堆区</span></span><br><span class="line">    <span class="comment">//指针 本质也是局部变量，放在栈上（堆区的地址编号用栈上的指针保存），指针保存的数据是放在堆区</span></span><br><span class="line">    <span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);<span class="comment">//本质是把堆区存放的地址返回给你，利用new创建的数据会返回该数据所对应的类型的指针</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在堆区开辟数据</span></span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">func</span>();</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new操作符">new操作符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.new的基本语法</span></span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在堆区创建整形数据</span></span><br><span class="line">    <span class="comment">//new返回的是 该数据类型的指针</span></span><br><span class="line">    <span class="type">int</span> *p=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">func</span>();</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//堆区的数据由程序员管理开辟，由程序员管理释放</span></span><br><span class="line">    <span class="comment">//如果想释放堆区的数据，利用关键字delete</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2，在堆区利用new开辟一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建10整形数据的数据，在堆区</span></span><br><span class="line">    <span class="type">int</span> * arr=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];<span class="comment">//返回一个首元素地址</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i]=i+<span class="number">100</span>;<span class="comment">//给10个元素赋值 100~109</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       cout&lt;&lt;arr[i]&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放堆区数组 要加[]才可以</span></span><br><span class="line">    <span class="keyword">delete</span>[]arr;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4id="注意代码区和全局区都是程序在运行前的一个区域c中在程序运行前分为全局区和代码区在程序运行后才会有栈区和堆区">注意：代码区和全局区都是程序在运行前的一个区域（C++中在程序运行前分为全局区和代码区），在程序运行后才会有栈区和堆区</h4><h2 id="引用给变量起别名">引用(给变量起别名)</h2><h3 id="数据类型-别名原名">数据类型 &amp;别名=原名</h3><h5 id="引用的注意事项">引用的注意事项：</h5><p>1.引用必须要初始化</p><p>2.引用一旦初始化就不可以更改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int &amp;b;  //错误的</span></span><br><span class="line">    <span class="type">int</span> &amp;b=a;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line">    b=c;<span class="comment">//赋值操作而不是更改引用</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c=&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做参数函数">引用做参数函数</h3><h5id="作用函数传参时可以利用引用的技术让形参修饰实参">作用：函数传参时，可以利用引用的技术让形参修饰实参</h5><h5 id="优点可以简化指针修改实参">优点：可以简化指针修改实参</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;  <span class="comment">//值传递中形参确实发生改变，但实参没有发生改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=temp;  <span class="comment">//址传递中形参和实参都发生改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;  <span class="comment">//引用传递中形参和实参都发生改变</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">   <span class="comment">// mySwap01(a,b);  //值传递</span></span><br><span class="line">   <span class="comment">// mySwap02(&amp;a,&amp;b);  //址传递</span></span><br><span class="line">   <span class="comment">// mySwap03(a,b);  //引用传递</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;endl;  <span class="comment">// 值传递：10    地址传递： 20    引用传递： 20</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;  <span class="comment">//值传递：20    地址传递： 10   引用传递： 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做函数返回值">引用做函数返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要返回局部变量的引用</span></span><br><span class="line"><span class="comment">//函数的调用可以作为左值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;<span class="comment">//局部变量存放在四区中的栈区</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> a=<span class="number">10</span>;<span class="comment">//静态变量存储在全局区，全局区上的数据在程序结束后系统释放，而不是在text02运行完就失效</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  int &amp;ref=text01();</span></span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;//ref=10   第一次结果正确，因为编译器做了保留</span></span><br><span class="line">  <span class="comment">//  cout&lt;&lt;&quot;ref=&quot;&lt;&lt;ref&lt;&lt;endl;//ref=260398  第二次结果错误，因为a的内存已经释放</span></span><br><span class="line">    <span class="comment">//所以不要返回局部变量的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> &amp;ref=<span class="built_in">text02</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;  <span class="comment">//ref=10</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;  <span class="comment">//ref=10</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;  <span class="comment">//ref=10</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">text02</span>()=<span class="number">1000</span>;<span class="comment">//如果函数的返回值是引用，这个函数调用可以作为左值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;  <span class="comment">//ref=1000</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ref=&quot;</span>&lt;&lt;ref&lt;&lt;endl;  <span class="comment">//ref=1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数提高">函数提高</h2><h3 id="函数默认参数">函数默认参数</h3><h6 id="语法返回值类型-函数名形参默认值">语法：返回值类型函数名(形参=默认值)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b=<span class="number">20</span>,<span class="type">int</span> c=<span class="number">30</span>)</span><span class="comment">//写了一个b和c的默认值，当没有给参数默认值时，形参和实参的数量要一样，当有默认值就不需要相同数量的形参和实参了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(<span class="number">10</span>)&lt;&lt;endl;  <span class="comment">//60</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">30</span>)&lt;&lt;endl;  <span class="comment">//70  如果这个值我传了就用我传的值，如果我没传就用默认值</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6id="注意事项1.如果某个位置已经有了默认参数那么从这个位置往后从左到右都必须有默认值-例如-int-func2int-aint-b10int-c20int-d30">注意事项：1.如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值例如： int func2(int a,int b=10,int c=20,int d=30)</h6><h6id="如果函数的声明有默认参数那么函数实现就不能有默认参数声明和实现只能有一个有默认参数">2.如果函数的声明有默认参数，那么函数实现就不能有默认参数(声明和实现只能有一个有默认参数)</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> a=<span class="number">10</span>,<span class="type">int</span> b=<span class="number">10</span>)</span></span>;<span class="comment">//函数的声明</span></span><br><span class="line"><span class="comment">//  int func3(int a=10,int b=10) //函数的实现，因为此时函数的声明有默认参数，那么函数实现就不能有默认参数，不然就会报错:重定义了默认参数，   即使声明和实现传的默认参数一样   这个情况在C++中称之为&quot;二异性&quot;</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      return a+b;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="函数占位参数">函数占位参数</h3><h6id="语法返回值类型-函数名-数据类型-小括号中只有一个数据类型没有参数">语法：返回值类型函数名 (数据类型){} //小括号中只有一个数据类型，没有参数</h6><h6id="c中函数的形参列表里可以有占位参数用来做占位调用函数时必须填补该位置">C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>)</span><span class="comment">//占位参数还可以有默认参数  void func(int a,int =10)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;this is func&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>，<span class="number">10</span>);  <span class="comment">//第二个10是没有办法传到func函数中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="目前阶段占位函数用不到">目前阶段占位函数用不到</h6><h2id="函数重载函数名可以相同析构函数没有参数因此它不能被重载一个类可以有多个构造函数但是只能有一个析构函数">函数重载（函数名可以相同）（析构函数没有参数,因此它不能被重载。一个类可以有多个构造函数,但是只能有一个析构函数）</h2><h6id="作用函数名可以相同提高复用性">作用：函数名可以相同，提高复用性</h6><h4 id="函数重载满足条件">函数重载满足条件：</h4><ul><li>同一个作用域下（全局作用域）</li><li>函数名称相同</li><li>函数参数类型不同 或者 个数不同 或者 顺序不同</li></ul><h5id="注意函数的返回值不可以作为函数重载的条件无法重载仅仅按返回类型区分的函数">注意:函数的返回值不可以作为函数重载的条件(无法重载仅仅按返回类型区分的函数)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func的调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span>  <span class="comment">//1和2函数类型的个数不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func(int a)的调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span>  <span class="comment">//2和3函数函数参数类型不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func(double a)的调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>  <span class="comment">//4和5函数参数顺序不同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func(int a,double b)的调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;(double a,int b)的调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6</span></span><br><span class="line"><span class="comment">//  void func(double a,int b)   //无法重载仅仅按返回类型区分的函数)</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      cout&lt;&lt;&quot;(double a,int b)的调用&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//func();  //func(int a)的调用</span></span><br><span class="line">    <span class="comment">//func(10);</span></span><br><span class="line">    <span class="comment">//func(2.12);</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2.12</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载注意事项">函数重载注意事项</h3><h4 id="引用作为重载条件">1.引用作为重载条件</h4><h4 id="函数重载遇到默认参数">2.函数重载遇到默认参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引用作为重载条件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span>  <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func(int &amp;a)调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span>  <span class="comment">//2        //1和2的形参类型不一样，可以发生函数重载</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func(const int &amp;a)调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>;   </span><br><span class="line">    <span class="built_in">func</span>(a); <span class="comment">//代码调用函数结果是调用1，没有加const  原因是变量a(变量的意思是可读，可写，可修饰);而加了const就是为了限制a的只读状态，只能读，不能写，所以调用1   </span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">//这时候就会调用2    const int &amp;a=10;  计算机的优化功能</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.函数重载遇到默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>  <span class="comment">//1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func2(int a,int b)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span>  <span class="comment">//2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func2(int a)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// func2(10);  //这时候就会出错因为1和2都会被调用当函数重载碰到默认参数，出现二义性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数语法类名">构造函数语法：类名()</h2><ul><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数有参数，因此可以发生重载</li><li>程序在调用对象时会自动调用构造，无需手动调用，而且只会调用一次</li></ul><h3 id="构造函数的分类及调用">构造函数的分类及调用</h3><h4 id="两种分类方式">两种分类方式：</h4><p>​ 按参数分为：有参构造和无参构造（默认构造）</p><p>​ 按类型分为：普通构造和拷贝构造</p><h4 id="三种调用方式">三种调用方式：</h4><h6 id="括号法">1.括号法：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p1;<span class="comment">//默认构造函数调用</span></span><br><span class="line"><span class="comment">//注意1：调用默认构造函数时候，不要加(),因为下面这行代码，编译器会认为是一个函数的声明，不会认为在创建对象</span></span><br><span class="line"><span class="comment">//Person p1();</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;<span class="comment">//拷贝构造函数</span></span><br></pre></td></tr></table></figure><h6 id="显示法">2.显示法：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">Person p2=<span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">Person p3=<span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//匿名对象 特点：当前执行结束后，系统会立即回收掉匿名对象</span></span><br><span class="line"><span class="comment">//注意2：不要利用拷贝构造函数初始化匿名对象 编译器会认为 Person(p3)==Person p3;</span></span><br><span class="line"><span class="comment">//Person(p3);</span></span><br></pre></td></tr></table></figure><h6 id="隐式转换法">3.隐式转换法：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p4=<span class="number">10</span>;<span class="comment">//相当于 写了 Person p4=Person(10);  有参构造</span></span><br><span class="line">Person p5=p4;<span class="comment">//拷贝构造</span></span><br></pre></td></tr></table></figure><h4id="c中拷贝构造函数调用时机通常有三种">C++中拷贝构造函数调用时机通常有三种：</h4><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person默认构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person有参函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_age=p.m_age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p2的年龄为： &quot;</span>&lt;&lt;p2.m_age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.对象以值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dowork</span><span class="params">(Person p)</span><span class="comment">//相当于传递一个副本，需要调用拷贝构造函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">dowork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.对象以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">dowork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;<span class="comment">//因为局部变量的特点作用域只在这个大括号中，所以返回局部变量时会产生一个副本代替局部变量返回到主函数</span></span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>*)&amp;p1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p=<span class="built_in">dowork2</span>();</span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>*)&amp;p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="comment">/* Person有参函数调用</span></span><br><span class="line"><span class="comment">       Person拷贝构造函数调用</span></span><br><span class="line"><span class="comment">       p2的年龄为：20</span></span><br><span class="line"><span class="comment">       Person析构函数调用</span></span><br><span class="line"><span class="comment">       Person析构函数调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">    <span class="comment">/*Person默认构造函数调用</span></span><br><span class="line"><span class="comment">      Person拷贝构造函数调用</span></span><br><span class="line"><span class="comment">      Person析构函数调用</span></span><br><span class="line"><span class="comment">      Person析构函数调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">text03</span>();</span><br><span class="line">    <span class="comment">/*Person默认构造函数调用</span></span><br><span class="line"><span class="comment">      010FF94</span></span><br><span class="line"><span class="comment">      Person拷贝构造函数调用</span></span><br><span class="line"><span class="comment">      Person析构函数调用</span></span><br><span class="line"><span class="comment">      010FF98C</span></span><br><span class="line"><span class="comment">      Person析构函数调用</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意：</code>(1)在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如对象的类型不同，编译时将出错。（2）两个对象之间的赋值,仅仅是对其中的数据成员赋值,而不对成员函数赋值。（3）数据成员是占存储空间的,不同对象的数据成员占有不同的存储空间,而不同对象的成员函数是占有同一个函数代码段,无法对它们赋值。</p><h2 id="析构函数语法类名">析构函数语法：~类名()</h2><ul><li><p>析构函数，没有返回值也不写void</p></li><li><p>函数名称与类名相同，在名称前加上符号~</p></li><li><p>析构函数不可以有参数，因此不能发生重载</p></li><li><p>程序在对象销毁前会自动调用析构，无需手动调用且只会调用一次</p></li><li><p>在以下情况, 当对象的生命周期结束时，析构函数会被自动调用:</p><p>①如果定义了一个全局对象，则在程序流程离开其作用域时（如main函数结束或调用exit函数）时，调用该全局对象的析构函数。</p><p>②如果一个对象被定义在一个函数体内,则当这个函数结束时,该对象的析构函数被自动调用。</p><p>③若一个对象是使用new运算符动态创建的,在使用delete运算符释放它时,delete会自动调用析构函数。</p></li></ul><h2id="默认情况下c编译器至少给一个类添加三个函数">默认情况下，C++编译器至少给一个类添加三个函数</h2><ul><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ul><h4 id="构造函数的调用规则上3">1.构造函数的调用规则（上3）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()  <span class="comment">//1</span></span><br><span class="line">   &#123;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;Person的默认构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)  <span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;Person的有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">      m_age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)  <span class="comment">//3</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person的拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_age=p.m_age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4id="如果我们写了有参构造函数编译器就不会再提供默认构造依然提供拷贝构造-如果我们写了拷贝构造函数编译器就不提供其他构造函数">2.如果我们写了有参构造函数，编译器就不会再提供默认构造，依然提供拷贝构造如果我们写了拷贝构造函数，编译器就不提供其他构造函数</h4><h2 id="深拷贝和浅拷贝问题">深拷贝和浅拷贝问题</h2><h4id="浅拷贝简单的赋值拷贝操作带来的问题是内存会重复释放如果利用编译器提供的拷贝构造函数就会进行浅拷贝工作">浅拷贝：简单的赋值拷贝操作(带来的问题是内存会重复释放)，如果利用编译器提供的拷贝构造函数，就会进行浅拷贝工作</h4><h4id="深拷贝在堆区重新申请空间进行拷贝操作">深拷贝：在堆区重新申请空间，进行拷贝操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person的默认构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age,<span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_age=age;</span><br><span class="line">        m_Height=<span class="keyword">new</span> <span class="built_in">int</span>(height);<span class="comment">//利用new把数据创建在堆区，返回的数据是int*</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person的有参构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自己实现拷贝构造函数，解决浅拷贝带来的问题</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person拷贝构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_age=age;</span><br><span class="line">        <span class="comment">//m_Height=p.m_Height;  编译器默认就是实现这一行代码(浅拷贝)</span></span><br><span class="line">        <span class="comment">//深拷贝操作</span></span><br><span class="line">        </span><br><span class="line">        m_Height=<span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构代码，将堆区开辟数据做释放操作</span></span><br><span class="line">        <span class="keyword">if</span>(m_Height!=<span class="literal">NULL</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Height;</span><br><span class="line">            m_Height=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> *m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span><span class="comment">//先进后出原则，p1后调用析构函数，后释放内存，p2先释放</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="number">160</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1的年龄为：&quot;</span>&lt;&lt;p1.m_age&lt;&lt;<span class="string">&quot;身高为：&quot;</span>&lt;&lt;*p1.m_Height&lt;&lt;endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p2的年龄为：&quot;</span>&lt;&lt;p2.m_age&lt;&lt;<span class="string">&quot;身高为：&quot;</span>&lt;&lt;*p2.m_Height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4id="注意如果属性有在堆区开辟的一定要自己提供拷贝构造函数防止浅拷贝带来的问题">注意：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</h4><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272115523.png"alt="308b631d9cd744ac84fde08b0e7cb024" /><figcaptionaria-hidden="true">308b631d9cd744ac84fde08b0e7cb024</figcaption></figure><h2 id="初始化列表赋初值">初始化列表赋初值</h2><h4id="语法构造函数属性1值1属性2值2属性3值3...">语法：构造函数():属性1(值1):属性2(值2):属性3(值3)...</h4><h2 id="类对象作为类成员">类对象作为类成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string pName)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Phone的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_PName=pName;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Phone的析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//m_Phone=pName 隐式转换法</span></span><br><span class="line">    <span class="built_in">Person</span>(string name,string pName):<span class="built_in">m_Name</span>(name),<span class="built_in">m_Phone</span>(pName)<span class="comment">//初始化列表的方式赋初值</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Person的析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//手机</span></span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当其他类对象(集合)作为本类成员(成员变量和成员函数)，构造时候先构造类对象，再构造自身，析构函数的调用和构造函数的调用相反</span></span><br><span class="line"><span class="type">void</span> text01</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;p.m_Name&lt;&lt;<span class="string">&quot;拿着:&quot;</span>&lt;&lt;p.m_Phone.m_PName&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    text01;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="静态成员static">静态成员(static)</h2><ul><li>静态成员变量<ul><li>所有对象共享一份数据</li><li>在编译阶段分配内存（全局区）</li><li>类内声明，类外初始化（必须有初始值）</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;<span class="comment">//类内声明</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::m_A=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B=<span class="number">200</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout&lt;&lt;p.m_A&lt;&lt;endl;</span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A=<span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;p.m_A&lt;&lt;endl;<span class="comment">//200  说明所有对象共享一份数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量不属于某个对象上，所有对象都共享同一份数据</span></span><br><span class="line">    <span class="comment">//因此静态成员变量有两种访问方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1，通过对象进行方式</span></span><br><span class="line">    Person p;</span><br><span class="line">    cout&lt;&lt;p.m_A&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2，通过类名进行访问  Perxon作用域下的m_A</span></span><br><span class="line">    cout&lt;&lt;Person::m_A&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;Person::m_A&lt;&lt;endl;<span class="comment">//会报错，私有同样不可以访问静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态成员函数<ul><li>所有对象共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A=<span class="number">100</span>;<span class="comment">//静态成员函数可以访问静态成员变量</span></span><br><span class="line">        <span class="comment">//m_B=200;   静态成员函数不能访问非静态成员变量  无法区分到底是哪个对象的m_B</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;static void func调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;<span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B;<span class="comment">//非静态成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态成员函数也有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;static func2()的访问调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有两种访问方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.通过对象访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//2.通过类名访问，因为静态成员函数不属于某个对象，大家共享这个静态函数</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Person::func2();  会报错因为类外不可以访问私有静态成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c对象模型">C++对象模型</h2><h3id="成员变量和成员函数分开存储只有非静态成员变量才属于类的对象上非静态成员函数静态成员变量静态成员函数都是分开存储不在类的对象上">成员变量和成员函数分开存储（只有非静态成员变量才属于类的对象上，非静态成员函数；静态成员变量；静态成员函数都是分开存储，不在类的对象上）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量 4 也侧面验证了非静态成员变量，属于类的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;<span class="comment">//静态成员变量 4 加上静态成员变量 类的对象所占内存还是4，侧面验证了静态成员变量不属于类对象上</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//非静态成员函数 4 不属于类对象上</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//4 静态成员函数 不属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//空对象占用内存空间为：  1个字节</span></span><br><span class="line">    <span class="comment">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class="line">    <span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size of p=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(p)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span><span class="comment">//当有一个非静态成员变量时 类的对象所占内存空间为：</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size of p=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(p)&lt;&lt;endl;  <span class="comment">//4</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="this指针概念不同对象的数据成员存放在不同的内存地址所有对象的成员函数对应的是同一个函数代码段">this指针概念（不同对象的数据成员存放在不同的内存地址，所有对象的成员函数对应的是同一个函数代码段）</h3><p><code>this指针的本质是指针常量 指针的指向是不可以修改的 但是指向的值是可以修改的</code></p><h5id="每个非静态成员函数只会诞生一份函数实例也就是说多个同类型的对象会共用一块代码那这一块代码是如何区分是哪个对象调用自己呢当一个对象要调用成员函数时this指针中就装着该对象的地址-成员函数就根据这个指针找到相应的数据然而进行相应的操作">每个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那这一块代码是如何区分是哪个对象调用自己呢？<code>当一个对象要调用成员函数时，this指针中就装着该对象的地址, 成员函数就根据这个指针,找到相应的数据,然而进行相应的操作。</code></h5><h5id="c通过提供特殊的对象指针this指针解决上述问题this指针指向被调用的成员函数所属的对象-this指针是隐含在每一个非静态成员函数的一种指针不需要定义直接使用即可">C++通过提供特殊的对象指针，this指针，解决上述问题，<code>this指针指向被调用的成员函数所属的对象  this指针是隐含在每一个非静态成员函数的一种指针，不需要定义直接使用即可</code></h5><ul><li>解决名称冲突</li><li>返回对象本身用*this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this-&gt;age=age;  this指针指向的是被调用的成员函数所属的对象，这里this指向p1</span></span><br><span class="line">        age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person &amp;p)</span>  <span class="comment">//返回p2本体用引用方式返回，会一直返回p2，但是如果用值的方式返回就会一直调用赋值构造函数，返回的值就不是p2</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age+=p.age;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//this指向p2指针，*this指向的是p2本体</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1的年龄为 &quot;</span>&lt;&lt;p1.age&lt;&lt;endl; <span class="comment">//26328629 乱码出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">   <span class="comment">// p2.PersonAddAge(p1);</span></span><br><span class="line">   <span class="comment">// cout&lt;&lt;&quot;p2的年龄为 &quot;&lt;&lt;p2.age&lt;&lt;endl;//20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链式编程思想</span></span><br><span class="line">    p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p2的年龄为 &quot;</span>&lt;&lt;p2.age&lt;&lt;endl; <span class="comment">//40</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    text01;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="空指针访问成员函数">空指针访问成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;this is Person class&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//报错原因是因为传入指针为空，无中生有</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;age=&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Age&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提高指针健壮性</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person *p=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">  <span class="comment">//  p-&gt;showPersonAge(); //读取访问权限冲突</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const修饰成员函数常函数">const修饰成员函数(常函数)</h2><h3 id="常函数">常函数</h3><ul><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><h3 id="常对象">常对象</h3><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常含数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">//如果在成员函数形参列表后加const，其本质相当于const Person *const this，这个时候不仅指针指向不可以改，其指针指向的值也不可以修改</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//this-&gt;m_A=100; </span></span><br><span class="line">        <span class="comment">//this=NULL; //this指针不可以修改指针的指向的</span></span><br><span class="line">        <span class="comment">//this指针的本质是指针常量，指针指向不可以修改，但是指针指向的值可以修改，其本质是Person * const this;</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">this</span>-&gt;m_B=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_B;<span class="comment">//特殊变量，即使在常含数中，也可以修改这个值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Person p;<span class="comment">//对象前加const，变为常对象</span></span><br><span class="line">    <span class="comment">//p.m_A=100;//不允许修改 不允许更改常对象的数据成员  不允许常对象调用普通的成员函数      </span></span><br><span class="line">    p.m_B=<span class="number">200</span>;<span class="comment">//允许修改</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//常对象只能调用常含数</span></span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="comment">//p.func();//会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>    <span class="comment">//如果在一个类中说明了常数据成员,那么构造函数就只能通过初始化列表对该数据成员进行初始化,而不能采用在函数中直接赋值的方法。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> year; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> month; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> day;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d); </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">showDate</span><span class="params">()</span></span>;  &#125;;</span><br><span class="line">  Date::<span class="built_in">Date</span>(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d) :<span class="built_in">year</span>(y),<span class="built_in">month</span>(m),<span class="built_in">day</span>(d) <span class="comment">//只能通过初始化列表对该数据成员进行初始化</span></span><br><span class="line">      <span class="comment">/*  //cui</span></span><br><span class="line"><span class="comment">      如果构造函数改写成：</span></span><br><span class="line"><span class="comment">Date::Date(int y,int m,int d)</span></span><br><span class="line"><span class="comment">&#123; year=y;</span></span><br><span class="line"><span class="comment">  month=m;</span></span><br><span class="line"><span class="comment">  day=d;  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> &#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Date::showDate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  cout&lt;&lt;year&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;month&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;day&lt;&lt;endl;&#125; </span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="function">Date <span class="title">date1</span><span class="params">(<span class="number">2009</span>,<span class="number">10</span>,<span class="number">15</span>)</span></span>;     </span><br><span class="line">   date1.<span class="built_in">showDate</span>();  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="友元">友元</h2><ul><li>全局函数做友元</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//全局函数的声明,goodGay全局函数是Building好朋友，可以访问私有类成员</span></span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_SittingRoom=<span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_BedRoom=<span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;好基友全局函数 正在访问：&quot;</span>&lt;&lt;building-&gt;m_SettingRoom&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;好基友全局函数 正在访问：&quot;</span>&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Building building;</span><br><span class="line">    <span class="built_in">goodGay</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类做友元</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数 访问Building中的属性</span></span><br><span class="line">    </span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;<span class="comment">//GoodGay这个类是本类的好朋友，可以访问私有</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>(); <span class="comment">//构造函数声明</span></span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外给构造函数或成员函数赋初值(类内也可以)</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_SettingRoom=<span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom=<span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建建筑物的对象</span></span><br><span class="line">    building=<span class="keyword">new</span> Building; <span class="comment">//new 在堆区创造一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;好基友类正在访问：&quot;</span>&lt;&lt;building-&gt;SettingRoom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>成员函数做友元</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GoodGay类</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">GoodGay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGay</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;  <span class="comment">//让visit函数可以访问Building中私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;  <span class="comment">//让visit2函数不可以访问Building中私有成员</span></span><br><span class="line">    </span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Building类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 GoodGay类下的visit成员函数可以访问Building类的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_SittingRoom=<span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom=<span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    building=<span class="keyword">new</span> Building:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> GoodGay::<span class="built_in">visit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;visit正在访问：&quot;</span>&lt;&lt;building-&gt;m_SettingRoom&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;visit正在访问：&quot;</span>&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;visit2正在访问：&quot;</span>&lt;&lt;building-&gt;m_SettingRoom&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//  cout&lt;&lt;&quot;visit2正在访问：&quot;&lt;&lt;building-&gt;m_BedRoom&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GoodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();<span class="comment">//客厅 卧室都可以访问</span></span><br><span class="line">    gg.<span class="built_in">visit2</span>();<span class="comment">//客厅可以 卧室不可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;  <span class="comment">//对Date类的提前引用声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;  <span class="comment">//声明类Time</span></span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Time</span> (<span class="type">int</span> h,<span class="type">int</span> m,<span class="type">int</span> s) <span class="comment">//定义构造函数</span></span><br><span class="line">  &#123; hour =h; minute =m; sec =s;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showDate_Time</span><span class="params">(Date&amp;)</span></span>;   <span class="comment">//声明函数showDate_Time为类Time的成员函数,也是类Date的友元函数</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> hour; <span class="type">int</span> minute; <span class="type">int</span> sec; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123; <span class="comment">//声明类Date</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Date</span>(<span class="type">int</span> y,<span class="type">int</span> m,<span class="type">int</span> d) <span class="comment">//定义构造函数</span></span><br><span class="line">  &#123; year=y; month=m; day=d; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Time::showDate_Time</span><span class="params">(Date&amp;)</span></span>; </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> year; <span class="type">int</span> month; <span class="type">int</span> day;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::showDate_Time</span> <span class="params">(Date&amp; d)</span>  <span class="comment">//定义函数showDate_Time为类Time的成员函数,也是类Date的友元函数,形参为Date类对象的引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;d.year&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;d.month&lt;&lt;<span class="string">&quot;.&quot;</span>&lt;&lt;d.day&lt;&lt;endl; <span class="comment">//函数showDate_Time作为Time类的成员函数,可以访问Time类对象中的私有数据</span></span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;sec&lt;&lt;endl;    <span class="comment">//函数showDate_Time作为Date类的友元函数,可以访问Date类对象中的私有数据</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">date1</span><span class="params">(<span class="number">2010</span>,<span class="number">11</span>,<span class="number">14</span>)</span></span>;<span class="comment">//定义Date类对象date1</span></span><br><span class="line">  <span class="function">Time <span class="title">time1</span><span class="params">(<span class="number">6</span>,<span class="number">12</span>,<span class="number">18</span>)</span></span>;  <span class="comment">//定义Time类对象time1</span></span><br><span class="line">  time1.<span class="built_in">showDate_Time</span>(date1); <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//调用函数showDate_Time,实参是Date类对象date1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">程序的运行结果如下:</span><br><span class="line"><span class="number">2010.11</span><span class="number">.14</span></span><br><span class="line"><span class="number">6</span>:<span class="number">12</span>:<span class="number">18</span></span><br></pre></td></tr></table></figure><h6 id="友元关系是单向的不具有交换性">(1)友元关系是单向的，不具有交换性。</h6><p>若类X是类Y的友元，类Y是否是X的友元，要看在类中是否有相应的声明。</p><h6 id="友元关系也不具有传递性">(2) 友元关系也不具有传递性。</h6><p>若类X是类Y的友元，类Y是类Z的友元，不一定类X是类Z的友元。</p><h2 id="运算符重载">运算符重载</h2><h3id="对已有的运算符进行定义赋予其另一种功能以适应不同的数据类型">对已有的运算符进行定义，赋予其另一种功能，以适应不同的数据类型</h3><h4id="加号运算符重载实现两个自定义数据类型的运算">加号运算符重载(实现两个自定义数据类型的运算)</h4><ul><li>对于内置的数据类型的表达式的运算符是不可能改变的</li><li>不要滥用运算符重载</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使p1的m_A属性加上p2的m_A属性等于p3的m_A属性；使p1的m_B属性加上p2的m_B属性等于p3的m_B属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    Person <span class="keyword">operator</span>+(Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A=<span class="keyword">this</span>-&gt;m_A+p.m_A;</span><br><span class="line">        temp.m_B=<span class="keyword">this</span>-&gt;m_B+p.m_B;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1:</span><br><span class="line">    p1.m_A=<span class="number">10</span>;</span><br><span class="line">    P1.m_B=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Person p2:</span><br><span class="line">    p2.m_A=<span class="number">10</span>;</span><br><span class="line">    P2.m_B=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Person p3=p1+p2;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p3.m_A&quot;</span>&lt;&lt;p3.m_A&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p3.m_B&quot;</span>&lt;&lt;p3.m_B&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以通过自己写成员函数来实现两个对象相加后返回新的对象</span></span><br><span class="line"><span class="comment">Person PersonAddPerson(Person &amp;p)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Person temp;</span></span><br><span class="line"><span class="comment">    temp.m_A=this-&gt;m_A+p.m_A;</span></span><br><span class="line"><span class="comment">    temp.m_B=this-&gt;m_B+p.m_B;</span></span><br><span class="line"><span class="comment">    return temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个时候编译器起了一个通用名称</span></span><br><span class="line"><span class="comment">// operator+</span></span><br><span class="line"><span class="comment">//这个时候成员函数就可以变为</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A=<span class="keyword">this</span>-&gt;m_A+p.m_A;</span><br><span class="line">    temp.m_B=<span class="keyword">this</span>-&gt;m_B+p.m_B;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现上诉目的就的代码为</span></span><br><span class="line">Person p3=p1.<span class="keyword">operator</span>+(p2);</span><br><span class="line"><span class="comment">//简化为</span></span><br><span class="line">Person p3=p1+p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="comment">/*通过全局函数重载+</span></span><br><span class="line"><span class="comment">Person operator+(Person &amp;p1,Person &amp;p2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    person temp; </span></span><br><span class="line"><span class="comment">    temp.m_A=p1.m_A+p2.m_A;</span></span><br><span class="line"><span class="comment">    temp.m_B=p1.m_B+p2.m_B;</span></span><br><span class="line"><span class="comment">    return temp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//调用这个全局函数</span></span><br><span class="line"><span class="comment">Person p3=operator+(p1,p2)</span></span><br><span class="line"><span class="comment">//简化为</span></span><br><span class="line"><span class="comment">Person p3=p1+p2; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="运算符重载-也可以发生函数重载用途重复使用函数名">运算符重载也可以发生函数重载（用途：重复使用函数名）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person p3=p1+<span class="number">10</span>;  <span class="comment">//Person + int</span></span><br><span class="line"><span class="comment">//函数重载版本</span></span><br><span class="line">Person Person+(Person &amp;p1,<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    person temp; </span><br><span class="line">    temp.m_A=p1.m_A+p2.m_A;</span><br><span class="line">    temp.m_B=p1.m_B+p2.m_B;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p4=p1+<span class="number">100</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;p4.m_A&quot;</span>&lt;&lt;p4.m_A&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;p4.m_B&quot;</span>&lt;&lt;p4.m_B&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h4 id="左移运算符重载">左移运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了输出p时就能将其中的所有属性都输出</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(cout,p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用成员函数重载左移运算符  p.operator&lt;&lt;(cout)  简化版本 p&lt;&lt;cout</span></span><br><span class="line">    <span class="comment">//不会利用成员函数重载&lt;&lt;运算符，因为无法实现cout在左侧</span></span><br><span class="line">    <span class="comment">//void operator&lt;&lt;(cout)   在不知道返回值的情况下，先用void</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//在构造函数中赋初值</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a，<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        m_A=a;</span><br><span class="line">        m_B=b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能利用全局函数重载左移运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person &amp;p) <span class="comment">//本质 operator&lt;&lt;(cout) 简化为cout&lt;&lt;p;  cout本质为标准输出流对象，全局只能有一个</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;m_A=&quot;</span>&lt;&lt;p.m_A&lt;&lt;<span class="string">&quot;m_B=&quot;</span>&lt;&lt;p.m_B;</span><br><span class="line">    <span class="keyword">return</span> cout;  <span class="comment">//cout可以改成任意别名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cout&lt;&lt;p&lt;&lt;endl;  没有与这些操作数匹配的&quot;&lt;&lt;&quot;运算符</span></span><br><span class="line">    <span class="comment">//全局函数编码成功后就可以输出p</span></span><br><span class="line">    <span class="comment">//链式反应</span></span><br><span class="line">    cout&lt;&lt;p&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递增运算符重载">递增运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,Myinteger myint)</span><br><span class="line">    <span class="built_in">MyInteger</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Num=<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重载++运算符(前置)</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++()     <span class="comment">//为什么返回不能返回值而是返回引用的数据？为了多次累加的链式反应不出错，为了对同一个数据做递增操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重载++运算符(后置)</span></span><br><span class="line">    <span class="comment">//因为temp是一个局部对象，在这个函数执行完就会被释放，如果还要返回它的引用，之后就是非法操作，所以后置返回的是值的形式</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)  <span class="comment">//int代表占位参数，用于区分前置和后置递增</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先 记录当时结果</span></span><br><span class="line">        MyInteger temp=*<span class="keyword">this</span>;     </span><br><span class="line">        <span class="comment">//后 递增</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//最后将记录结果返回</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载左移运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout,Myinteger myint)  </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line">    cout&lt;&lt;++(++myint)&lt;&lt;endl; <span class="comment">//用引用或者值返回都为2</span></span><br><span class="line">    cout&lt;&lt;myint&lt;&lt;endl;  <span class="comment">//此时用引用返回的为2，而用值返回的就为1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;myint++&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;myint&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符重载">赋值运算符重载</h4><h5id="编译器会至少给一个类添加4个函数">编译器会至少给一个类添加4个函数</h5><ul><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行拷贝</li><li>赋值运算符operator=对属性进行值拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age=<span class="keyword">new</span> <span class="built_in">int</span>(age);  <span class="comment">//new运算符生成一个堆区数据，由程序员手动开辟，也需要他手动释放(手动释放用析构函数)，返回类型为int*</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Age!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//重载 赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//编译器是提供浅拷贝</span></span><br><span class="line">    <span class="comment">//m_Age=p.m_Age;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.应该先判断是否有属性在堆区，如果有要先释放干净，然后再深拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(m_Age!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Age;</span><br><span class="line">        m_Age=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.深拷贝</span></span><br><span class="line">    m_Age=<span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//3.返回对象本身</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="comment">//赋值运算操作  用编译器提供的赋值操作，只是单纯把p1中的年龄的地址值赋值给p2，会出现重复释放的问题，所以要自己写一个赋值运算符</span></span><br><span class="line">    p3=p2=p1;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p1的年龄为：&quot;</span>&lt;&lt;*p1.m_Age&lt;&lt;endl;  <span class="comment">//18</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p2的年龄为：&quot;</span>&lt;&lt;*p2.m_Age&lt;&lt;endl; <span class="comment">//18</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;p3的年龄为：&quot;</span>&lt;&lt;*p3.m_Age&lt;&lt;endl; <span class="comment">//18</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系运算符重载">关系运算符重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name=name;</span><br><span class="line">        m_Age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载关系运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;m_Name==p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age==p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom,18&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom,18&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(p1==p2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1和p2是相等的&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;p1和p2是不相等的&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用运算符重载">调用运算符重载</h4><ul><li>函数调用运算符（）也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myprint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">//重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;test&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint02</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;test&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//对象使用重载调用运算符</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyPrint02</span>(<span class="string">&quot;hello world&quot;</span>);<span class="comment">//调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加法函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1+num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd myadd;</span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">myadd</span>(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ret=&quot;</span>&lt;&lt;ret&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//匿名函数对象</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">MyAdd</span>()(<span class="number">100</span>,<span class="number">100</span>)&lt;&lt;endl;  <span class="comment">//匿名对象重载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>(); <span class="comment">//仿函数没有固定写法，很灵活，会根据我们的需求改变返回值类型和参数类型和个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承">继承</h2><h4 id="语法-class-子类派生类-继承方式-父类基类">语法： class子类（派生类） ：继承方式 父类（基类）</h4><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>:<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A=<span class="number">10</span>;<span class="comment">//父类中的公共权限成员 在子类依然是公共权限</span></span><br><span class="line">        m_B=<span class="number">20</span>;<span class="comment">//父类中的保护权限成员 在子类依然是保护权限</span></span><br><span class="line">       <span class="comment">// m_C=30;  父类中的私有权限成员 子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s1;</span><br><span class="line">    s1.m_A=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//    s1.m_B=100;   //保护权限类内可以访问，类外不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A=<span class="number">100</span>;  <span class="comment">//父类中公共成员 在子类中变成保护权限</span></span><br><span class="line">        m_B=<span class="number">100</span>;  <span class="comment">//父类中保护成员 依然在子类为保护权限</span></span><br><span class="line">  <span class="comment">//  m_C=100;  //父类中的私有权限成员 子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son2 s1;</span><br><span class="line"> <span class="comment">//   s1.m_A=100;  保护权限类内可以访问，类外不可以访问</span></span><br><span class="line"> <span class="comment">//   S1.m_B=100;  保护权限类内可以访问，类外不可以访问</span></span><br><span class="line"> <span class="comment">//   s1.m_C=100;  保护权限类内可以访问，类外不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A=<span class="number">100</span>;  <span class="comment">//父类中公共成员 在子类中变为私有成员</span></span><br><span class="line">        m_B=<span class="number">100</span>;  <span class="comment">//父类中保护成员 在子类中变为私有成员</span></span><br><span class="line">        m_c=<span class="number">100</span>;  <span class="comment">//父类中私有成员 子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s1;</span><br><span class="line">    s1.m_A=<span class="number">1000</span>;  <span class="comment">//私有成员类外访问不到</span></span><br><span class="line">    S2.m_B=<span class="number">1000</span>;  <span class="comment">//私有成员类外访问不到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中的对象模型">继承中的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size of Son:&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(Son)&lt;&lt;endl;  <span class="comment">//16 父类中所有非静态成员属性成员，子类都会继承，父类中私有成员属性，是被编译器隐藏了，子类访问不到，但是确实被继承了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当基类含有带参数的构造函数时，派生类必须定义构造函数，并缀上基类名(参数表),以提供把参数传递给基类构造函数的途径。</strong>其中基类构造函数参数表的参数，通常来源于派生类构造函数的参数表，也可以用常数值。</p><p>(1)可以将派生类构造函数定义在类的外部,而在类体内只写该函数的声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在派生类中声明构造函数的原型:</span></span><br><span class="line">   <span class="built_in">D</span>(<span class="type">int</span> a,<span class="type">int</span> b);   <span class="comment">//在此，不包括基类构造函数名及其参数表(即:base(b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而在类的外部定义派生类的构造函数:</span></span><br><span class="line">   <span class="built_in">D</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">B</span>(b)   <span class="comment">//在此，要列出基类构造函数名及其参数表(即:base(b)) </span></span><br><span class="line">   &#123; cout&lt;&lt;<span class="string">&quot;调用派生类的构造函数\n&quot;</span>&lt;&lt;endl;</span><br><span class="line">    j=a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6id="当派生类中含有对象成员时其构造函数的一般形式为">当派生类中含有对象成员时，其构造函数的一般形式为：</h6><p><strong>派生类名(参数总表基类名(参数表0)，对象名成员1(参数表1)，…，对象成员名n(参数表n)</strong></p><p><strong>{</strong></p><p><strong>//派生类新增成员的初始化语句</strong> <strong>..</strong></p><p><strong>}</strong></p><h3 id="继承中构造和析构顺序">继承中构造和析构顺序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base的构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base的析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son的构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son的析构函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Base b;  Base的构造函数   Base的析构函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先构造父类再构造子类，析构和构造的顺序相反</span></span><br><span class="line">    Son s;   <span class="comment">// Base的构造函数  Son的构造函数  Son的析构函数  Base的析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中同名成员的处理方式">继承中同名成员的处理方式</h3><h4id="当子类与父类出现同名的成员如何通过子类对象访问到子类或父类中同名的数据">当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据</h4><ul><li>访问子类同名成员 直接访问就行</li><li>访问父类同名成员 需要加作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A=<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base-func()调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son-func()调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//同名数据成员，通过子类对象的处理方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Son下 m_A=&quot;</span>&lt;&lt;s.m_A&lt;&lt;endl;  <span class="comment">//200,直接访问访问的是同名中的子类</span></span><br><span class="line">    <span class="comment">//如果通过子类对象 访问到父类中同名成员，需要加作用域</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base下 m_A=&quot;</span>&lt;&lt;s.Base::m_A&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数处理方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();  <span class="comment">//Son-func()调用  直接调用，调用的是子类中的成员函数</span></span><br><span class="line">    <span class="comment">//如何调用到父类中同名成员函数？</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>();  <span class="comment">//Base-func()调用</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数 所以s.func(100); 会报错</span></span><br><span class="line">    <span class="comment">//如果想访问父类中被隐藏的同名成员函数需要加作用域</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中同名静态成员">继承中同名静态成员</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base static void func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base static void func(int a)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_A=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>::<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Son static void func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son::m_A=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.通过对象来访问数据</span></span><br><span class="line">    Son s;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Son 下 m_A=&quot;</span>&lt;&lt;s.m_A&lt;&lt;endl;  <span class="comment">//100</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base 下 m_A=&quot;</span>&lt;&lt;Son::m_A&lt;&lt;endl;  <span class="comment">//200</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.通过类名方式访问</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;通过类名访问：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Son 下 m_A=&quot;</span>&lt;&lt;Son::m_A&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base 下 m_A=&quot;</span>&lt;&lt;Son::Base::m_A&lt;&lt;endl;<span class="comment">//子类通过域名访问父类作用域 下的m_A</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.通过对象访问</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;通过对象访问&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.通过类名访问</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;通过类名访问&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Son::func(100) 这时也无法通过函数重载调用带参的函数  因为子类出现和父类同名成员函数，会隐藏父类中所有同名成员函数，这时候还是需要加作用域才能访问</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多继承语法">多继承语法</h3><p><code>语法：class 子类:继承方式 父类1，继承方式 父亲2...</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Base1</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         m_A=<span class="number">100</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_B=<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类 需要继承Base1和Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_C=<span class="number">300</span>;</span><br><span class="line">        m_D=<span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof Son=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(s)&lt;&lt;endl;  <span class="comment">//16 </span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;m_A=&quot;&lt;&lt;s.m_A&lt;&lt;endl;  二义性，当父类中出现同名成员，需要加作用域</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base1 m_A=&quot;</span>&lt;&lt;Base1::s.m_A&lt;&lt;endl;  <span class="comment">//100</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base2 m_A=&quot;</span>&lt;&lt;Base2::s.m_A&lt;&lt;endl;  <span class="comment">//200</span></span><br><span class="line">    <span class="comment">//通常在开发过程中不做多继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="虚基类菱形继承">虚基类（菱形继承）</h3><ul><li>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时就会产生二义性</li><li>草泥马继承了动物的数据继承了两份，但这个数据继承一次就行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承 解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//继承之前 加上关键字virtual变为虚继承</span></span><br><span class="line"><span class="comment">//Animal类称为虚基类</span></span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span>:<span class="keyword">public</span> Sheep,<span class="keyword">public</span> Tuo</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">   <span class="comment">// st.m_Age=18;  这时候就会出现多继承的问题，产生二义性</span></span><br><span class="line">    st.Sheep::m_Age=<span class="number">18</span>;</span><br><span class="line">    st.Tuo::m_Age=<span class="number">28</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; st.Sheep::m_Age=&quot;</span>&lt;&lt; st.Sheep::m_Age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; st.Tuo::m_Age=&quot;</span>&lt;&lt; st.Tuo::m_Age&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当成为虚继承时，数据就变成了一个这个时候不会出现二义性，先把m_Age赋值为18，再赋值为28</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; st.m_Age=&quot;</span>&lt;&lt; st.m_Age&lt;&lt;endl; <span class="comment">//28</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6id="派生类对基类成员的访问形式主要有以下两种">派生类对基类成员的访问形式主要有以下两种:</h6><p><strong>内部访问</strong> 由派生类中新增的成员函数对基类继承来的成员的访问</p><p><strong>对象访问</strong>在派生类<strong>外部</strong>通过派生类的对象对从基类继承来的成员的访问</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272116787.png"alt="屏幕截图_20230511_110042" /><figcaption aria-hidden="true">屏幕截图_20230511_110042</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272116450.png"alt="屏幕截图_20230511_110227" /><figcaption aria-hidden="true">屏幕截图_20230511_110227</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272116782.png"alt="屏幕截图_20230511_110626" /><figcaption aria-hidden="true">屏幕截图_20230511_110626</figcaption></figure><h6 id="对于基类中的私有成员">对于基类中的私有成员：</h6><p>无论哪种派生方式，基类中的私有成员,</p><p>不允许派生类的对象直接访问(对象访问),</p><p>不允许派生类中成员函数直接访问(内部访问) ，</p><p><strong>但是可以通过基类提供的公有成员函数访问。</strong></p><h2 id="多态">多态</h2><ul><li>静态多态：函数重载和运算符重载属于静态多态，重复使用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><h6 id="静态多态和动态多态的区别">静态多态和动态多态的区别：</h6><ul><li>静态多态的函数地址早绑定，编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定，运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;动物在说话&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行说话的函数</span></span><br><span class="line"><span class="comment">//地址早绑定，在编译阶段就确定函数地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal &amp;animal)</span>  <span class="comment">//在用父类的引用接收子类的对象  Animal &amp; animal=cat  在C++中允许父子之间的类型转换，不需要做强制类型转换，父类的引用或者指针可以直接指向子类对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//现在的问题是speak()这个函数是走猫还是动物？  我们本意是想让猫说话，但是执行结果是动物在说话  如果想执行让猫说话，就不能让这个函数地址提前绑定，需要在运行阶段进行绑定</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">doSpeak</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof Animal=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(Animal)&lt;&lt;endl; <span class="comment">//在没有构建虚函数前因为成员变量和成员函数分开存储（只有非静态成员变量才属于类的对象上，非静态成员函数；静态成员变量；静态成员函数都是分开存储，不在类的对象上），所以现在的Animal类相当于一个空类，空类的大小是&#x27;1&#x27;`</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof Animal=&quot;</span>&lt;&lt;<span class="built_in">sizeof</span>(Animal)&lt;&lt;endl; <span class="comment">//在构建完虚函数后结果变成了&#x27;4&#x27;(不管什么类型的指针都占四个字节)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6id="在c中规定-基类的对象指针可以指向它的公有派生的对象但是当其指向公有派生类对象时它只能访问派生类中从基类继承来的成员而不能访问公有派生类中定义的成员"><strong>在C++中规定</strong>:基类的对象指针可以指向它的公有派生的对象,但是当其指向公有派生类对象时,它只能访问派生类中从基类继承来的成员，而不能访问公有派生类中定义的成员</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;         </span><br><span class="line"> <span class="keyword">public</span>：<span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;. . .&#125;  &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>：<span class="keyword">public</span> A &#123;</span><br><span class="line"> <span class="keyword">public</span>：<span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">()</span></span>&#123;. . .&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;A *p1；  <span class="comment">//定义基类A的指针变量p1</span></span><br><span class="line"> B op2；  <span class="comment">//定义派生类B的对象op2</span></span><br><span class="line"> p1=&amp;op2；<span class="comment">//将指针变量p1指向派生类对象op2</span></span><br><span class="line"> p1-&gt;<span class="built_in">print1</span>();  <span class="comment">//正确, 基类指针变量p1可以访问派生类中从基类继承来的成员函数print1()</span></span><br><span class="line"> p1-&gt;<span class="built_in">print2</span>();  <span class="comment">//错误,基类指针变量p1不能访问派生类中定义的成员函数print2()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;    <span class="comment">//例 虚函数引例 </span></span><br><span class="line">  <span class="type">int</span> a,b;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">base</span>(<span class="type">int</span> x,<span class="type">int</span> y) &#123; a=x;  b=y; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123; cout&lt;&lt;<span class="string">&quot;调用基类base的show函数\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a=&quot;</span> &lt;&lt;a&lt;&lt;“b=<span class="string">&quot;&lt;&lt;b&lt;&lt;endl; &#125;   &#125;;</span></span><br><span class="line"><span class="string">class dirive:public base &#123;</span></span><br><span class="line"><span class="string">  int c;</span></span><br><span class="line"><span class="string"> public:</span></span><br><span class="line"><span class="string">  dirive(int x,int y,int z):base(x,y)&#123;c=z;&#125;</span></span><br><span class="line"><span class="string">  void show( ) &#123; cout&lt;&lt; &quot;</span>调用派生类dirive的show函数\n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">cout&lt;&lt;&quot;</span>c=<span class="string">&quot;&lt;&lt;c&lt;&lt;endl; &#125;  &#125;;</span></span><br><span class="line"><span class="string">void main( )</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">  base mb(50,50),*mp; </span></span><br><span class="line"><span class="string">  dirive mc(10,20,30);</span></span><br><span class="line"><span class="string">  mp=&amp;mb; </span></span><br><span class="line"><span class="string">  mp-&gt;show( );</span></span><br><span class="line"><span class="string">  mp=&amp;mc; </span></span><br><span class="line"><span class="string">  mp-&gt;show( );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">程序运行结果不是：</span></span><br><span class="line"><span class="string">调用基类base的show函数</span></span><br><span class="line"><span class="string">a=50 b=50</span></span><br><span class="line"><span class="string">调用派生类dirive的show函数</span></span><br><span class="line"><span class="string">c=30</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">程序运行结果如下：</span></span><br><span class="line"><span class="string">调用基类base的show函数</span></span><br><span class="line"><span class="string">a=50  b=50</span></span><br><span class="line"><span class="string">调用基类base的show函数</span></span><br><span class="line"><span class="string">a=10  b=20</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure><p><strong>如果在派生类中没有对基类的虚函数重新定义,则公有派生类继承其直接基类的虚函数。一个虚函数无论被公有继承多少次,它仍然保持其虚函数的特性。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B0</span>&#123;</span><br><span class="line">   . . .</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;. . .&#125; <span class="comment">//在基类B0中,定义show为虚函数</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">public</span> B0&#123;</span><br><span class="line">    ...    <span class="comment">//若在公有派生类B1中没有重新定义虚函数show,则函数show在派生类中被继承,仍是虚函数。</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h4 id="动态多态满足条件">动态多态满足条件</h4><h5 id="有继承关系"><code>1.有继承关系</code></h5><h5id="子类要重写父类的虚函数这时virtual可以不写-virtual-void-speak和void-speak相同-重写函数名相同形参列表函数返回值类型都完全相同"><code>2.子类要重写父类的虚函数，这时virtual可以不写 virtual void speak()和void speak()相同   重写：函数名相同，形参列表，函数返回值类型都完全相同</code></h5><h4 id="动态多态的使用">动态多态的使用</h4><h5id="父类的指针或引用-指向子类对象"><code>父类的指针或引用 指向子类对象</code></h5><h3 id="动态多态的原理">动态多态的原理</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272117027.png"alt="屏幕截图_20230409_171013" /><figcaption aria-hidden="true">屏幕截图_20230409_171013</figcaption></figure><h3id="cat类中重写speak函数与否的原理上边没有重写下边重写了">cat类中重写speak函数与否的原理（上边没有重写，下边重写了）</h3><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272118997.png"alt="屏幕截图_20230409_171528" /><figcaption aria-hidden="true">屏幕截图_20230409_171528</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272118072.png"alt="屏幕截图_20230409_171800" /><figcaption aria-hidden="true">屏幕截图_20230409_171800</figcaption></figure><h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3><h6id="在多态中通常父类中虚函数的实现是毫无意义的主要都是调用子类重写的内容">在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</h6><h6id="语法virtual-返回值类型-函数名-形参列表0当类中有了纯虚函数这个类就称为抽象类">语法：<code>virtual 返回值类型 函数名 (形参列表)</code>=0，当类中有了纯虚函数，这个类就称为抽象类</h6><p>抽象类：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类（父类）中的纯虚函数，否则也属于抽象类，无法实例化对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;func函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Base b; 抽象类无法实例化对象</span></span><br><span class="line">    <span class="comment">// new Base; 抽象类无法实例化对象</span></span><br><span class="line">    </span><br><span class="line">    Son s; <span class="comment">//子类必须重写父类中的纯虚函数，否则无法实例化对象</span></span><br><span class="line">    </span><br><span class="line">    Base *base=<span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;<span class="built_in">func</span>(); <span class="comment">//func函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6id="多态多态的作用就是为了使函数接口更通用化通过一个父类的指针或引用因为创造的对象不同可以调用多种形态的函数"><code>多态：多态的作用就是为了使函数接口更通用化，通过一个父类的指针或引用，因为创造的对象不同，可以调用多种形态的函数</code></h6><h3 id="虚析构和纯虚析构">虚析构和纯虚析构</h3><p>多态使用时，如果子类中有些属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><ul><li><p>虚析构函数没有类型,也没有参数。</p></li><li><p>如果将基类的析构函数定义为虚函数,由该基类所派生的所有派生类的析构函数也都自动成为虚函数。</p></li><li><p>在C++中,不能声明虚构造函数,但是可以声明虚析构函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>   <span class="comment">//本程序只执行了基类B的析构函数,而没有执行派生类D的析构函数。原因是当撤销指针P所指的派生类的无名对象, 调用析构函数时,采用了静态联编方式,只调用了基类B的析构函数。 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">B</span>()</span><br><span class="line"> &#123; cout&lt;&lt;<span class="string">&quot;调用基类B的析构函数\n&quot;</span>;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   ~<span class="built_in">D</span>()</span><br><span class="line"> &#123; cout&lt;&lt;<span class="string">&quot;调用派生类D的析构函数\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; B *p;           <span class="comment">//定义指向基类B的指针变量p </span></span><br><span class="line">  p= <span class="keyword">new</span> D;   <span class="comment">//运算符new为派生类的无名对象动态地 分配了一个存储空间,并将地址赋给对象指针p</span></span><br><span class="line">  <span class="keyword">delete</span> p;   <span class="comment">//用delete撤销无名对象,释放动态存储空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//程序运行的结果为:调用基类B的析构函数</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>   <span class="comment">// 虚析构函数的使用。</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">B</span>()</span><br><span class="line"> &#123; cout&lt;&lt;<span class="string">&quot;调用基类B的析构函数\n&quot;</span>;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   ~<span class="built_in">D</span>()</span><br><span class="line"> &#123; cout&lt;&lt;<span class="string">&quot;调用派生类D的析构函数\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; B *p;           <span class="comment">//定义指向基类B的指针变量p </span></span><br><span class="line">  p= <span class="keyword">new</span> D; </span><br><span class="line">  <span class="keyword">delete</span> p;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">//程序运行的结果为:调用派生类D的析构函数调用基类B的析构函数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Animal构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用虚析构可以解决 父类指针释放子类对象时不干净的问题</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    virtual ~Anmial()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;&quot;Animal析构函数调用&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//纯虚析构 需要声明也需要实现</span></span><br><span class="line">    <span class="comment">//有了纯虚析构之后，这个类也属于抽象类，无法实例化对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()=<span class="number">0</span>;  <span class="comment">//声明</span></span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">spesk</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()  <span class="comment">//shi&#x27;xia</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Animal纯虚析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_Name=<span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;*m_Name&lt;&lt;<span class="string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_Name!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Cat析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string *m_Name; <span class="comment">//将小猫的名字创建在堆区,用指针维护</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal* animal=<span class="keyword">new</span> Cat;  <span class="comment">//父类指针指向子类对象 多态</span></span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//父类的指针在析构时不会调用子类中析构函数，导致子类如果有堆区属性，会有泄露情况，解决办法是把Animal析构函数变成纯虚构函数</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();  <span class="comment">//Animal构造函数调用  Cat构造函数调用 Tom小猫在说话 Animal析构函数调用 此时还没有Cat析构函数调用的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>由于抽象类中至少包含有一个没有定义功能的纯虚函数,因此抽象类只能用作其他类的基类,不能建立抽象类对象。</p></li><li><p>不允许从具体类派生出抽象类。所谓具体类，就是不包含纯虚函数的普通类;</p></li><li><p>抽象类不能用作函数的参数类型、函数的返回类型或显式转换的类型;</p></li><li><p>可以声明指向抽象类的指针或引用，此指针可以指向它的派生类，进而实现多态性。</p></li><li><p>在派生类中,如果对基类的纯虚函数没有重新定义,则该函数在派生类中仍是纯虚函数,该派生类仍为抽象类。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数分文件编写&quot;&gt;函数分文件编写&lt;/h2&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C++Project</title>
    <link href="https://pipi1002.github.io/2023/02/23/C++Project/"/>
    <id>https://pipi1002.github.io/2023/02/23/C++Project/</id>
    <published>2023-02-23T02:38:33.000Z</published>
    <updated>2024-02-27T13:13:22.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c语言程序设计">C++语言程序设计</h1><h2id="五只小猪称体重在一个数组中找到最大值">五只小猪称体重(在一个数组中找到最大值)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">300</span>,<span class="number">350</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">250</span>&#125;</span><br><span class="line"><span class="comment">//算法：认定MAX为最大值，访问数组中每个元素，如果这个元素比我认定的最大值大，则更新最大值</span></span><br><span class="line">    <span class="type">int</span> MAX=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            MAX=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印最大值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;最重的小猪体重为:&quot;</span>&lt;&lt;MAX&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2id="数组元素逆置如原数组元素为12345逆置后输出结果为54321">数组元素逆置(如原数组元素为1，2，3，4，5逆置后输出结果为5，4，3，2，1)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start=<span class="number">0</span>;<span class="comment">//起始元素的下标</span></span><br><span class="line">    <span class="type">int</span> end=<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]<span class="number">-1</span>);<span class="comment">//末尾元素下标</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//start和end下标元素进行互换(创建临时变量)</span></span><br><span class="line">      <span class="type">int</span> temp=arr[start];</span><br><span class="line">      arr[start]=arr[end];</span><br><span class="line">      arr[end]=temp;</span><br><span class="line">      atart++;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;数组元素更新后：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体案例">结构体案例</h2><h5id="案例1学校正在做毕设项目每名老师带领5个学生总共有三名老师需求如下">案例1：学校正在做毕设项目，每名老师带领5个学生，总共有三名老师，需求如下</h5><h6id="设计学生和老师的结构体其中在老师的结构体中有老师姓名和一个存放5名学生的数组作为成员学生的成员有姓名考试分数创建数组存放3名老师通过函数给每个老师及所带的学生赋值最终打印出老师数据以及老师所带的学生数据">设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员，学生的成员有姓名，考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值，最终打印出老师数据以及老师所带的学生数据</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iosteam&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生的结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string sName;</span><br><span class="line">    <span class="comment">//分数</span></span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//老师的结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string tName;</span><br><span class="line">    <span class="comment">//学生数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> sArray[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给老师和学生赋值的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(<span class="keyword">struct</span> Teacher tArray[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string nameSeed=<span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)<span class="comment">//外侧for循环给老师进行赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先赋值老师姓名</span></span><br><span class="line">        tArray[i].tName=<span class="string">&quot;Teacher_&quot;</span>;</span><br><span class="line">        tArray[i].tName+=nameSeed[i];<span class="comment">//相当于追加一个字母</span></span><br><span class="line">        <span class="comment">//通过内循环给每个老师带的学生赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tArray[i].sArray[j].sName=<span class="string">&quot;Student_&quot;</span>;</span><br><span class="line">            tArray[i].sArray[j].sname+=nameSeed[j];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//给分数是一个随机值</span></span><br><span class="line">            <span class="type">int</span> random=<span class="built_in">rand</span>()%<span class="number">61</span>+<span class="number">40</span>;  <span class="comment">//0+40~60+40</span></span><br><span class="line">            tArray[i].sArray[j].score=random;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印所有信息的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printinfo</span><span class="params">(<span class="keyword">struct</span> Teacher tArray[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//遍历老师</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;老师姓名:&quot;</span>&lt;&lt;tArray[i].tName&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;\t学生姓名:&quot;</span>&lt;&lt;tArray[i].sArray[j].sName&lt;&lt;<span class="string">&quot; 考试分数:&quot;</span>&lt;&lt;tArray[i].sArray[j].score&lt;&lt;endl;  <span class="comment">//\t空格效果更明显</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">//创建3名老师的数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Teacher</span> tArray[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//通过函数给3名老师的信息赋值，并给老师带的学生信息赋值</span></span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">sizeof</span>(tArray)/<span class="built_in">sizeof</span>(tArray[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">allocateSpace</span>(tArray,len);</span><br><span class="line">    <span class="comment">//打印所有老师及所带的学生信息</span></span><br><span class="line">    <span class="built_in">printInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5id="案例2设计一个英雄的结构体包括成员姓名年龄性别创建结构体数组数组中存放5名英雄通过冒泡排序的算法将数组中的英雄按照年龄进行升序排序最终打印排序后的结果">案例2：设计一个英雄的结构体，包括成员姓名，年龄，性别；创建结构体数组，数组中存放5名英雄，通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</h5><p>五名英雄信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;刘备&quot;,23,&quot;男&quot;&#125;</span><br><span class="line">&#123;&quot;关羽&quot;,22,&quot;男&quot;&#125;</span><br><span class="line">&#123;&quot;张飞&quot;,20,&quot;男&quot;&#125;</span><br><span class="line">&#123;&quot;赵云&quot;,21,&quot;男&quot;&#125;</span><br><span class="line">&#123;&quot;貂蝉&quot;,19,&quot;女&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//英雄的结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hero</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序，实现年龄升序排列的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">struct</span> Hero heroArray[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(heroArray[j].age&gt;heroArray[j+<span class="number">1</span>],age)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">Hero</span> temp=heroArray[j];  <span class="comment">//定义temp的数据类型要为struct Hero</span></span><br><span class="line">                heroArray[j]=heroArray[j+<span class="number">1</span>];</span><br><span class="line">                heroArray[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHero</span><span class="params">(<span class="keyword">struct</span> Hero heroArray[],<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;排序后排序:&quot;</span>&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;heroArray[i].name&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;heroArray[i].age&lt;&lt;<span class="string">&quot;性别:&quot;</span>&lt;&lt;heroArray[i].sex&lt;&lt;endl</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.设计英雄结构体</span></span><br><span class="line">    <span class="comment">//2.创建数组存放5名英雄</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Hero</span> heroArray[<span class="number">5</span>]=</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">sizeof</span>(heroArray)/<span class="built_in">sizeof</span>(heroArray[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//排序前打印</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;heroArray[i].name&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;heroArray[i].age&lt;&lt;<span class="string">&quot;性别:&quot;</span>&lt;&lt;heroArray[i].sex&lt;&lt;endl</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.对数组进行排序，按照年龄进行升序排序</span></span><br><span class="line">    <span class="built_in">bubbleSort</span>(heroArray,len);</span><br><span class="line">    <span class="comment">//4.将排序后的结果排序输出</span></span><br><span class="line">    <span class="built_in">printHero</span>(HeroArray,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通讯录管理系统">通讯录管理系统</h2><ul><li><h6id="添加联系人向通讯录中添加新人信息包括姓名性别年龄联系电话家庭住址最多纪录1000人">添加联系人：向通讯录中添加新人，信息包括（姓名，性别，年龄，联系电话，家庭住址）最多纪录1000人</h6></li><li><h6id="显示联系人显示通讯录中所有联系人信息">显示联系人：显示通讯录中所有联系人信息</h6></li><li><h6id="删除联系人按照姓名进行删除指定联系人">删除联系人：按照姓名进行删除指定联系人</h6></li><li><h6id="查找联系人按照姓名查看指定联系人信息">查找联系人：按照姓名查看指定联系人信息</h6></li><li><h6id="修改联系人按照姓名重新修改指定联系人">修改联系人：按照姓名重新修改指定联系人</h6></li><li><h6id="清空联系人清空通讯录里全部信息">清空联系人：清空通讯录里全部信息</h6></li><li><h6id="退出通讯录退出当前使用的通讯录">退出通讯录：退出当前使用的通讯录</h6></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单功能 1.封装函数显示界面  2.在main函数中调用封装好的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  1,添加联系人  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  2,显示联系人  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  3,删除联系人  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  4,查找联系人  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  5,修改联系人  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  6,清空联系人  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*****  0,退出通讯录  *****&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建通讯录结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Addressbooks</span> abs;</span><br><span class="line">    <span class="comment">//初始化通讯录中当前人员个数</span></span><br><span class="line">    abs.m_Size=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> select=<span class="number">0</span>;  <span class="comment">//创建用户选择输入的变量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//展示菜单调用</span></span><br><span class="line">    <span class="built_in">showMenu</span>();</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;select;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//退出功能</span></span><br><span class="line">    <span class="keyword">switch</span>(switch_on)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//添加联系人</span></span><br><span class="line">            <span class="built_in">addPerson</span>(&amp;abs);<span class="comment">//利用地址传递可以在形参中修改实参</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//显示联系人</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//删除联系人</span></span><br><span class="line">            <span class="built_in">deletePerson</span>(&amp;abs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//查找联系人</span></span><br><span class="line">            <span class="built_in">findPerson</span>(&amp;abs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:  <span class="comment">//修改联系人 </span></span><br><span class="line">            <span class="built_in">modifyPerson</span>(&amp;abs);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:  <span class="comment">//清空联系人</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出通讯录</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;欢迎下次使用&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">//按下任意键退出</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一，添加联系人功能</span></span><br><span class="line"><span class="number">1.</span>设计联系人结构体：姓名，性别，年龄，联系电话，家庭住址</span><br><span class="line"><span class="number">2.</span>设计通讯录结构体</span><br><span class="line"><span class="number">3.</span>main函数中创建通讯录</span><br><span class="line"><span class="number">4.</span>封装添加联系人函数</span><br><span class="line"><span class="number">5.</span>测试添加联系人功能</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000<span class="comment">//最大人数</span></span></span><br><span class="line"><span class="comment">//设计联系人结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="comment">//性别  1.男 2.女</span></span><br><span class="line">    <span class="type">int</span> m_Sex;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">int</span> mPhone;</span><br><span class="line">    <span class="comment">//住址</span></span><br><span class="line">    string m_Addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计通讯录结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Addressbooks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通讯录中保存的联系人数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> personArrray[MAX];</span><br><span class="line">    <span class="comment">//通讯录中当前记录的联系人个数</span></span><br><span class="line">    <span class="type">int</span> m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addPerson</span><span class="params">(<span class="keyword">struct</span> Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判读通讯录是否已满，如果满了就不在添加</span></span><br><span class="line">    <span class="keyword">if</span>(abs-&gt;m_Size==MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;通讯录已满，无法添加！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//添加具体联系人</span></span><br><span class="line">        <span class="comment">//姓名</span></span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入联系人:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Name=name;</span><br><span class="line">        <span class="comment">//性别</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入性别:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;1----男&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;2----女&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> sex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sex==<span class="number">1</span>||sex==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            abs-&gt;personArray[abs-&gt;m_Size].m_Sex=sex;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//年龄</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入年龄:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Age=age;</span><br><span class="line">        <span class="comment">//电话</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入联系电话:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        string Phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;persomArray[abs-&gt;m_Size].m_Phone=phone;</span><br><span class="line">        <span class="comment">//住址</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入家庭住址:&quot;</span>&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[abs-&gt;m_Size].m_Addr=address;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新通讯录人数</span></span><br><span class="line">        abs-&gt;m_Size++;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;添加成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//请按任意键继续</span></span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清屏操作        </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二，显示联系人，判断如果当前通讯录中没有人员，就提示记录为空，人数大于0，显示通讯录中信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断通讯录中人数是否为0，如果为0，提示记录为空</span></span><br><span class="line">    <span class="comment">//如果不为0，显示记录的联系人信息</span></span><br><span class="line">    <span class="keyword">if</span>(abs-&gt;m_Size==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;当前记录为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;姓名：&quot;</span>&lt;&lt;abs-&gt;personArray[i].m_Name&lt;&lt;<span class="string">&quot;\t&quot;</span>; <span class="comment">//水平制表符，其中8个空格</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;性别：&quot;</span>&lt;&lt;(abs-&gt;personArray[i].m_Sex==<span class="number">1</span>?<span class="string">&quot;男&quot;</span>:<span class="string">&quot;女&quot;</span>)&lt;&lt;<span class="string">&quot;\t&quot;</span>;  <span class="comment">//男女改变显示效果</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;年龄：&quot;</span>&lt;&lt;abs-&gt;personArray[i].m_Age&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;电话：&quot;</span>&lt;&lt;abs-&gt;personArray[i].m_Phone&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;住址：&quot;</span>&lt;&lt;abs-&gt;personArray[i].m_Addr&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//按任意键继续</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);<span class="comment">//清除屏幕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三，删除联系人</span></span><br><span class="line"><span class="comment">//封装检测联系人是否存在的函数，先判断用户输入的联系人是否存在，如果存在删除，不存在提示用户没有要删除的联系人，因此可以把检测联系人是否存在封装成一个函数中，如果存在，返回联系人在通讯录的位置，不存在返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isExist</span><span class="params">(Addressbooks *abs,string name)</span><span class="comment">//参数一 通讯录，参数二 对比姓名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(abs-&gt;personArray[i].m_Name==name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//找到了，返回这个人在数组中的下标编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果遍历结束都没有找到，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deletePerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要删除的联系人&quot;</span>&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ret==-1  未查到</span></span><br><span class="line">    <span class="comment">//ret!=-1  查到了</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">isExist</span>(abs,name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(ret!<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//查到此人进行删除操作</span></span><br><span class="line">        <span class="comment">//需要知道要删除的人在数组中对应的下标，将他之后的数据向前移动，并且让通讯录里人员个数进行一个减一的操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ret;i&lt;abs-&gt;m_Size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//数据前移动操作</span></span><br><span class="line">            abs-&gt;personArray[i]=abs-&gt;personArray[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        abs-&gt;personArray[i]=abs-&gt;personArray[i+<span class="number">1</span>];</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;删除成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;未查到此人&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//四，查找联系人</span></span><br><span class="line"><span class="comment">//判断用户指定联系人是否存在，如果显示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入您要查找的联系人&quot;</span>&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    <span class="comment">//判断指定的联系人是否存在通讯录中</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">isExist</span>(abs,name);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">-1</span>)<span class="comment">//找到联系人</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;abs-&gt;personArray[ret].m_Name&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;性别:&quot;</span>&lt;&lt;abs-&gt;personArray[ret].m_Sex&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;年龄:&quot;</span>&lt;&lt;abs-&gt;personArray[ret].m_Age&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;abs-&gt;personArray[ret].m_Phone&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;姓名:&quot;</span>&lt;&lt;abs-&gt;personArray[ret].m_Addr&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//未找到联系人</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查无此人&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//任意键按下后  清屏</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//五，修改联系人</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请您输入要修改的联系人&quot;</span>&lt;&lt;endl;</span><br><span class="line">    string name;</span><br><span class="line">    cin&gt;&gt;name;</span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">isExist</span>(abs,name);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">-1</span>)<span class="comment">//找到指定联系人</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//姓名</span></span><br><span class="line">        string name;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入姓名：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        abs-&gt;personArray[ret].m_Name=name;</span><br><span class="line">        <span class="comment">//性别</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入性别：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;1---男&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;2---女&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> sex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          cin&gt;&gt;sex;</span><br><span class="line">          <span class="keyword">if</span>(sex==<span class="number">1</span>||sex==<span class="number">2</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//输入正确退出循环输入</span></span><br><span class="line">            abs-&gt;personArray[ret].m_Sex=sex;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;输入有误，请重新输入&quot;</span>&lt;&lt;endl;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//年龄</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入年龄：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;age;</span><br><span class="line">        abs-&gt;personArray[ret].m_Age=age;</span><br><span class="line">        <span class="comment">//电话</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入联系电话：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        string phone;</span><br><span class="line">        cin&gt;&gt;phone;</span><br><span class="line">        abs-&gt;personArray[ret].m_Phone=phone;</span><br><span class="line">        <span class="comment">//住址</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入家庭住址：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        string address;</span><br><span class="line">        cin&gt;&gt;address;</span><br><span class="line">        abs-&gt;personArray[ret].m_Adde=address;</span><br><span class="line">        </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;修改成功!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//未找到</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;查无此人&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//六，清空联系人</span></span><br><span class="line"><span class="comment">//只需要将通讯录中记录的联系人数量为0，做逻辑清空即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanPerson</span><span class="params">(Addressbooks * abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    abs-&gt;m_Size=<span class="number">0</span>;<span class="comment">//将当前记录联系人数量置为0，做逻辑清空操作</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;通讯录已经清空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计立方体类">设计立方体类</h2><h3id="求出立方体的面积和体积分别用全局函数和成员函数判断两个立方体是否相等">(求出立方体的面积和体积，分别用全局函数和成员函数判断两个立方体是否相等)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建立方体的类</span></span><br><span class="line"><span class="comment">//设计属性和行为</span></span><br><span class="line"><span class="comment">//设计行为 获取立方体的面积和体积</span></span><br><span class="line"><span class="comment">//分别利用全局函数和成员函数 判断两个立方体是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_L;</span><br><span class="line">    <span class="type">int</span> m_W;</span><br><span class="line">    <span class="type">int</span> m_H;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置接口</span></span><br><span class="line">    <span class="comment">//设置宽</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_L=w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取宽</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_L=l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_L;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置高</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_H=h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取高</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取立方体的面积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">caculateS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*m_L*m_W+<span class="number">2</span>*m_W*m_H+<span class="number">2</span>*m_L*m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取立方体的体积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_L*m_W*m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用成员函数判断两个立方体是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameByClass</span><span class="params">(Cube &amp;c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_L==c.<span class="built_in">getL</span>()m_W==c.<span class="built_in">getW</span>()&amp;&amp;m_H==c.<span class="built_in">getH</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用全局函数判断 两个立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(Cube &amp;c1,Cube &amp;c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c1.<span class="built_in">getL</span>()==c2.<span class="built_in">getL</span>()&amp;&amp;c1.<span class="built_in">getW</span>()==c2.<span class="built_in">getW</span>()&amp;&amp;c1.<span class="built_in">getH</span>()==c2.<span class="built_in">getH</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建立方体的对象</span></span><br><span class="line">    Cube c1;</span><br><span class="line">    c1.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">setW</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">steH</span>(<span class="number">10</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c1的面积为:&quot;</span>&lt;&lt;c1.<span class="built_in">calculateS</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c1的体积为:&quot;</span>&lt;&lt;c1.<span class="built_in">calculateV</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建第二个立方体</span></span><br><span class="line">    Cube c2;</span><br><span class="line">    c2.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">setW</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">steH</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//利用全局函数判断</span></span><br><span class="line">    <span class="type">bool</span> ret=<span class="built_in">isSame</span>(c1,c2);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;c1和c2是相等的&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;c1和c2不相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用成员函数判断</span></span><br><span class="line">    <span class="type">bool</span> ret=<span class="built_in">isSame</span>(c1,c2);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成员函数判断 c1和c2是相等的&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;成员函数判断 c1和c2不相等&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计点和圆的关系">设计点和圆的关系</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断点到圆心的距离和半径进行比较</span></span><br></pre></td></tr></table></figure><h2 id="多态案例-----计算器类">多态案例-----计算器类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别利用普通或者多态的技术实现计算器</span></span><br><span class="line"><span class="comment">//普通写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&quot;+&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> m_Num1+m_Num2;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&quot;-&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> m_Num1-m_Num2;</span><br><span class="line">        <span class="keyword">if</span>(oper==<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> m_Num1*m_Num2;</span><br><span class="line">        <span class="comment">//如果想扩展新的功能，需要修改源码</span></span><br><span class="line">        <span class="comment">//在真实开发中 提倡 开闭原则：对扩展进行开放，对修改进行关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> text01</span><br><span class="line">&#123;</span><br><span class="line">    Calculator c;</span><br><span class="line">    c.m_Num1=<span class="number">10</span>;</span><br><span class="line">    c.m_Num2=<span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;c.m_Num1&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;c.m_Num2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c.m_Num1&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;c.m_Num2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c.m_Num1&lt;&lt;<span class="string">&quot;*&quot;</span>&lt;&lt;c.m_Num2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多态写法实现计算器</span></span><br><span class="line"><span class="comment">//多态好处：</span></span><br><span class="line"><span class="comment">/*1.组织结构清晰</span></span><br><span class="line"><span class="comment">  2.可读性强</span></span><br><span class="line"><span class="comment">  3.对于后期扩展和维护性高，不需要对源码更正</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器的抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设计加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span>:<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1+m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设计减法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span>:<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1-m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设计乘法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span>:<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1*m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//父类的指针或引用指向子类对象</span></span><br><span class="line">    <span class="comment">//加法运算</span></span><br><span class="line">    AbstractCalculator *abc=<span class="keyword">new</span> AddCalculator;<span class="comment">//new AddCalculator相当于创建了一个子类对象</span></span><br><span class="line">    abc-&gt;m_Num1=<span class="number">10</span>;</span><br><span class="line">    abc-&gt;m_Num2=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;abc-&gt;m_Num1&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;abc-&gt;m_Num2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;abc-&gt;<span class="built_in">getResult</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//用完后记得销毁</span></span><br><span class="line">    <span class="keyword">delete</span> abc;  <span class="comment">//把堆区数据释放，但指针类型没有变</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减法运算</span></span><br><span class="line">    abc=<span class="keyword">new</span> SubCalculator;  <span class="comment">//现在还相当于父类指针指向子类对象</span></span><br><span class="line">    abc-&gt;m_Num1=<span class="number">100</span>;</span><br><span class="line">    abc-&gt;m_Num2=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;abc-&gt;m_Num1&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;abc-&gt;m_Num2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;abc-&gt;<span class="built_in">getResult</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//乘法运算</span></span><br><span class="line">    abc=<span class="keyword">new</span> SubCalculator;  </span><br><span class="line">    abc-&gt;m_Num1=<span class="number">100</span>;</span><br><span class="line">    abc-&gt;m_Num2=<span class="number">100</span>;</span><br><span class="line">    cout&lt;&lt;abc-&gt;m_Num1&lt;&lt;<span class="string">&quot;*&quot;</span>&lt;&lt;abc-&gt;m_Num2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;abc-&gt;<span class="built_in">getResult</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">    <span class="built_in">text02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态案例-----制作饮品">多态案例-----制作饮品</h2><p>大致流程：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p><h6id="提供抽象制作饮品类提供子类制作咖啡和茶叶">提供抽象制作饮品类，提供子类制作咖啡和茶叶</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//煮水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//制作饮品</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeDrink</span><span class="params">()</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Boil</span>();</span><br><span class="line">        <span class="built_in">Brew</span>();</span><br><span class="line">        <span class="built_in">PourInCup</span>();</span><br><span class="line">        <span class="built_in">PutSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span>:<span class="keyword">public</span> AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//煮水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;煮农夫山泉&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;冲泡咖啡&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;倒入杯中&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;加入糖和牛奶&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span>:<span class="keyword">public</span> AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//煮水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;煮矿泉水&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;冲泡茶叶&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;倒入杯中&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;加入枸杞&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dowork</span><span class="params">(AbstractDrinking *abs)</span><span class="comment">//AbstractDrinking *abs=new Coffee </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    abs-&gt;<span class="built_in">makeDrink</span>();</span><br><span class="line">    <span class="keyword">delete</span> abs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//制作咖啡</span></span><br><span class="line">    <span class="built_in">dowork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//制作茶叶</span></span><br><span class="line">    <span class="built_in">dowork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="new创建对象是否调用构造函数和析构函数">new创建对象是否调用构造函数和析构函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">point</span>()&#123;number++;&#125;</span><br><span class="line">    ~<span class="built_in">point</span>()&#123;number--;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> point::number=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    point *ptr; <span class="comment">//指针不会调用构造函数和析构函数，只是定义了一个指针，没有申请内存</span></span><br><span class="line">    point A,B;<span class="comment">//调用构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        point *ptr_point=<span class="keyword">new</span> point[<span class="number">3</span>]; <span class="comment">//调用三次构造函数  使用new创建对象时，申请分配内存调用构造函数</span></span><br><span class="line">        ptr=ptr_point;</span><br><span class="line">    &#125;</span><br><span class="line">    point C;</span><br><span class="line">    <span class="keyword">delete</span>[]ptr;  <span class="comment">//调用析构函数释放内存，3次，因为ptr数组有三个元素</span></span><br><span class="line">    cout&lt;&lt;point::number&lt;&lt;endl;  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态案例-----电脑组装">多态案例-----电脑组装</h2><h4 id="案例描述">案例描述：</h4><p>电脑主要组成部件为CPU(用于计算)，显卡(用于显示)，内存条(用于存储)</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如intel厂商和lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组转不同的三台电脑进行工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象不同零件类</span></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的计算函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的显示函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的显示函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>(CPU *cpu,VideoCard *vc,Memory *mem)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cpu=cpu;</span><br><span class="line">        m_vc=vc;</span><br><span class="line">        m_mem=mem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个工作函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//让零件工作起来调用接口</span></span><br><span class="line">        m_cpu-&gt;calculate;</span><br><span class="line">        </span><br><span class="line">        m_vc-&gt;display;</span><br><span class="line">        </span><br><span class="line">        m_mem-&gt;storage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个析构函数来释放电脑零件</span></span><br><span class="line">    ~<span class="built_in">Computer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//释放CPU零件</span></span><br><span class="line">        <span class="keyword">if</span>(m_cpu!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_cpu;</span><br><span class="line">            m_cpu=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放显卡零件</span></span><br><span class="line">        <span class="keyword">if</span>(m_vc!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_vc;</span><br><span class="line">            m_vc=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放内存条零件</span></span><br><span class="line">        <span class="keyword">if</span>(m_mem!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_mem;</span><br><span class="line">            m_mem=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CPU *m_cpu;<span class="comment">//cpu零件指针</span></span><br><span class="line">    VideoCard *m_vc;</span><br><span class="line">    Memory *m_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现具体厂商封装</span></span><br><span class="line"><span class="comment">//Inter厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterCPU</span>:<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Inter的CPU开始计算了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterVideoCard</span>:<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Inter的显卡开始显示了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterMemory</span>:<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Inter的内存条开始存储了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span>:<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Lenovo的CPU开始计算了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span>:<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Lenovo的显卡开始显示了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span>:<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Lenovo的内存条开始存储了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//组装不同电脑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一台电脑零件</span></span><br><span class="line">    CPU *interCpu=<span class="keyword">new</span> InterCPU;<span class="comment">//父类指针指向子类对象</span></span><br><span class="line">    VideoCard *interCard=<span class="keyword">new</span> InterVideoCard;</span><br><span class="line">    Memory *interMem=<span class="keyword">new</span> InterMemory;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第一台电脑开始工作&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//创建第一台电脑</span></span><br><span class="line">    Computer *computer1=<span class="keyword">new</span> <span class="built_in">Computer</span>(interCpu,interCard,interMem);</span><br><span class="line">    computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer1;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第二台电脑开始工作&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//创建第二台电脑</span></span><br><span class="line">    Computer *computer2=<span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU,<span class="keyword">new</span> LenovoVideoCard,<span class="keyword">new</span> Lenovomemory);</span><br><span class="line">    computer2-&gt;<span class="built_in">work</span>(); </span><br><span class="line">    <span class="keyword">delete</span> computer2;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;第三台电脑开始工作&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//创建第二台电脑</span></span><br><span class="line">    Computer *computer3=<span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU,<span class="keyword">new</span> InterVideoCard,<span class="keyword">new</span> Lenovomemory);</span><br><span class="line">    computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272113549.png"alt="屏幕截图_20230421_163057" /><figcaption aria-hidden="true">屏幕截图_20230421_163057</figcaption></figure><h2id="定义一个描述矩形的类rectangle包括的数据成员有宽width和长length计算矩形周长计算矩形面积改变矩形大小">定义一个描述矩形的类Rectangle，包括的数据成员有宽（width）和长（length）：计算矩形周长；计算矩形面积；改变矩形大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">Rectangle</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">         &#123;  width=a; length=b; &#125;</span><br><span class="line">         <span class="function"><span class="type">int</span> <span class="title">Area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">         </span>&#123;  <span class="keyword">return</span> width*length;  &#125;</span><br><span class="line">         <span class="function"><span class="type">int</span> <span class="title">Periment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;  <span class="keyword">return</span> <span class="number">2</span>*(width+length);  &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">Changesize</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"> </span>&#123;  width=a;  length=b;  &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="keyword">private</span>:</span><br><span class="line">         <span class="type">int</span> width,length;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Rectangle::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;AREA=&quot;</span>&lt;&lt;<span class="built_in">Area</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;PERIMENT=&quot;</span>&lt;&lt;<span class="built_in">Periment</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Rectangle <span class="title">r</span><span class="params">(<span class="number">5</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">        r.<span class="built_in">Print</span>();</span><br><span class="line">r.<span class="built_in">Changesize</span>(<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line">r.<span class="built_in">Print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断1030内的质数">判断10~30内的质数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//该循环体被用来判断10~30中的质数有哪些  11 13 17 19 23 29</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fun</span><span class="params">(<span class="type">long</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> a = <span class="number">10</span>, b = <span class="number">30</span>, l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> m = a; m &lt;= b;)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fun</span>(m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (l++ % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">5</span>) &lt;&lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fun</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sqrtm = (<span class="type">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= sqrtm; i++)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写程序输入1到100内所有的素数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>,k.flag=<span class="number">1</span>;</span><br><span class="line">    k=<span class="built_in">sqrt</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(in j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;      <span class="comment">//一定要加break跳出内循环，要么在这个if后面加上else &#123;flag=1;&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;<span class="string">&quot;为素数&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个判断素数的函数，并输出100-300之间的全部素数之和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> n)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>;i&lt;<span class="number">300</span>;i++)</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">prime</span>(i)) sum+=i;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (n%i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="输出所有的水仙花数所谓水仙花数是指一个3位数其各位数字的立方和等于该数字本身例如153是一个水仙花数因为153135333">输出所有的“水仙花数”，所谓“水仙花数”是指一个3位数，其各位数字的立方和等于该数字本身。例如：153是一个“水仙花数”，因为：153=13+53+33</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k,n;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">100</span>;n&lt;<span class="number">1000</span>;n++)</span><br><span class="line"> &#123;</span><br><span class="line">  i=n/<span class="number">100</span>;  <span class="comment">//这里的i为百位数</span></span><br><span class="line">  j=(n-i*<span class="number">100</span>)/<span class="number">10</span>;  <span class="comment">//这里的j为十位数  或者可以写成n%100/10</span></span><br><span class="line">  k=n%<span class="number">10</span>;    <span class="comment">//这里的k为个位数</span></span><br><span class="line">  <span class="keyword">if</span>(n==i*i*i+j*j*j+k*k*k) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写一个计算n的函数并在主程序中调用该函数计算1-10的阶乘之和即s12310">编写一个计算n!的函数，并在主程序中调用该函数，计算1-10的阶乘之和（即S=1！+2！+3！+…+10!）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">fac</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> f;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;n&lt;0,data error!&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n==<span class="number">0</span>) f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f=<span class="built_in">fac</span>(n<span class="number">-1</span>)*n;  <span class="comment">//用嵌套的方法求出每个数字的阶乘</span></span><br><span class="line"><span class="keyword">return</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">s+=<span class="built_in">fac</span>(i);   <span class="comment">//把每个数字的阶乘相加</span></span><br><span class="line">cout&lt;&lt;”s=”&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="从键盘输入10个正整数输出它们中的最大值最小值和平均值">从键盘输入10个正整数，输出它们中的最大值、最小值和平均值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,max,min,s=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;please input 10 number:&quot;</span>;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">max=min=x;   <span class="comment">//这里把最大值或者最小值都看成第一个数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">1</span>;n&lt;<span class="number">10</span>;n++)</span><br><span class="line">&#123;   cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;max) max=x;</span><br><span class="line"><span class="keyword">if</span> (x&lt;min) min=x;</span><br><span class="line">s+=x;</span><br><span class="line">&#125;</span><br><span class="line">s=s/<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;max=&quot;</span>&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;min=&quot;</span>&lt;&lt;min&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s=&quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="设计一个立方体类box它能计算并输出立方体的体积和表面积">设计一个立方体类Box，它能计算并输出立方体的体积和表面积</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Box类包含三个私有数据成员a(立方体边长)、volume(体积)和area(表面积)，另有两个构造函数以及seta()(设置立方体边长)、getvolume()(计算体积)、getarea()(计算表面积)和disp()(输出结果)。</span></span><br><span class="line"><span class="comment">本题程序如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> a;</span><br><span class="line">    <span class="type">float</span> volume;</span><br><span class="line">    <span class="type">float</span> area;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Box</span>()&#123;&#125;</span><br><span class="line">        <span class="built_in">Box</span>(<span class="type">float</span> r)&#123;a=r;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">seta</span><span class="params">(<span class="type">float</span> r)</span></span>&#123;a=r;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">getvolume</span><span class="params">()</span></span>&#123;volume=a*a*a;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">getarea</span><span class="params">()</span></span>&#123;area=<span class="number">6</span>*a*a;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;体积：&quot;</span>&lt;&lt;volume&lt;&lt;<span class="string">&quot;,表面积：&quot;</span>&lt;&lt;area&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">obj1</span><span class="params">(<span class="number">4.5</span>)</span>,obj2</span>;</span><br><span class="line">    obj2.<span class="built_in">seta</span>(<span class="number">6.4</span>);</span><br><span class="line">    obj1.<span class="built_in">getvolume</span>();</span><br><span class="line">    obj1.<span class="built_in">getarea</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;obj1=&gt;&quot;</span>;</span><br><span class="line">    obj1.<span class="built_in">disp</span>();</span><br><span class="line">    obj2.<span class="built_in">getvolume</span>();</span><br><span class="line">    obj2.<span class="built_in">getarea</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;obj2=&gt;&quot;</span>;</span><br><span class="line">    obj2.<span class="built_in">disp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写一个程序设计一个点类point求两个点之间的距离">编写一个程序，设计一个点类Point，求两个点之间的距离</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#using namespace std;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> i,<span class="type">int</span> j)&#123;x=i;y=j;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gety</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">distance</span><span class="params">(Point &amp;x,Point &amp;y)</span>  <span class="comment">//对象引用作为参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> d;</span><br><span class="line">        d=<span class="built_in">sqrt</span>((p1.<span class="built_in">getx</span>()-p2.<span class="built_in">getx</span>())*(p1.<span class="built_in">getx</span>()-p2.<span class="built_in">getx</span>())+(p1.<span class="built_in">gety</span>()-p2.<span class="built_in">gety</span>())*(p1.<span class="built_in">gety</span>()-p2.<span class="built_in">gety</span>()));</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span>,<span class="title">p2</span><span class="params">(<span class="number">5</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">disp</span>(); cout&lt;&lt;<span class="string">&quot;与&quot;</span>; p2.<span class="built_in">disp</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;之间距离=&quot;</span>&lt;&lt;<span class="built_in">distance</span>(p1,p2)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写一个简单程序要求"><strong>编写一个简单程序，要求：</strong></h2><h3id="用循环实现从键盘上输入20个整数并放入数组">1用循环实现从键盘上输入20个整数并放入数组</h3><h3id="求出数组元素的最大值及数组的平均值并输出">2.求出数组元素的最大值及数组的平均值并输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p[])</span></span>;<span class="comment">//声明求和函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> p[])</span></span>;<span class="comment">//声明求极大值函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> a[<span class="number">20</span>],i=<span class="number">0</span>;<span class="comment">//声明数组</span></span><br><span class="line">   <span class="keyword">while</span>(i&lt;<span class="number">20</span>)<span class="comment">//通过循环从键盘给数组元素赋值</span></span><br><span class="line">   &#123;  cout&lt;&lt;<span class="string">&quot;a[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]=&quot;</span>;</span><br><span class="line">          cin&gt;&gt;a[i];</span><br><span class="line">          i++;</span><br><span class="line">&#125;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;sum ： &quot;</span>&lt;&lt;<span class="built_in">sum</span>(a)&lt;&lt;endl;<span class="comment">//调用求和函数并输出结果</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;max ： &quot;</span>&lt;&lt;<span class="built_in">max</span>(a)&lt;&lt;endl;       <span class="comment">//求极大值函数并输出结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求和函数的实现，形参用数组 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">   s+=p[i];</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求极大值函数的实现，形参用数组 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> maxv=p[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">   <span class="keyword">if</span>(p[i]&gt;maxv)</span><br><span class="line">           maxv=p[i];</span><br><span class="line">   <span class="keyword">return</span> maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写两个函数分别求两个数的最大公约数和最小公倍数">编写两个函数，分别求两个数的最大公约数和最小公倍数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GCD</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span>  <span class="comment">//求最小公倍数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (u % v) &#123;</span><br><span class="line">  <span class="type">int</span> t= u % v;</span><br><span class="line">  u = v;</span><br><span class="line">  v = t;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCM</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span>  <span class="comment">//求最大公倍数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> gcd = <span class="built_in">GCD</span> (u, v);</span><br><span class="line"> <span class="keyword">return</span> u * v / gcd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">cout&lt;&lt;”最大公约数为：”&lt;&lt;<span class="built_in">GCD</span>(x,y)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;”最小公倍数为：”&lt;&lt;<span class="built_in">LCM</span>(x,y)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写一个函数实现用冒泡法对输入的10个整数按由小到大顺序排列">编写一个函数，实现用“冒泡法”对输入的10个整数按由小到大顺序排列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> num[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>-i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">temp=num[j];</span><br><span class="line">num[j]=num[j+<span class="number">1</span>];</span><br><span class="line">num[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入10个整数：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">cin&gt;&gt;num[i];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;排序前：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;num[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="built_in">sort</span>(num);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;排序后：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;num[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;c语言程序设计&quot;&gt;C++语言程序设计&lt;/h1&gt;
&lt;h2
id=&quot;五只小猪称体重在一个数组中找到最大值&quot;&gt;五只小猪称体重(在一个数组中找到最大值)&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>文章</title>
    <link href="https://pipi1002.github.io/2023/01/02/%E6%96%87%E7%AB%A0/"/>
    <id>https://pipi1002.github.io/2023/01/02/%E6%96%87%E7%AB%A0/</id>
    <published>2023-01-02T04:38:42.000Z</published>
    <updated>2024-02-27T13:08:46.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="夕阳">夕阳</h3><p>我们虽然不生活在一起，但是我们拥有同一片天空，我们或许曾同一时间抬头，那我们目光所交汇处便是回忆。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272108142.jpeg"alt="mmexport1671530955562" /><figcaption aria-hidden="true">mmexport1671530955562</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/pipi1002/markdown_pic@main/202402272108313.jpeg"alt="mmexport1671530945556" /><figcaption aria-hidden="true">mmexport1671530945556</figcaption></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;夕阳&quot;&gt;夕阳&lt;/h3&gt;
&lt;p&gt;我们虽然不生活在一起，但是我们拥有同一片天空，我们或许曾同一时间抬头，那我们目光所交汇处便是回忆。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;https://cdn.jsdelivr.net/gh/pipi1002/mar</summary>
      
    
    
    
    <category term="随想" scheme="https://pipi1002.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>EXAM-NOTE-C语言</title>
    <link href="https://pipi1002.github.io/2022/11/20/EXAM-NOTE-C%E8%AF%AD%E8%A8%80/"/>
    <id>https://pipi1002.github.io/2022/11/20/EXAM-NOTE-C%E8%AF%AD%E8%A8%80/</id>
    <published>2022-11-20T12:44:51.000Z</published>
    <updated>2023-06-26T10:55:05.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有以下程序输出的结果为">1.有以下程序,输出的结果为</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> p[<span class="number">20</span>]=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;,q[]=<span class="string">&quot;abc&quot;</span>,r[]=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(p+<span class="built_in">stlen</span>(q),r);<span class="comment">//(p+strlen(q)):意思是多出3(strlen(q))个字符来储存p的前三个字符,strcpy本来是全部覆盖，然后现在从第四个开始覆盖</span></span><br><span class="line">    <span class="comment">//此时数组p内的内容变为&#123;a,b,c,a,b,c,d,e,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0&#125;</span></span><br><span class="line">    <span class="built_in">strcat</span>(p,q);<span class="comment">//数组p内容变为&#123;a,b,c,a,b,c,d,e,a,b,c,\0,\0,\0,\0,\0,\0,\0,\0,\0&#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">sizeof</span>(p),<span class="built_in">strlen</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />20 9</label></li><li><label><input type="checkbox" />9 9</label></li><li><label><input type="checkbox" checked="" />20 11</label></li><li><label><input type="checkbox" />11 11</label></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strcpy会把/0也复制到新的数组中</span></span><br><span class="line"><span class="comment">//strlen会在看到(第一个)/0时停止计数</span></span><br><span class="line">设有</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> str[ ]=<span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line">则执行</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(<span class="built_in">strcpy</span>(str,<span class="string">&quot;China&quot;</span>)));</span><br><span class="line">后的输出结果为  <span class="comment">//A</span></span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked="" />5</label></li><li><label><input type="checkbox" />7</label></li><li><label><input type="checkbox" />12</label></li><li><label><input type="checkbox" />14</label></li></ul><h5 id="注意点">注意点：</h5><ul><li><p>sizeof:计算数组(变量)所占空间大小,注意，\0也是一个字符-----操作符</p></li><li><p>strlen:求字符串长度，到\0就停止，并且\0不算字符串内容，strlen也不把\0计算到字符串长度中</p><p>例子：</p><ul><li><p>char arr1[]="abc";</p><p>char arr2[]={'a','b','c'};</p><p>printf("%d",sizeof(arr1));//4</p><p>printf("%d",sizeof(arr2));//3</p><p>printf("%d",strlen(arr1));//3</p><p>printf("%d",strlen(arr2));//15(随机数)，因为找不到\0,字符串后才有\0</p></li></ul></li><li><p>注意：sizeof求所占空间大小算的是比特位，如果是char类型就×1相当于其中字符个数</p></li><li><p>int arr[]={1,2,3,4} 如果是int类型的就要×4</p><ul><li>sizeof(arr)=4×4=16(bit位)</li></ul></li></ul><h6 id="数组长度的计算方法-sizesizeofarrsizeofarr0">数组长度的计算方法：size=sizeof(arr)/sizeof(arr[0])</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已有定义：<span class="type">char</span> a[ ]= ″xyz″,b[ ]=&#123; ′x′, ′y′, ′z′&#125;;</span><br><span class="line"><span class="comment">//所以a的长度为4，因为a后面默认是有\0的；b的长度为3</span></span><br></pre></td></tr></table></figure><h2 id="下列程序输出结果是">2.下列程序输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> w[][<span class="number">10</span>]=&#123;<span class="string">&quot;ABCD&quot;</span>,<span class="string">&quot;EFGH&quot;</span>,<span class="string">&quot;IJKL&quot;</span>,<span class="string">&quot;MNOP&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;w[k][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解答：FGHKL，%s指输出字符串，所以从起始位置到此行结束的所有字符都将被输出</p><h2 id="下列程序输出结果是-1">3.下列程序输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(&amp;str[<span class="number">0</span>],<span class="string">&quot;NEXT&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(&amp;str[<span class="number">1</span>]),<span class="string">&quot;OR&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(&amp;str[<span class="number">2</span>],<span class="string">&quot;TICE&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> w[][<span class="number">10</span>]=&#123;<span class="string">&quot;ABCD&quot;</span>,<span class="string">&quot;EFGH&quot;</span>,<span class="string">&quot;IJKL&quot;</span>,<span class="string">&quot;MNOP&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;<span class="number">3</span>;k++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,&amp;w[k][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.解答：NOTICE</p><p>注意：数组名通常情况下代表首元素地址（2种情况例外）</p><ul><li>sizeof(数组名)：此时数组名表示整个数组，sizeof(数组名)计算的是整个数组的大小</li><li>&amp;数组名：代表整个数组，&amp;数组名，取出的是整个数组的地址</li><li>strcpy是全部覆盖</li></ul><p>2.解答：FGHKL</p><p>注意：因为输出的是%s的字符串类型，所以会输出头后所有的，一连串输出</p><h2 id="以下程序输出结果是">4.以下程序输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(a/<span class="number">3</span>&gt;<span class="number">0</span>)?a/<span class="number">10</span>:a%s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><label><input type="checkbox" />0</label></p></li><li><p><label><input type="checkbox" />1</label></p></li><li><p><label><input type="checkbox" />10</label></p></li><li><p><label><input type="checkbox" checked="" />3</label></p></li><li><p>三目运算符的运算顺序是从右到左，当a/3是真的就输出a/10;当a/3为假那么输出a%3，因为a/3是判断语句不是赋值语句，所以a/3=10，但是a还是30</p></li></ul><h2 id="ifa5是允许的">5.if(a=5)是允许的</h2><h2 id="以下语句的输出结果是">6.以下语句的输出结果是：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char s[10];</span><br><span class="line">s=&quot;abcd&quot;;</span><br><span class="line">printf(&quot;%s\n&quot;,s);</span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />输出abcd</label></li><li><label><input type="checkbox" />输出a</label></li><li><label><input type="checkbox" checked="" />出现编译错误</label></li><li><label><input type="checkbox" />输出bcd</label></li></ul><p>注意：C语言中无字符串变量，不能直接用赋值语句对一个数组整体赋值</p><h2id="野指针写代码时极易出现的错误">7.野指针(写代码时极易出现的错误)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//野指针1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//未初始化的指针变量（非法访问）</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//局部变量不初始化，里面默认放的是一个随机值</span></span><br><span class="line">*p = <span class="number">20</span>;<span class="comment">//相当于把20放在了内存中随机的一块地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//当编写程序的时候不知道当时要给指针赋予什么样的值那么 int* p=NULL; (void *)0，把0强制转换成void *xing</span></span><br><span class="line"><span class="comment">//野指针2：指针越界访问</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = a;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">*p = i;(*p++=i)</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回局部变量或临时变量的地址</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//局部变量的存在，只在所在大括号内</span></span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">text</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="以下程序输出结果是-1">8. 以下程序输出结果是：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,*p=a,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        a[i]=*p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" checked="" />6</label></li><li><label><input type="checkbox" />8</label></li><li><label><input type="checkbox" />4</label></li><li><label><input type="checkbox" />2</label></li></ul><p>注意：<em>p++运算等价于</em>(p++),先运算地址增值再解引用操作，但由于是p++,所以是先赋值后＋1</p><h2 id="以下函数的类型是">9.以下函数的类型是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fff</span>(<span class="type">float</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x*x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />与参数x的类型相同</label></li><li><label><input type="checkbox" />void型</label></li><li><label><input type="checkbox" checked="" />int型</label></li><li><label><input type="checkbox" />无法决定</label></li></ul><p>注意：只有int类型可以省略在函数名前，是否返回值是取决于项目目的，void类型基本不返回返回值，其他类型也可能没有返回值。</p><h2 id="下列程序的输出结果是">10.下列程序的输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fun</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    c=a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">2</span>,<span class="number">3</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />0</label></li><li><label><input type="checkbox" />1</label></li><li><label><input type="checkbox" />6</label></li><li><label><input type="checkbox" checked="" />无确定值</label></li></ul><p>注意：变量c进入func函数后并没有输出，也没有返回值，并且处理的数据只能在该函数体范围内有效，所以无法确定输出结果</p><h2id="以下不能正确定义二维数组的选项是">11.以下不能正确定义二维数组的选项是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;&#125;;   <span class="comment">//对 </span></span><br><span class="line"><span class="type">int</span> a[][<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;    <span class="comment">//对</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;; <span class="comment">//对</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;<span class="comment">//错</span></span><br></pre></td></tr></table></figure><ul><li>注意：在定义二维数组时，如果对所有元素赋初值，其第1维的长度可以省略</li><li>二维数组初始化也可以只对每一行或若干个行的前若干元素赋初值</li><li>在二维数组定义中不能省略第二维的长度</li></ul><h2 id="以下程序的输出结果为">12.以下程序的输出结果为</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(aa/<span class="number">3</span>&gt;<span class="number">0</span>)?a/<span class="number">10</span>:a%<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针在c语言中的规定">13.指针在C语言中的规定</h2><p>注意：C语言规定，允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_VALUES 5</span></span><br><span class="line"><span class="type">float</span> values[N_VALUES];</span><br><span class="line"><span class="type">float</span> *vp;</span><br><span class="line"><span class="keyword">for</span>(vp=&amp;values[<span class="number">0</span>];vp&lt;&amp;values[N_VALUES];)</span><br><span class="line">&#123;</span><br><span class="line">    *vp++=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_VALUES 5</span></span><br><span class="line"><span class="type">float</span> values[N_VALUES];</span><br><span class="line"><span class="type">float</span> *vp;</span><br><span class="line"><span class="keyword">for</span>(vp=&amp;values[N_VALUES<span class="number">-1</span>];vp&gt;=&amp;values[<span class="number">0</span>];vp--)</span><br><span class="line">&#123;</span><br><span class="line">    *vp=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相比于第二种写法更建议第一种写法</span></span><br></pre></td></tr></table></figure><h2 id="指针与数组">14.指针与数组</h2><ul><li>注意：一般情况下数组名指的就是首元素地址，但是有两个例外：<ul><li>1.&amp;arr- &amp;数组名-数组名不是首元素的地址-数组名表示的是整个数组-&amp;数组名，取出的是整个数组的地址</li><li>sizeof(arr)-sizeof(数组名)-数组名表示的是整个数组-sizeof(数组名)计算的是整个数组的大小</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,arr);<span class="comment">//1.首元素的地址00EFF8E0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,arr+<span class="number">1</span>);<span class="comment">//00EFF8E4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;arr[<span class="number">0</span>]);<span class="comment">//2.首元素地址00EFF8E0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;arr[<span class="number">0</span>]+<span class="number">1</span>);<span class="comment">//00EFF8E4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;arr);<span class="comment">//全部元素地址，虽然打印出来和1,2相同为00EFF8E0，但意义不同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,&amp;arr+<span class="number">1</span>);<span class="comment">//00EFF908(与00EFF8E0相差40，因为跳过一整个数组地址)</span></span><br></pre></td></tr></table></figure><h2 id="以下函数有几个实参">15.以下函数有几个实参</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exece</span>((v1,v2),(v3,v4),v5,v6)</span><br></pre></td></tr></table></figure><p>注意：(v1,v2)和(v3,v4)是两个逗号表达式，结果分别为v2,v4所以一共有4个实参</p><h2 id="栈堆">16.栈，堆</h2><ul><li>栈上保存局部变量和函数形参</li><li>堆上保存全局变量</li></ul><h2 id="下列代码打印出的结果为">17.下列代码打印出的结果为：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    <span class="type">short</span> *p=(<span class="type">short</span>*)arr;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(p+i)=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：将数组arr的首元素地址强制转换为short类型（short类型为2个字节），所以（*p+i）赋值给了数组元素中1，2的这8个字节（先赋值元素1的前两个字节，后赋值1的后两个字节，元素2同理）</p><ul class="task-list"><li><label><input type="checkbox" />1 2 3 4 5</label></li><li><label><input type="checkbox" checked="" />0 0 3 4 5</label></li><li><label><input type="checkbox" />0 0 0 0 5</label></li><li><label><input type="checkbox" />1 0 0 0 0</label></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>×<span class="number">11223344</span>;</span><br><span class="line">    <span class="type">char</span> *pc=(<span class="type">char</span>*)&amp;a;</span><br><span class="line">    *pc=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>内存块的存放方法：倒着存放44 33 2211一共4个字节（44，33，22，11分别占位一个字节）,但是打印时要复原地址顺序</p></li><li><p>char*只能访问一个字节</p></li><li><p><label><input type="checkbox" />00223344</label></p></li><li><p><label><input type="checkbox" />0</label></p></li><li><p><label><input type="checkbox"checked="" />11223300</label></p></li><li><p><label><input type="checkbox" />112233</label></p></li></ul><h2 id="下列代码打印出来的结果是">18.下列代码打印出来的结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//全局变量未初始化默认初始化为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="built_in">sizeof</span>(i))<span class="comment">//sizeof-计算变量/类型所占内存的大小，恒&gt;0(不可能返回负数),为无符号数，一个整数和无符号数进行运算（比较大小，或者加减乘除）的时候，会把这个整数转换为无符号数，再进行计算。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：-1：10000000000000000000000000000001 源码</p><p>​ 11111111111111111111111111111110 反码</p><p>​ 11111111111111111111111111111111 补码</p><ul class="task-list"><li><label><input type="checkbox" checked="" />大于</label></li><li><label><input type="checkbox" />小于</label></li></ul><h2 id="正确的执行结果是">19.正确的执行结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox"checked="" />程序陷入死循环</label></li><li><label><input type="checkbox" />4</label></li><li><label><input type="checkbox" />2</label></li><li><label><input type="checkbox" />3</label></li></ul><p>注意：while();这是一个没有执行语句的while循环：；的位置</p><h2 id="以下程序的输出结果是">20.以下程序的输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123; <span class="type">int</span>  i=<span class="number">010</span> , j = <span class="number">10</span>;  <span class="comment">//010是八进制数，十进制数为8</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,+ +i , j - -); &#125;  <span class="comment">//9，10</span></span><br><span class="line"><span class="comment">//八进制的整数都是以0开头，十六进制的整数以0x开头，在C语言中只有十进制数有负数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="string">&#x27;\72&#x27;</span>;</span><br><span class="line"><span class="comment">//其中、72代表一个字符，72是八进制数，代表ASCII码值的字符&quot;:&quot;</span></span><br></pre></td></tr></table></figure><h2 id="以下程序的输出结果是-1">21.以下程序的输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123; <span class="type">int</span>  a=<span class="number">4</span>,b=<span class="number">5</span>,c=<span class="number">0</span>,d;</span><br><span class="line">d=!a&amp;&amp;!b||!c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d);</span><br><span class="line">&#125;  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li><p>常用的运算符优先级(由高到低)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">!     ++     --</span><br><span class="line"></span><br><span class="line">×     /       %(要求运算时必须为整形)</span><br><span class="line"></span><br><span class="line">+     -</span><br><span class="line"></span><br><span class="line">&lt;&lt;     &gt;&gt;     左移和右移运算符</span><br><span class="line"></span><br><span class="line">＞   ＜     ≥      ≤</span><br><span class="line"></span><br><span class="line">==   !=</span><br><span class="line"></span><br><span class="line">&amp;&amp;</span><br><span class="line"></span><br><span class="line">||</span><br><span class="line"></span><br><span class="line">?:</span><br><span class="line"></span><br><span class="line">+=   -=   *=    </span><br><span class="line"></span><br><span class="line">=</span><br><span class="line"></span><br><span class="line">,</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设有语句<span class="type">int</span>  a=<span class="number">3</span>;则执行了语句a+=a-=a*a;后，变量a的值是 <span class="number">-12</span><span class="comment">//+=和-=的运算按顺序从右向左</span></span><br></pre></td></tr></table></figure><h2 id="下列程序的运行结果是">22.下列程序的运行结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="type">int</span> *k;</span><br><span class="line">   k=a; a=b; b=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;  <span class="type">int</span> a=<span class="number">3</span>, b=<span class="number">6</span>, *x=&amp;a, *y=&amp;b;</span><br><span class="line">   <span class="built_in">fun</span>(x,y);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a, b);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ul><li><p>结果是： 3 6</p></li><li><h5id="形参都是值传递但是这个值是指针的话是可以改变指针指向内容的值即实参的值但是要弄清两个概念指针和指针指向的数据这个例子中形参的值是实参的地址并不是实参的值所以形参的值的改变只是指针的改变即指向数据的地址改变并不是指针指向数据的改变">形参都是值传递，但是这个值是指针的话，是可以改变指针指向内容的值，即实参的值。但是要弄清两个概念：指针和指针指向的数据。这个例子中形参的值是实参的地址，并不是实参的值，所以形参的值的改变只是指针的改变，即指向数据的地址改变，并不是指针指向数据的改变。</h5></li></ul><h2id="执行下面程序中的输出语句后变量-a-的值为逗号表达式">23.执行下面程序中的输出语句后，变量a 的值为(逗号表达式)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span> ( ) </span><br><span class="line">&#123;  <span class="type">int</span>  a ;  <span class="built_in">printf</span> ( “ %d \n ”,  ( a = <span class="number">3</span> * <span class="number">5</span> ,  a * <span class="number">4</span> ,  a + <span class="number">5</span> ) ) ;  &#125;  <span class="comment">//a=15</span></span><br></pre></td></tr></table></figure><ul><li>x=表达式1，表达式2，表达式3；</li></ul><p>因为逗号表达式是优先级最低的表达式，赋值表达式的优先级高，所以会把表达式1的值直接赋值给x</p><ul><li>x=(表达式1，表达式2，表达式3)；</li></ul><p>括号里的先执行，逗号表达式是左结合性，所以会从左往右依次执行，最后再把表达式3的值赋给x</p><h2 id="注意">注意：</h2><p>上面的题是求变量a的值，如果上面的例题变为，求逗号表达式a=2×6，a×3，a＋5的值</p><p>逗号表达式的结果是整个表达式执行完最后的一个值</p><h5id="可以把这个式子看成xa26a3a5-a2612这时表达式的式子为12a3并不是一个赋值语句表达式的值还是12最后xa512517该表达式为17">可以把这个式子看成x=(a=2×6，a×3，a+5)a=2×6=12，这时表达式的式子为12；a×3并不是一个赋值语句，表达式的值还是12；最后x=(a+5)=12+5=17;该表达式为17</h5><h6 id="应用">应用：</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>((exp1,exp2),(exp3,exp4,exp5))  <span class="comment">//2个实参</span></span><br></pre></td></tr></table></figure><p>上述函数调用语句中有几个实参？ 2个</p><h2 id="以下程序的输出结果是-2">24.以下程序的输出结果是</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="literal">NULL</span>); &#125;  <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h2 id="c语言中的定义问题">25.C语言中的定义问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.C语言的基本单位位是函数</span><br><span class="line">2.在宏定义 #define PI 3.14159中，用宏名PI代替是字符串</span><br><span class="line">3.C语言规定，程序中各函数之间既允许直接递归调用也允许间接递归调用</span><br><span class="line">4.指针的算数运算(p为指针变量，px为另一个指针变量)(两个基本类型相同的指针变量不能进行加法运算)</span><br><span class="line">  +    p+n     指针向地址大的方向移动n给数据</span><br><span class="line">  -    p-n     指针向地址小的方向移动n个数据</span><br><span class="line">  ++   p++或++p  指针向地址大的方向移动一个数据</span><br><span class="line">  --   p--或--p  指针向地址小的方向移动一个数据</span><br><span class="line">  -    p-px    注意:两个指针相隔元素的个数</span><br><span class="line">5.C语言程序的三种基本结构是顺序结构、选择结构和循环结构</span><br><span class="line">6.在C语言的条件判断语句中可用任意的表达式来决定分支的流程</span><br><span class="line">7.在C语言中数字029是一个非法数</span><br></pre></td></tr></table></figure><h2 id="或逻辑短路和与逻辑短路">26.或逻辑短路和与逻辑短路</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">设 a=<span class="number">5</span>, b=<span class="number">6</span>, c=<span class="number">7</span>, d=<span class="number">8</span>, m=<span class="number">2</span>, n=<span class="number">2</span>, 执行</span><br><span class="line">(m=a&gt;b)&amp;&amp;(n=c&gt;d)</span><br><span class="line">后n的值为  <span class="comment">//BBB</span></span><br><span class="line"><span class="comment">//短路问题的结论”或(||)“逻辑前面为1，”与(&amp;&amp;)”逻辑前面为0就会短路</span></span><br><span class="line">    <span class="number">1.</span>或逻辑短路</span><br><span class="line">   <span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">6</span>,c=<span class="number">7</span>,d=<span class="number">8</span>,m=<span class="number">2</span>,n=<span class="number">2</span>;</span><br><span class="line">    (m=a&lt;b)||(n=c&gt;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d&quot;</span>,m,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//的结果为1,2,因为a&lt;b,m=1,这个或逻辑就被“短路”掉了,后面的语句就没有执行，所以n还是等于原来的2.||只要有一个为1，结果就为1.因此短路，并且不计算(n=c&gt;d)</span></span><br><span class="line">    <span class="number">2.</span>与逻辑短路</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">6</span>,c=<span class="number">7</span>,d=<span class="number">8</span>,m=<span class="number">2</span>,n=<span class="number">2</span>;</span><br><span class="line">        (m=a&gt;b)&amp;&amp;(n=c&gt;d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d&quot;</span>,m,n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//结果为0，2，因为a&gt;b为0，m=0,整个“与”逻辑就判断为”假“所以后面的“n=c&gt;d”就被忽略掉了，所以n还是等于原来的2</span></span><br><span class="line"><span class="comment">//另外：标准的逻辑与(|)与逻辑或(&amp;),无论第一个表达式为真还是假都计算第二个表达式</span></span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />1</label></li><li><label><input type="checkbox" checked="" />2</label></li><li><label><input type="checkbox" />3</label></li><li><label><input type="checkbox" />4</label></li></ul><h2 id="隐式转换问题">27.隐式转换问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若有定义：<span class="type">int</span> a=<span class="number">8</span>，b=<span class="number">5</span>，C；，执行语句C=a/b+<span class="number">0.4</span>;后，c的值为<span class="comment">//B</span></span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />1.4</label></li><li><label><input type="checkbox" checked="" />1</label></li><li><label><input type="checkbox" />2.0</label></li><li><label><input type="checkbox" />2</label></li></ul><h6 id="注意-1">注意：</h6><p>在使用赋值运算符的时候，当赋值号右边数据类型和左边数据类型不相同时，系统将自动将赋值号右边数据转换成与左边数据相同的数据类型，然后再赋值（这里不是四舍五入，而是取整操作）</p><h2 id="固定位宽问题">28.固定位宽问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下程序段的输出结果是__C___。</span><br><span class="line"><span class="type">int</span>  a=<span class="number">1234</span>；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d\n&quot;</span>,a);  <span class="comment">//1234</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,<span class="number">1</span>);  <span class="comment">//输出_1(_代表空格)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,<span class="number">102</span>);  <span class="comment">//输出102</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,<span class="number">12.23</span>);  <span class="comment">//输出12(强制类型转换，即取整数部分)</span></span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />12</label></li><li><label><input type="checkbox" />34</label></li><li><label><input type="checkbox" checked="" />1234</label></li><li><label><input type="checkbox" />错误</label></li></ul><h2 id="不同类型变量进行运算规则">29.不同类型变量进行运算规则</h2><h6id="系统有默认的转化规则就是从精度低的转化为精度高的避免计算时精度的丢失">系统有默认的转化规则，就是从精度低的转化为精度高的，避免计算时精度的丢失</h6><p>具体转化规则如下：</p><p>char---&gt;short---&gt;int---&gt;unsigned(无符号数)---&gt;long---&gt;unsignedlong---&gt;float---&gt;double</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设有整型变量a，单精度型变量f，双精度型变量x，则表达式a+’b’+x*f值的类型为  </span><br></pre></td></tr></table></figure><ul class="task-list"><li><label><input type="checkbox" />int</label></li><li><label><input type="checkbox" />float</label></li><li><label><input type="checkbox" checked="" />double</label></li><li><label><input type="checkbox" />不能确定</label></li></ul><h2 id="和的运算">30.%和/的运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="keyword">if</span>(<span class="number">3</span>/<span class="number">4</span>&gt;<span class="number">1</span>/<span class="number">2</span>) a=<span class="number">1</span>; <span class="keyword">else</span> a=<span class="number">0</span>;执行该语句后，a的值是   <span class="comment">//0</span></span><br><span class="line">    <span class="comment">//在C语言中3/4 (1/2)等于0;3%4 (1%2)等于3 (1)</span></span><br></pre></td></tr></table></figure><h2 id="合法实性常数的判断规则">31.合法实性常数的判断规则</h2><p>实型常量又称实数或浮点数，在C语言中可以用两种形式来表示一个实型常量1.小数形式2.指数形式</p><p>在C语言中，以“e”或E后跟一个整数来代表以十为底的幂数。其一般形式是aEn，其中a为十进制数，n为十进制整数</p><h6 id="注意-2">注意：</h6><p>C语言规定字母e或E之前必须要有数字，且e或E后面的数只能是整数</p><figure class="highlight c++"><figcaption><span>以下选项中合法的实型常数是</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下选项中合法的实型常数是 <span class="comment">//3</span></span><br><span class="line">    <span class="number">1.</span>  <span class="number">5E2</span><span class="number">.0</span></span><br><span class="line">    <span class="number">2.</span>  E<span class="number">-3</span></span><br><span class="line">    <span class="number">3.</span>  <span class="number">2E0</span></span><br><span class="line">    <span class="number">4.</span>  <span class="number">1.3</span>E</span><br></pre></td></tr></table></figure><h2 id="section">32.</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有以下程序输出的结果为&quot;&gt;1.有以下程序,输出的结果为&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://pipi1002.github.io/2022/11/20/hello-world/"/>
    <id>https://pipi1002.github.io/2022/11/20/hello-world/</id>
    <published>2022-11-20T11:41:33.417Z</published>
    <updated>2023-02-23T02:45:51.818Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h6id="大学生活是人生不可磨灭的记忆你的每一次尝试每一声叹息每一次牵手都在大学四年的日子里沉淀为永恒-大学是我们每一个人梦想的殿堂为了来到这个殿堂我们经历了风风雨雨-既然跨进了这道门槛那么就让我们在这梦想的殿堂里尽情的挥洒个性吧-大学不是幻想不是梦想更不是妄想而是我们伟大的理想-只要我们为之奋斗为之拼搏-总有一天我们会满载而归的那时你会听到枫叶流舟你会看到金菊在笑你会闻到硕果飘香因为你到了收获的季节-大学赐予我一双想飞的翅膀我可以借着它的力量去实现自己理想-我要在今后的生活里积蓄更多的能量给自己加油为自己喝彩相信蝴蝶破茧而出的将会是人生全程-描写大学生活的文章大学生活的感受-大学生活过去了一个学期了在那逝去的半年时光里初步认识到大学生活的作为">大学生活是人生不可磨灭的记忆，你的每一次尝试，每一声叹息，每一次牵手，都在大学四年的日子里沉淀为永恒。大学是我们每一个人梦想的殿堂，为了来到这个殿堂我们经历了风风雨雨。既然跨进了这道门槛，那么就让我们在这梦想的殿堂里尽情的挥洒个性吧。大学不是幻想，不是梦想，更不是妄想，而是我们伟大的理想。只要我们为之奋斗，为之拼搏。总有一天我们会满载而归的!那时你会听到枫叶流舟，你会看到金菊在笑，你会闻到硕果飘香，因为你到了收获的季节大学赐予我一双想飞的翅膀我可以借着它的力量去实现自己理想。我要在今后的生活里积蓄更多的能量，给自己加油，为自己喝彩，相信蝴蝶破茧而出的将会是人生全程描写大学生活的文章：大学生活的感受大学生活过去了一个学期了，在那逝去的半年时光里，初步认识到大学生活的作为。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very
first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; fo</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://pipi1002.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="https://pipi1002.github.io/2022/11/16/HTML/"/>
    <id>https://pipi1002.github.io/2022/11/16/HTML/</id>
    <published>2022-11-16T13:26:33.000Z</published>
    <updated>2023-01-02T04:31:40.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode前端需要安装的插件">1.vscode前端需要安装的插件</h1><ul><li><p>Auto Rename Tag 自动将结尾标签进行更改</p></li><li><p>HTML CSS Support 在html代码中支持css提示</p></li><li><p>HTML Snippets 自动生成html代码，专门针对html代码格式</p></li><li><p>image preview 在代码前预览图片的缩略图</p></li><li><p>IntelliSense for CSS class names in HTML在html中提出css中的class名</p></li><li><p>Live Sever将vscode作为一台服务器，让浏览器进行访问，实时更新数据</p></li><li><p>open in browser可以将网页在不同浏览器打开，需要更新页面数据时需要刷新页面</p></li></ul><h2 id="文本标签">文本标签</h2><ul><li><p>用来组织网页中的文本，不同的文本可以使用不同的文本标签</p><h5 id="标题标签h">标题标签h</h5><p>h1~h6用来组织标题文本，数字越大字号越小，文本变粗，独占一行默认标签上下有间距margin</p><ul><li><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>h1标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>h2标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>h3标签<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>h4标签<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>h5标签<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>h6标签<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="段落标签p">段落标签p</h5><ul><li><p>用来组织段落文本，一个段落就是一个p标签</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">文本</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>p标签不能嵌套</li><li>默认上下有间距margin</li><li>独占一行</li></ul></li></ul><h5id="span标签用来组织简短文本或提示性信息">span标签，用来组织简短文本，或提示性信息</h5><ul><li><h5 id="语法">语法：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>文本<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>span可以同行显示</p><h5 id="label标签">label标签</h5><ul><li><h5id="提供了特殊用途可以搭配表单元素一起使用控制表单元素">提供了特殊用途，可以搭配表单元素一起使用，控制表单元素</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>文本<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>注意：可以同行显示</li></ul></li></ul><h5 id="bstrong标签">b/strong标签</h5><ul><li><p>用来进行文本加粗处理</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure><p>推荐使用strong</p></li></ul><h5 id="iem标签">i/em标签</h5><ul><li><p>用来进行文本斜体处理</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>推荐使用i标签</li></ul></li></ul><h5 id="换行br标签">换行br标签</h5><ul><li><p>用于换行，需要换几行就使用几个br标签</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="分割线hr标签">分割线hr标签</h5><ul><li><p>在页面上加一条直线</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="图片标签">图片标签</h1><ul><li><p>用来连接图片</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;需要连接图片的路径&quot;</span> <span class="attr">title</span>=<span class="string">&quot;图片加载成功时显示的图片&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片加载失败时显示的解释说明文字&quot;</span> <span class="attr">width:</span>&quot;<span class="attr">设置图片的宽度</span>&quot; <span class="attr">heigth:</span>&quot;<span class="attr">设置图片的高度</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>绝对路径：是指目标文件在目录的具体位置</p><p>在开发中指https或者http开头的路径，或者磁盘盘符路径</p></li><li><p>相对路径：是以某个文件为参考找到目标文件的路径</p><p>在开发中，是以当前文件出发，找到目标文件的路径</p></li><li><p>注意：返回上一级 ../</p></li><li><p>宽度和高度只设置一个时等比例缩放，如果都设置图片可能被拉伸，可能会变形</p></li></ul></li></ul><h2 id="超链接标签">超链接标签</h2><ul><li><p>用于网页跳转</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;链接需要跳转到的网页路径&quot;</span> <span class="attr">target</span>=<span class="string">&quot;设置新网页的打开方式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>href：可以是本地路径，也可以是网络路径（必须包含http或https）------推荐使用相对路径</li><li>target：控制新打开的网页的打开方式,_self 在原窗口打开网页,_blank新开窗口打开网页</li></ul></li><li><p>注意：</p><ul><li><p>href=""或者href="#":代表刷新页面</p></li><li><p>锚点：以#id名可以指定跳转到指定位置 href="#id名"</p></li><li><p>id是唯一的，一个网页中不能出现同名的id</p><p>id命名规则：</p><p>​ 是以数字，字母，下划线_，和短横线-构成</p><p>​ 不能以数字开头，不能包含特殊符号</p><h2 id="表格标签">表格标签</h2><ul><li><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">table：代表了一个表格，默认没有边框</span><br><span class="line">        tr:代表的就是行，需要几行就是几个tr,可以设置高度height，会影响整行高度，不能设置宽度width</span><br><span class="line">           align在tr上设置，设置的是该单元格中内容的对齐方式</span><br><span class="line">           bgcolor：设置该行背景颜色</span><br><span class="line">        td：代表的就是列，需要几列就是几个td，可以设置宽度width，会影响整列宽度，不能设置高度height</span><br><span class="line">           align在td上设置，设置的是该单元格中内容的对其方式</span><br><span class="line">           bgcolor：设置该列背景颜色</span><br><span class="line">        border：设置表格的边框</span><br><span class="line">        width：设置表格的宽度</span><br><span class="line">        height：设置表格的高度</span><br><span class="line">        align：设置表格在页面中的对应方式 left左对齐，right右对齐，center居中对齐</span><br><span class="line">        bgcolor：设置的是背景颜色  颜色单词，#十六进制的值</span><br><span class="line">        cellspacing：设置单元格间的间距</span><br><span class="line">        cellpadding： 设置单元格边框到内容的距离</span><br></pre></td></tr></table></figure><ul><li><p><label><inputtype="checkbox" />border:设置表格边框</label></p></li><li><p><label><inputtype="checkbox" />align：设置对齐方式</label></p></li><li><p>left</p></li><li><p>right</p></li><li><p>center</p></li><li><p>注意：table标签设置align控制表格在页面中的对齐方式，tr和td设置align控制的是</p><p>​ 单元格的内容在单元格的对齐方式</p><ul><li><p>bgcolor：背景颜色 优先级： td&gt;tr&gt;table</p></li><li><p>cellspacing: 设置单元格间的间距</p></li><li><p>cellpadding: 设置单元格边框到内容的距离</p></li></ul></li></ul></li></ul></li></ul></li><li><p>注意：</p><p>1.th标签代表表头，默认会进行加粗，文本居中显示</p><p>2.表格的基本结构，table里面只能放tr，tr里面只能放th或td</p><p>3.表格是可以相互嵌套的，注意里面的表格需要放在外面表格的单元格之中，不能破坏外面表格结构</p><h5 id="单元格合并">单元格合并：</h5><ul><li>rowspan：跨行合并，垂直方向上进行合并</li><li>colspan： 水平合并，水平方向上进行合并</li></ul></li></ul><h2 id="表单标签">表单标签</h2><ul><li>登录注册等需要进行数据交互的标签</li></ul><h4 id="普通输入框">普通输入框</h4><ul><li><h5 id="语法-1">语法</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;文本框中显示的提示信息&quot;</span> <span class="attr">value</span>=<span class="string">&quot;设置文本框中默认值&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="密码框">密码框</h4><ul><li><h5 id="语法-2">语法：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;passworld&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><ul><li>输入的内容是不可见的</li></ul></li></ul><h4 id="单选框">单选框</h4><ul><li><h5 id="语法-3">语法：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男 <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女 <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：</li><li>单选框需要设置相同的name值进行绑定</li><li>label的特殊用法：通过form属性指定对应的表单元素的id，就可以通过点击label中的内容控制对应的表单元素获取焦点</li></ul></li></ul><h4 id="复选框">复选框</h4><ul><li><h5 id="语法-4">语法：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>LOL</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>王者</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>开心消消乐</span><br></pre></td></tr></table></figure>注意：checke可以控制单选框或者多选框默认选中</li></ul><h4 id="下拉列表">下拉列表</h4><ul><li><h5 id="语法-5">语法：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">multiple</span>&gt;</span>身份证<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>驾驶证<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">selected</span>&gt;</span>学生证<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：下拉列表默认显示第一个选项，可以在option上设置select属性，控制默认显示的选项</p><p>默认下拉列表只能选中一个选项，可以在select标签上设置multiple属性控制多选</p></li></ul><h4 id="文本域">文本域</h4><ul><li><h5 id="语法-6">语法：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>cols:一行可以输入多少个字符<br /></li><li>rows：文本域可以显示几行可以变相控制文本域的宽高</li></ul></li></ul><h4 id="按钮">按钮</h4><ul><li><h4 id="语法-7">语法：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;普通按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>普通按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>重置按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>推荐使用button按钮</li><li>注意：重置和提交按钮需要配合form标签一起使用</li></ul></li></ul><h4 id="form标签">form标签</h4><ul><li><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;success.html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>action：设置提交数据的服务器地址</li><li>method：设置提交数据提交方式<ul><li>get：从服务器获取数据，也可以提交数据，但是数据会显示在窗口的地址栏</li><li>post：提交数据给服务器，数据不会显示在窗口的地址栏</li></ul></li></ul></li></ul><h2 id="列表标签">列表标签</h2><ul><li><h5 id="无序列表ul">无序列表ul</h5><ul><li><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：默认有16像素的margin padding-left有40px</p><p>​ ul里面只能放li标签</p><p>​ ul，li标签都是独占一行</p></li></ul></li><li><h5 id="有序列表">有序列表</h5><ul><li><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：有序列表ol 默认上下也有16px上下margin 有40px的padding-left</p><p>​ ol里只能发li标签</p><p>​ ol，li标签都是独占一行</p><p>有序列表和无序列表可以嵌套</p></li></ul></li><li><h5 id="定义列表">定义列表</h5><ul><li><p>语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>中华人民共和国<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>汽水<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>碳水化合物，冒着泡泡的肥宅水<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：dl：定义列表</p><p>​ dt：指定一个名词 dd：针对名词进行解释说明</p></li></ul></li></ul><h2 id="其他标签">其他标签：</h2><h5 id="div标签">div标签：</h5><ul><li><h5id="可以看作一个容器结构并且没有任何样式独占一行可以通过css自己设置">可以看作一个容器结构，并且没有任何样式，独占一行，可以通过CSS自己设置</h5></li><li><h5id="marquee标签跑马灯里面的内容从右边进入从左边滚动到左侧消失循环播放">marquee标签：跑马灯，里面的内容从右边进入，从左边滚动到左侧消失，，循环播放</h5></li><li>语法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">behavior</span>=<span class="string">&quot;&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;&quot;</span>&gt;</span>公告：明天周五不上晚自习<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="iframe-框架标签">iframe 框架标签</h5><ul><li><p>可以在网页中嵌套其他的网页，可以是在线服务器的网页，也可以是本地服务器的网页</p></li><li><p>语法：src内是需要嵌套的其他网页，可以是在线服务器的网页，也可以是本地服务器的网页</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.woniuxy.com&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;1000px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h5id="注意需要设置宽高如果宽高不够自动产生滚动条不赞成使用">注意：需要设置宽高，如果宽高不够，自动产生滚动条，不赞成使用</h5></li></ul><h5 id="删除线标签-del">删除线标签 del</h5><ul><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>$998<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="带边框的标签-fieldset">带边框的标签 fieldset</h5><ul><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置边框上的标题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">legend</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">            用户名： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">            密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode前端需要安装的插件&quot;&gt;1.vscode前端需要安装的插件&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Auto Rename Tag 自动将结尾标签进行更改&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HTML CSS Support 在html代码中支持css提示&lt;</summary>
      
    
    
    
    <category term="Html前端笔记" scheme="https://pipi1002.github.io/categories/Html%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>页面homework</title>
    <link href="https://pipi1002.github.io/2022/11/16/%E9%A1%B5%E9%9D%A2homework/"/>
    <id>https://pipi1002.github.io/2022/11/16/%E9%A1%B5%E9%9D%A2homework/</id>
    <published>2022-11-16T13:26:19.000Z</published>
    <updated>2023-01-02T04:32:01.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雪碧图应用">雪碧图应用</h1><ul><li><p>将多张图片组合在一起，形成一张图片，减少请求服务器的次数，优化网页</p></li><li><p>原理：通过背景样式background-image和background-position来实现雪碧图效果</p></li><li><p>步骤：</p><p>1.设置一个宽高刚好显示指定图标大小的标签（盒子）</p><p>2.通过background-image引入雪碧图</p><p>3.再通过background-position来实现雪碧图的显示位置，调整到指定图标</p></li><li><p>注意：在开发过程中，x轴的正方向是水平向右，y轴的正方向是垂直向下</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;雪碧图应用&quot;&gt;雪碧图应用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将多张图片组合在一起，形成一张图片，减少请求服务器的次数，优化网页&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原理：通过背景样式background-image和background-position来实现雪</summary>
      
    
    
    
    <category term="Html前端笔记" scheme="https://pipi1002.github.io/categories/Html%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS样式</title>
    <link href="https://pipi1002.github.io/2022/11/16/CSS%E6%A0%B7%E5%BC%8F/"/>
    <id>https://pipi1002.github.io/2022/11/16/CSS%E6%A0%B7%E5%BC%8F/</id>
    <published>2022-11-16T13:25:29.000Z</published>
    <updated>2023-01-02T04:33:19.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网页由三部分组成">网页由三部分组成：</h1><p>1.html ：网页架构骨架，网页结构的设计</p><p>2.CSS：网页的样式，用于美化网页，有了CSS才能达到像素级的还原</p><p>3.JavaScript：动态脚本，控制页面动画，点击事件</p><h2 id="css基本概念">CSS基本概念：</h2><p>css （Cascading StyleSheets）层叠样式表，主要控制网页样式显示。一般css样式是作用在标签上，控制的是标签显示的样式。</p><p>层叠：css样式可以在多个地方书写，可以在标签上添加style属性添加css样式代码，style标签中书写的，外部css文件中书写css代码，最终层叠在一起，形成一套css样式作用在标签上。相同的css属性只作用一个，不同的直接作用。</p><p>样式表：css的样式代码；页面上通过内联样式，内部样式，外部样式的方式属性css代码</p><h2 id="网页中样式的来源">网页中样式的来源</h2><p>注意：所有html默认没有样式</p><ul><li><h4 id="浏览器默认的样式不同">浏览器默认的样式不同</h4></li><li><p>所有的html标签默认没有样式，但是a，h标签等默认是浏览器添加的样式</p></li><li><h4 id="浏览器用户自定义的样式">浏览器用户自定义的样式</h4></li><li><p>用户可以在浏览器上更改默认标签的样式</p></li></ul><h3 id="内联样式">内联样式</h3><p>在标签上添加style属性，在属性值中书写css样式代码</p><ul><li>语法：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;css属性1:css属性1的值;css属性2:css属性2的值&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>好处：哪里需要样式写在哪</p></li><li><p>缺点：多个标签有相同的样式时需重复添加</p></li></ul><h3 id="内部样式">内部样式</h3><ul><li><p>在head标签添加style标签，再通过选择器书写css样式代码</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        选择器&#123;</span></span><br><span class="line"><span class="language-css">            css属性<span class="number">1</span>:css属性值<span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">            css属性<span class="number">2</span>:css属性值<span class="number">2</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>好处：</p><ul><li>​ 结构和样式分清了，利与后期代码维护</li><li>​ 可以批量选择标签中的标签样式</li></ul></li><li><p>缺点：</p><ul><li>样式和结构完全分离，目前还在一个文件中</li></ul></li></ul><h3 id="外部样式">外部样式</h3><ul><li><p>先创建一个后缀名为.css文件，再在里面通过选择器书写css样式代码，再在head标签中通过link标签引入css样式文件</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/01-外部样式.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>里面的href:链接css文件</p><ul><li><p>好处：</p><ul><li>样式和结构代码完全分离</li><li>以后维护代码可以一处改处处改</li><li>以后可以将css进行压缩，减少文件体积</li></ul></li><li><h4id="注意优先级相同的选择器内联内部外部-内部和外部的优先级是依据代码的先后就近原则">注意：优先级：相同的选择器，内联&gt;内部/外部，内部和外部的优先级是依据代码的先后（就近原则）</h4><h2 id="选择器">选择器</h2><h5id="相同选择器后面选择器会盖住前面选择器">相同选择器后面选择器会盖住前面选择器</h5><p>1.标签选择器：</p><ul><li>通过标签名找到指定的标签，没有指定范围的时候找到的是页面中所以满足条件的标签</li></ul><p>2.类选择器（class选择器）：</p><ul><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">css属性1：css属性值1；</span><br><span class="line">css属性2：css属性值2；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>又称为class标签，通过标签上class名找到满足条件的标签，多个标签可以共享一个class标签，可以提供公共标签样式</p></li><li><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class名&#123;</span><br><span class="line">css属性1：css属性值1；</span><br><span class="line">css属性2：css属性值2；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li><p>标签上可以作用多个class名，中间用空格隔开</p></li><li><p>如果选择器多个组合在一起，中间没有空格，代表并且的意思</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">找到页面中class名中即有op又有oa的标签</span><br><span class="line">.op.oa&#123;</span><br><span class="line">css样式代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>3.标签选择器</p><ul><li><p>id是标签上定义的属性，id唯一，找到页面中唯一的标签，精准定位</p></li><li><p>通过标签上id名找到满足条件的标签</p></li><li><p>id命名规则：</p><ul><li><p>以数字，字母，-和_构成</p></li><li><p>不能以数字开头</p></li><li><p>不能包含特殊符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#id名&#123;</span><br><span class="line">css样式代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：id是唯一的，以后通过js会操作标签上id名，id选择器慎用</p><p>优先级问题：</p><ul><li>相同选择器，内联样式权重最大，内部样式和外部样式采用就近原则</li><li>相同选择器同时作用在一个标签上，后面的样式会盖住前面的样式</li><li>选择器权重（优先级）：id选择器&gt;类选择器&gt;标签选择器</li></ul></li></ul></li></ul></li></ul><h2 id="背景样式">背景样式</h2><ul><li><p><code>background-color</code>：设置背景颜色</p><ul><li>单词（#开头的十六进制数字）</li><li>rgb（0<sub>255，0</sub>255，0~255）</li></ul></li><li><p><code>background-image</code>:设置背景图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSS</span><br><span class="line">background-image:url(链接背景图片的文件路径)</span><br></pre></td></tr></table></figure><ul><li>背景图片默认从盒子左上角开始铺设，如果铺不满默认平铺</li><li>注意：如果背景颜色和图片同时存在，图片盖住背景颜色</li></ul></li><li><p><code>background-repeat</code>:设置背景图片是否平铺</p><ul><li><code>repeat</code>：默认值，x轴，y轴都平铺</li><li><code>repeat-x</code>:x轴方向进行平铺</li><li><code>repeat-y</code>:y轴方向进行平铺</li><li><code>no-repeat</code>:不平铺</li><li>可以实现一个像素渐变背景平铺，减少图片的体积，从而优化网页</li></ul></li><li><p><code>background-position</code>:设置背景图片的显示位置</p><ul><li>x轴 y轴：<ul><li>单词：left right center top bottom 两两搭配使用</li><li>固定的像素值：默认左上角0px，0px</li><li>百分比：50%，50%相当于center center</li></ul></li></ul></li><li><p><code>background-size</code>:设置背景图片的大小，css3提出</p><ul><li><p><code>contain</code>：一边铺满，另一边铺满</p></li><li><p><code>cover</code>:两边都铺满，超出部分隐藏</p></li><li><pre><code>  x轴，y轴  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    :宽度，高度</span><br><span class="line"></span><br><span class="line">    - 同时设置两个值，背景图片样式可能变形，只设置一个值，代表图片的宽度</span><br><span class="line"></span><br><span class="line">- `background-attachment`:设置背景图片是否固定 css3提供</span><br><span class="line"></span><br><span class="line">  - score:默认值，图片会随着滚动条滚动</span><br><span class="line">  - fixed：背景图片固定在页面上</span><br><span class="line"></span><br><span class="line">- `background`:复合属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>CSSbackground:pink url(img/img-3.jpg) no-repeat 50% 50% /100px 100px fixed;</code></pre></li><li><p>/前面代表图片显示位置，/后面代表背景图片大小</p></li></ul></li></ul><h2 id="文本样式">文本样式</h2><ul><li><code>color</code>:设置文本的颜色</li><li><code>text-align</code>:设置文本的对齐方式<ul><li>left：左对齐</li><li>right：右对齐</li><li>center：中间居中</li></ul></li></ul><p>​ 注意：可以控制标签中文本在水平方向的对齐方式，对行级标签同样有效</p><ul><li><code>line-height</code>:设置文本行高</li></ul><p>​ 1.像素</p><p>​ 2.百分比和数字是参考字体的大小，相当于字体的倍数</p><p>​ 注意：一行里面的文本在垂直方向上居中</p><pre><code>                针对单行文本水平垂直居中，可以设置text-align，line-height等于盒子宽度</code></pre><ul><li><code>text-decoration</code>:<ul><li>none:无</li><li>underline：下划线</li><li>line-thorugh：中划线</li><li>overline：上划线</li></ul></li><li>letter-spacing:设置字符间距，一个中文就是一个字符，一个字母是一个字符</li><li>word-spacing:设置字间距，以空格为参考</li><li>text-indent:设置首行缩进</li><li>text-transform:设置英文字母大小写 capitalize：首字母大写uppercase：全部大写 lowercase：全部小写</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网页由三部分组成&quot;&gt;网页由三部分组成：&lt;/h1&gt;
&lt;p&gt;1.html ：网页架构骨架，网页结构的设计&lt;/p&gt;
&lt;p&gt;2.CSS：网页的样式，用于美化网页，有了CSS才能达到像素级的还原&lt;/p&gt;
&lt;p&gt;3.JavaScript：动态脚本，控制页面动画，点击事件</summary>
      
    
    
    
    <category term="Html前端笔记" scheme="https://pipi1002.github.io/categories/Html%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C-CProject</title>
    <link href="https://pipi1002.github.io/2022/11/16/C-C/"/>
    <id>https://pipi1002.github.io/2022/11/16/C-C/</id>
    <published>2022-11-16T13:25:12.000Z</published>
    <updated>2023-01-05T05:10:04.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="猜数字游戏">猜数字游戏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##########################\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;###     1.play   0.exit      ###\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;##########################\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RAND_MAX-32767</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.生成一个随机数</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> guess = <span class="number">0</span>;<span class="comment">//接收猜的数字</span></span><br><span class="line">    <span class="comment">//拿时间戳来设置随机数的生成起始点</span></span><br><span class="line">    <span class="comment">//time_t time(time_t *timer)</span></span><br><span class="line">    <span class="comment">//time_t</span></span><br><span class="line">    ret = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>;<span class="comment">//生成随机数1到100之间的随机数（一个数被%，只会等于一个1到99的数）</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;,ret);</span></span><br><span class="line">    <span class="comment">//2.猜数字</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请猜数字：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">        <span class="keyword">if</span> (guess &gt; ret)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜大了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (guess &lt; ret)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;猜小了\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;恭喜你！！！猜中了\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> input = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//在工程里只需要调用一次</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">menu</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请选择:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">        <span class="keyword">switch</span> (input)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">game</span>();<span class="comment">//猜数字游戏</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;退出游戏\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;选择错误\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;猜数字游戏&quot;&gt;猜数字游戏&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>C-Ctext</title>
    <link href="https://pipi1002.github.io/2022/11/16/C-Ctext/"/>
    <id>https://pipi1002.github.io/2022/11/16/C-Ctext/</id>
    <published>2022-11-16T13:25:12.000Z</published>
    <updated>2023-11-14T11:40:30.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cc的学习text">C/C++的学习TEXT</h1><h2id="避免累积乘的问题for循环嵌套">避免累积乘的问题（for循环嵌套）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//1的阶乘，加2的阶乘，加3的阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, ret, i, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= <span class="number">3</span>; n++)</span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="number">1</span>;<span class="comment">//为了避免累积乘的现象出现，这一步必须要有</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ret = ret * i;</span><br><span class="line">&#125;</span><br><span class="line">sum = sum + ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辗转相除法">辗转相除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//辗转相除法求两个数的最大公约数，和最小公倍数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, m, n, r;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter m,n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">a = m;</span><br><span class="line">b = n;</span><br><span class="line"><span class="keyword">while</span> (m % n)<span class="comment">//如果m%n=0，自动跳出循环</span></span><br><span class="line">&#123;</span><br><span class="line">r = m % n;</span><br><span class="line">m = n;</span><br><span class="line">n = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最大公约数=%d\n&quot;</span>, n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最小公倍数=%d\n&quot;</span>, a * b / n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闰年计算方法">闰年计算方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> year = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (year = <span class="number">1000</span>; year &lt;= <span class="number">2000</span>; year++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//if((year%4==0)&amp;&amp;(year%100!=0))||(year%400==0))</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, year);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, year);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\ncount=%d\n&quot;</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数规则试除法1不是素数">素数：（规则）试除法,1不是素数</h2><p>素数只能被1和它本身整除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印100到200间的素数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">//判断i是否为素数</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">100</span>; i &lt;= <span class="number">200</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//此时有两种情况都可以跳出循环，要把它们分离开来</span></span><br><span class="line"><span class="keyword">if</span> (j == i)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\ncount= %d\n&quot;</span>, count);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从键盘输入一个大于2的整数m，判断m是不是素数（）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k,m,i;</span><br><span class="line">    <span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">&quot;%d&quot;</span>,&amp;m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(m&lt;=<span class="number">2</span>);</span><br><span class="line">    k=(<span class="type">int</span>)<span class="built_in">sqrt</span>(m);<span class="comment">//从算法上考虑，为了减少重复量，开平方后面的数就不用相除了</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">        <span class="keyword">if</span>(m%i==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=k)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is not a prime number\n&quot;</span>,m);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a prime number\n&quot;</span>,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印1到100内包含九的数字">打印1到100内包含九的数字：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;   <span class="comment">//如果十位数有9，那么这个数除10就会等于9，如果个位数有9，那么这个数取余%10就会等于9</span></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">9</span>)</span><br><span class="line">            count ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i/<span class="number">10</span>==<span class="number">9</span>)</span><br><span class="line">            count ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;count=%d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="打印112-1314...991-1001的值">打印1+1/2-1/3+1/4+...+99/1-100/1的值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;<span class="comment">//flage相当于正负号</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        sum+=flag*<span class="number">1.0</span>/i;</span><br><span class="line">        flag=-flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="打印九九乘法口诀表典型循环嵌套">打印九九乘法口诀表（典型循环嵌套）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="comment">//确定打印九行</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">    &#123;<span class="comment">//打印一行</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%-3d&quot;</span>,i,j,i*j);<span class="comment">//-3d不够三位左空格补齐</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找">二分查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">7</span>;<span class="comment">//k为要找的数</span></span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">    <span class="type">int</span> sz=<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span> (arr[<span class="number">0</span>]);<span class="comment">//计算元素个数</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;      <span class="comment">//左下标</span></span><br><span class="line">    <span class="type">int</span> right=sz<span class="number">-1</span>   <span class="comment">//右下标</span></span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[mid]&gt;k)<span class="comment">//要找的元素在中间元素左边，左下标不变，右下标变为mid-1</span></span><br><span class="line">      &#123;</span><br><span class="line">        right=mid<span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&lt;k)<span class="comment">//要找的元素在中间元素右边，右下标不变，左下标变成mid+1</span></span><br><span class="line">      &#123;</span><br><span class="line">        left=mid+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">else</span>(arr[mid]==k)</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;找到了，下标为：%d&quot;</span>,mid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找不到&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计一个函数，实现二分查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//二分查找：在一个有序数组中查找具体某一个数，如果找到了就返回这个数的下标，找不到返回-1</span></span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="built_in">binary_search</span>(arr,k);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找不到指定的数字\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，下表是：%d\n&quot;</span>,ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="char函数的使用">char()函数的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘上连续输入字符，并统计其中大写字母的个数直到“换行”字符结束</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch=<span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;   <span class="comment">//只能终止他所在的循环体</span></span><br><span class="line">        <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">           sum++;</span><br><span class="line">    &#125;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入一行字符，分别统计出其中的英文字母，空格，数字和其他字符的个数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> letter=<span class="number">0</span>,big=<span class="number">0</span>,space=<span class="number">0</span>,digit=<span class="number">0</span>,other=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入需要统计的字段:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((c=<span class="built_in">getchar</span>())!=<span class="string">&#x27;\n&#x27;</span>)<span class="comment">//到回车才结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            letter++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;<span class="string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            big++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            digit++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            other++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;小写=%d\n大写=%d\n空格=%d\n数字=%d\n其它=%d&quot;</span>,letter,big,space,digit,other);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有三行文字的文章，每行有80个字符，分别统计中英文大写字母，小写字母，数字，空格以及其他字符的个数（二维 ）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图案打印">图案打印</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//菱形从上到下a,b,c,d,e,f,g</span></span><br><span class="line">   <span class="function">a</span></span><br><span class="line"><span class="function">  bbb</span></span><br><span class="line"><span class="function"> ccccc</span></span><br><span class="line"><span class="function">ddddddd</span></span><br><span class="line"><span class="function"> eeeee</span></span><br><span class="line"><span class="function">  fff</span></span><br><span class="line"><span class="function">   g</span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> i,j;</span><br><span class="line">       <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">5</span>-i;j++)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">2</span>*i<span class="number">-1</span>;j++)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           c=c+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">           <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">9</span><span class="number">-2</span>*i;j++)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,c);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">           c=c+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2id="写一个函数每次调用一次这个函数就会将num的值加1">写一个函数，每次调用一次这个函数，就会将num的值加1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//*p++;//++的优先级比较高，++是作用于p的，不是作用于*p的，所以这样写代码是错误的</span></span><br><span class="line">    (*p)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Add</span>(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">Add</span>(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);<span class="comment">//2</span></span><br><span class="line">    <span class="built_in">Add</span>(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="编写一个程序加密输出字符数组应用举例">编写一个程序，加密输出(字符数组应用举例)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加密规则：所有的大写英文字母加三，小写英文字母减三，其他字符不变。</span></span><br><span class="line"><span class="comment">//注意：特殊的X，Y，Z这三个大写英文字母直接加三不能使其正确加密，所以加密后让X为A，Y为B，Z为C；同理x,y,z使其为a,b,c.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch,str1[<span class="number">81</span>],str2[<span class="number">81</span>];<span class="comment">//字符数组最大为81，防止溢出</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">get</span>(str1);<span class="comment">//get函数可以输入包括空格的字符</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str2,str1);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;(ch=str2[i])!=<span class="string">&#x27;\n&#x27;</span>;i++)<span class="comment">//(ch=str2[i])!=&#x27;\0&#x27;代表一直执行直到遇到\0</span></span><br><span class="line">        <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">            str2[i]+=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;X&#x27;</span>||ch==<span class="string">&#x27;Y&#x27;</span>||ch==<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            str2[i]-=<span class="number">23</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch&gt;=<span class="string">&#x27;d&#x27;</span>||ch&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            str2[i]-=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">&#x27;a&#x27;</span>||ch==<span class="string">&#x27;b&#x27;</span>||ch==<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            str2[i]+=<span class="number">23</span>;</span><br><span class="line">    str2[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原串是:%s\n&quot;</span>,str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加密后的串是:%s\n,str2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="魔方阵基数鞍点flag的运用">魔方阵（基数）/鞍点（flag的运用）</h2><ul><li><h4id="魔方阵是指组成元素为自然数12...n的平方的nn的方阵其中每个元素值都不相等且每行每列以及主副对角线上各n个元素之和都相等的排列规律">魔方阵（是指组成元素为自然数1，2...n的平方的n×n的方阵，其中每个元素值都不相等，且每行，每列以及主副对角线上各n个元素之和都相等）的排列规律：</h4></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>  <span class="number">1</span>  <span class="number">6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">5</span>  <span class="number">7</span></span><br><span class="line"><span class="number">4</span>  <span class="number">9</span>  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>,先给备用数组内所有数赋初值<span class="number">0</span>;(下面的i代表行号，j代表列号)(第<span class="number">1</span>步是为第<span class="number">7</span>步做铺垫)</span><br><span class="line"><span class="number">2</span>,第<span class="number">0</span>行的中间那个数a[i][j]=<span class="number">0</span>,此时i = <span class="number">0</span>,j = n/<span class="number">2</span>;</span><br><span class="line"><span class="number">3</span>,当前的数在首行(i=<span class="number">0</span>)时，下一个数放在最后一行(i=n<span class="number">-1</span>)，j++;</span><br><span class="line"><span class="number">4</span>,当前的数在最后一列(j=n<span class="number">-1</span>)时，下一个数放在第一列(j=<span class="number">0</span>)，i--;</span><br><span class="line"><span class="number">5</span>,如果同时满足了(i=<span class="number">0</span>和j=n<span class="number">-1</span>)，那么进行i=n<span class="number">-1</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="number">6</span>,如果<span class="number">3.4</span><span class="number">.5</span>都不满足，就进行i--,j++;</span><br><span class="line"><span class="number">7</span>,经过上面<span class="number">3</span>步的判断，找到了新的i和j的值，如果此时a[i][j]放的值是<span class="number">0</span>，代表这地方未被用过，可放下一个数；</span><br><span class="line">如果此时这里放的不是<span class="number">0</span>，代表已经被用过了，那么下一个数就直接放到这个数的前面那个数的的下面（比如本例n=<span class="number">3</span>时：<span class="number">4</span>本该放到a[<span class="number">0</span>][<span class="number">1</span>]的，但a[<span class="number">0</span>][<span class="number">1</span>]被<span class="number">1</span>占了，所以，就直接把<span class="number">4</span>放到<span class="number">4</span>的前面那个数<span class="number">3</span>的下面。）</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> i,j,ok,n,m;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)                   <span class="comment">/*给备用的数组做初始化*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; <span class="number">10</span>;j++)</span><br><span class="line">a[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ok = <span class="number">0</span>;                                  <span class="comment">/*限定输入的数必须满足要求*/</span></span><br><span class="line"><span class="keyword">while</span>(ok == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please input a number as the value of n:(必须是10以内的奇数)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">10</span> )</span><br><span class="line">ok = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ok = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = n/<span class="number">2</span>;</span><br><span class="line">a[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(m = <span class="number">2</span>;m &lt;= n*n;m++)                  <span class="comment">/*因为1已经放好了，所以我们从2开始放*/</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>((i == <span class="number">0</span>) &amp;&amp; (j != n<span class="number">-1</span>))            <span class="comment">/*算法中的第3步*/</span></span><br><span class="line">&#123;</span><br><span class="line">i = n<span class="number">-1</span>;</span><br><span class="line">j = j+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)                  <span class="comment">/*算法中的第7步*/</span></span><br><span class="line">a[i][j] = m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = j - <span class="number">1</span>;</span><br><span class="line">a[i][j] = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((i != <span class="number">0</span>) &amp;&amp; (j == n<span class="number">-1</span>))      <span class="comment">/*算法中的第4步*/</span></span><br><span class="line">&#123;</span><br><span class="line">i = i<span class="number">-1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)                <span class="comment">/*算法中的第7步*/</span></span><br><span class="line">a[i][j] = m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">j = n - <span class="number">1</span>;</span><br><span class="line">a[i][j] = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>((i == <span class="number">0</span>) &amp;&amp; (j == n<span class="number">-1</span>))       <span class="comment">/*算法中的第5步*/</span></span><br><span class="line">&#123;</span><br><span class="line">i = n<span class="number">-1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)                 <span class="comment">/*算法中的第7步*/</span></span><br><span class="line">a[i][j] = m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = n - <span class="number">1</span>;</span><br><span class="line">a[i][j] = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span>                                 <span class="comment">/*算法中的第6步*/</span></span><br><span class="line">&#123;</span><br><span class="line">i = i<span class="number">-1</span>;</span><br><span class="line">j = j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">0</span>)                 <span class="comment">/*算法中的第7步*/</span></span><br><span class="line">a[i][j] = m;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">i = i + <span class="number">2</span>;</span><br><span class="line">j = j - <span class="number">1</span>;</span><br><span class="line">a[i][j] = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d阶魔方阵:\n&quot;</span>,n);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)                        <span class="comment">/*输出数组*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Fritie」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/leipinyuan/article/details/79090126</span></span><br></pre></td></tr></table></figure><ul><li><h4 id="鞍点flag的用法">鞍点flag的用法</h4><ul><li><h6id="鞍点在二维矩阵中鞍点是在它所在这一行的最大在列上是最小的">鞍点：在二维矩阵中,鞍点是在它所在这一行的最大，在列上是最小的</h6></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//当需要多次更换矩阵的时候可以定义符号常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入数组</span></span><br><span class="line">    <span class="type">int</span> i,j,a[M][N],hangmax,hangmax_j,k,flag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请依次输入%d*%d的数组元素：\n&quot;</span>,M,N);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="comment">//打印数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组如下:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%6d&quot;</span>,&amp;a[i][j]);<span class="comment">//6d控制格式，因为有单位也有双位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hangmax=a[i][j];<span class="comment">//先假设第i行的第一个数是最大数</span></span><br><span class="line">        <span class="comment">//比较第i行哪个数最大</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&gt;hangmax)</span><br><span class="line">            &#123;</span><br><span class="line">                hangmax=a[i][j];</span><br><span class="line">                hangmax_j=j;<span class="comment">//这里必须有变量来接受最大数的纵下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较第i行最大值是不是在所在列中最小</span></span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;M;k++)<span class="comment">//设新变量k，因为是在一行行比较的大环境下</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k][hangmax_j]&lt;hangmax)<span class="comment">//这一行的hangmax就不是鞍点</span></span><br><span class="line">                <span class="comment">//标志变量的使用，触发flag，锁定鞍点位置</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)<span class="comment">//如果flag=1，表示有鞍点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;鞍点是：a[%d][%d]=%d&quot;</span>,i,hangmax_j,max);</span><br><span class="line">            <span class="comment">//二维数组只有一个鞍点，或没有鞍点</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//这里break的作用：防止flag==0被反复执行，因为有可能第一行存在鞍点之后行数不存在鞍点，那么就为flag=0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该数组不存在鞍点&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印100到200之间的素数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//拿2到n-1的数来进行试除</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%j==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//直接结束函数，不执行这个函数下面的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if(j==n)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">100</span>;i&lt;<span class="number">200</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断i是不是素数</span></span><br><span class="line">        <span class="comment">//规定不是素数返回0;是素数返回1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_prime</span>(i)==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="将字符串中ascii码值最大的放在最前面">将字符串中ASCII码值最大的放在最前面，</h2><h2id="并使该字符前的原字符顺次向后移动">并使该字符前的原字符顺次向后移动。</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 30</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[M];</span><br><span class="line"><span class="type">int</span> i,max,max_i;</span><br><span class="line"><span class="comment">//输入数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enter a string:&quot;</span>);</span><br><span class="line"><span class="built_in">gets</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n the original string:&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">max = str[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;i&lt;M; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] &gt; max)</span><br><span class="line">&#123;</span><br><span class="line">max = str[i];</span><br><span class="line">max_i = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//不能这样写的原因是如果输入pipiwrr，结果是wpppprr，会覆盖结果</span></span><br><span class="line"><span class="comment">/*for (i = 0; i &lt; max_i; i++)</span></span><br><span class="line"><span class="comment">str[i + 1] = str[i];*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=max_i;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        str[i+<span class="number">1</span>]=str[i];</span><br><span class="line">str[<span class="number">0</span>] = max;</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡法排序">冒泡法排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入一个正整数n(1&lt;n&lt;=10),再输入n个整数，按绝对值从小到大排序后输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[N] = &#123;<span class="number">0</span>&#125;,n,i,j,max;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入多少个正整数n:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="comment">//打印一遍</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打印这个数组:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)<span class="comment">//冒泡法重点在于趟数与数字数的关系，趟数等于数字数减一</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">max = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = max; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排列后的顺序:\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序数组中的数字(cong&#x27;x)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确定冒泡排序的趟数</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>;<span class="comment">//假设这一趟要排序的数据已经有序</span></span><br><span class="line">        <span class="comment">//每一趟冒泡排序</span></span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;sz<span class="number">-1</span>-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">                flag=<span class="number">0</span>;<span class="comment">//本躺排序的数据其实不完全有序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sz=<span class="built_in">sizeof</span>(arr)/<span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//对arr进行排序，排成升序</span></span><br><span class="line">    <span class="comment">//arr是数组，我们对数组进行传参，真实传递过去的并不是数组本身，而是首元素的地址 &amp;arr[0]</span></span><br><span class="line">    <span class="built_in">bubble_sort</span>(arr);<span class="comment">//冒泡排序函数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杨辉三角形要求打印十行">杨辉三角形(要求打印十行)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 11</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,a[N][N];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)<span class="comment">//贴切生活，从第一行开始而不从0行开始,列也是如此</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i][i]=<span class="number">1</span>;</span><br><span class="line">        a[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;N;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">            a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;杨辉三角形:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="求周边数组元素之和4行5列">求周边数组元素之和(4行5列)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[M][N]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>&#125;&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;<span class="comment">//根据需求可以更换数组元素</span></span><br><span class="line">    <span class="type">int</span> i,j,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)<span class="comment">//打印数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N;j++)<span class="comment">//第一行数组元素加上最后一行数组元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        s=s+a[<span class="number">0</span>][j];</span><br><span class="line">        s+=a[M<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;M<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=a[i][<span class="number">0</span>];<span class="comment">//打印最左边去掉第一行和最后一行的数组元素</span></span><br><span class="line">        s+=a[i][N<span class="number">-1</span>];<span class="comment">//打印最右行去掉第一行和最后一行的数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除有序数组中的相同数">删除有序数组中的相同数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 15</span></span><br><span class="line"><span class="built_in">main</span>()<span class="comment">//第一种方法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k=<span class="number">0</span>,b=[N];<span class="comment">//将排除过相同数的数组填到数组b中</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">15</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[k]=a[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;N;j++)<span class="comment">//如果后一个数组元素和前一个不等就把这两个数分别赋给b数组的两个数组元素；如果后一个数组等于前一个数组元素，那么把这两个数组元素赋给b数组的同一个数组元素</span></span><br><span class="line">            <span class="keyword">if</span>(a[i]!=a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//跳出内层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//else和离它最近的没有匹配的if进行匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()<span class="comment">//第二种方法，自认为好理解</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,k=<span class="number">0</span>,n=<span class="number">0</span>,b[N];</span><br><span class="line">    <span class="type">int</span> a[N]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)<span class="comment">//如果后一个数组元素和前一个不等就把这两个数分别赋给b数组的两个数组元素；如果后一个数组等于前一个数组元素，那么把这两个数组元素赋给b数组的同一个数组元素   和第一种方法思想差不多，就是程序书写不一样</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[i+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            b[k]=a[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>,b[i]);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&quot;%6d&quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="设计一个函数输入一个4位数字要求输出这4个数字字符但每两个数字间空一个空格例如输入1990应输入1-9-9-0">设计一个函数，输入一个4位数字，要求输出这4个数字字符，但每两个数字间空一个空格。例如，输入1990，应输入“19 9 0”</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">81</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;input four digits:\n&quot;</span>);</span><br><span class="line"><span class="built_in">gets</span>(str);<span class="comment">//录入数组元素</span></span><br><span class="line"><span class="built_in">insert</span>(str);<span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;output digits after insert space:\n&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);<span class="comment">//输出更改过后的数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="built_in">strlen</span>(str); i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">str[<span class="number">2</span> * i] = str[i];<span class="comment">//把数字放在下标为0，2，4，6这几个数组元素中</span></span><br><span class="line">str[<span class="number">2</span> * i - <span class="number">1</span>] = <span class="string">&#x27; &#x27;</span>;<span class="comment">//把空格放在下标为1，3，5，7的数组元素中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="置换一个字符串中的字符eg.werty置换成ytrew">置换一个字符串中的字符eg.werty置换成ytrew</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 5<span class="comment">//定义大小最好定义大一点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> j, k;</span><br><span class="line"><span class="type">char</span> temp;</span><br><span class="line">k = <span class="built_in">strlen</span>(a) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= k; j++)<span class="comment">//第一个和最后一个互换，第二个和倒数第二个互换...</span></span><br><span class="line">&#123;</span><br><span class="line">temp = a[j];</span><br><span class="line">a[j] = a[k];</span><br><span class="line">a[k] = temp;</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a[M];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;置换前的字符串:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a);<span class="comment">//直接打印一个字符串</span></span><br><span class="line"><span class="built_in">fun</span>(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;置换后的字符串:\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="描述第n个斐波那契数函数的递归与迭代">描述第n个斐波那契数(函数的递归与迭代)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1  1  2  3  5  8  13  21  34  55... </span></span><br><span class="line"><span class="comment">/*用递归来写效率非常低</span></span><br><span class="line"><span class="comment">int Fib()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(n&lt;=2)</span></span><br><span class="line"><span class="comment">        return 1;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        return Fib(n-1)+Fib(n-2)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//用迭代来写,用三个变量不断赋值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fib</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;<span class="comment">//前两个斐波那契数</span></span><br><span class="line">    <span class="type">int</span> b=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">1</span>;<span class="comment">//如果求前两个斐波那契数，直接return 1，不进循环</span></span><br><span class="line">    <span class="comment">//只有从第三个数开始才用这个方法</span></span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c=a+b;</span><br><span class="line">        a=b;</span><br><span class="line">        b=c;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="comment">//递归方法：</span></span><br><span class="line">    <span class="comment">//Fib&lt;=2时为1</span></span><br><span class="line">    <span class="comment">//Fib&gt;2时为Fib(n-1)+Fib(n-2)</span></span><br><span class="line">    ret=<span class="built_in">Fib</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret=%d\n&quot;</span>,ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汉诺塔问题">汉诺塔问题</h2><h4id="三个柱子第一个上面有几个从小到大的圆盘要求按原顺序移动到另一个柱子上一次只能挪1个最少需要几步">(三个柱子，第一个上面有几个从小到大的圆盘，要求按原顺序移动到另一个柱子上，一次只能挪1个，最少需要几步？)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 青蛙跳台问题</span><br><span class="line"></span><br><span class="line">#### (n个台阶，<span class="number">1</span>次可以跳一个台阶，也可以跳两个台阶，这只青蛙要跳到第n个台阶上，有多少种跳法）</span><br><span class="line"></span><br><span class="line">## 用人民币一元兑换<span class="number">1</span>分，<span class="number">2</span>分，<span class="number">5</span>分硬币，共有多少种不同换法</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c1, c2, c5, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1元硬币有以下兑换方法：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(c1=<span class="number">0</span>;c1&lt;=<span class="number">100</span>;c1++)</span><br><span class="line"><span class="keyword">for</span>(c2=<span class="number">0</span>;c2&lt;=<span class="number">50</span>;c2++)</span><br><span class="line"><span class="keyword">for</span>(c5=<span class="number">0</span>;c5&lt;=<span class="number">20</span>;c5++)</span><br><span class="line"><span class="keyword">if</span> (c1 * <span class="number">1</span> + c2 * <span class="number">2</span> + c5 * <span class="number">5</span> == <span class="number">100</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3d个1分硬币，%3d个2分硬币，%3d个5分硬币\n&quot;</span>, c1, c2, c5);</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;共有%d种方法\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="请编写函数将含有数字的字符串实现将字符串中从左至右的数字提出并按提出顺序组成一个新的整型数据-要求使用字符数组和字符指针来实现">请编写函数,将含有数字的字符串,实现将字符串中从左至右的数字提出并按提出顺序组成一个新的整型数据。(要求使用字符数组和字符指针来实现)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t,s=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (*p)  </span><br><span class="line">&#123;<span class="keyword">if</span> ((*p)&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp;(*p)&lt;=<span class="string">&#x27;9&#x27;</span>)  </span><br><span class="line">  &#123;</span><br><span class="line">    t=(*p)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s=s*<span class="number">10</span>+t;  <span class="comment">//*10的目的，让数组中的数字，从大到小依次对于这个新的整形数据的各十百千...位</span></span><br><span class="line">  &#125; </span><br><span class="line">p++;&#125; </span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">80</span>]; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入一串含有数字的字符串:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">gets</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;字符串%s中的数字字符组成的整数为:\n&quot;</span>,s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">find</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="输入一个八进制数字字符串函数convert将其转换成十进制数后输出">输入一个八进制数字字符串，函数convert将其转换成十进制数后输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">convert</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">0</span>,a[<span class="number">6</span>]; </span><br><span class="line">    <span class="keyword">while</span>(*p) </span><br><span class="line">    &#123; </span><br><span class="line">      n=n*<span class="number">8</span>+*p-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//进制转换 </span></span><br><span class="line">      p++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个8进制数字的字符串: &quot;</span>);</span><br><span class="line"><span class="built_in">gets</span>(s);</span><br><span class="line">a=<span class="built_in">convert</span>(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*采用的具体方法是余除法，例如八进制数12，取余分解出最低位为2，再乘以相应的权重，由于是最低位，所以权重是8的0次方=1；再用12/10，进行下一轮循环，取余分解出最低位1，再乘以相应的权重，权重为8的一次方=8，累加起来为2+8=10，所以相对于的十进制数为10*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Trans</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=(n%<span class="number">10</span>)*<span class="built_in">pow</span>(<span class="number">8</span>,i++);</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转化为十进制数为:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">Trans</span>(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="调用函数用指针实现将某字符串复制到一个空字符串的功能要求在主函数中输入字符串并输出复制后的结果">调用函数用指针实现将某字符串复制到一个空字符串的功能（要求在主函数中输入字符串，并输出复制后的结果）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *t++=*s++;<span class="comment">//使每个数组元素都复制到空zi&#x27;fu</span></span><br><span class="line">    &#125;</span><br><span class="line">    *t=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//使复制完成后以\0结尾，方便打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">100</span>],s2[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input s1:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">gets</span>(s1);</span><br><span class="line">    <span class="built_in">fun</span>(s1,s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 is %s\n&quot;</span>,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2id="输出1到100之内共有多少个完数完数是指一个数的因子之和等于这个数本身例如6123-那么6就是一个完数">输出1到100之内共有多少个完数（完数是指一个数的因子之和等于这个数本身，例如6=1+2+3那么6就是一个完数）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,x,sum=<span class="number">0</span>,n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=N;x++)<span class="comment">//检测1到100之内的数，x是要检测的数，n是1到100中完数的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum=<span class="number">0</span>;<span class="comment">//每次循环都要归零</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;x;i++)<span class="comment">//用i试除看此时的i是不是x的因数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)<span class="comment">//说明此时i是x的因数</span></span><br><span class="line">                sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==sum)<span class="comment">//判断因字数之和等不等于其本身(注意这个if条件语句的位置)</span></span><br><span class="line">            n++;</span><br><span class="line">    &#125;</span><br><span class="line">    returm n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>,M=<span class="number">100</span>; <span class="function"><span class="type">void</span> <span class="title">NONO</span><span class="params">()</span></span>;</span><br><span class="line">  sum=<span class="built_in">fun</span>(M);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;共有完数个数为:%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pi的估算">pi的估算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//1+1*1/3+1*1/3*2/5+...</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> s=<span class="number">2.0</span>,t=<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(t&gt;<span class="number">1e-16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t=t*i/j;</span><br><span class="line">        s=s+t;</span><br><span class="line">        i++;</span><br><span class="line">        j=j+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi=%.10lf\n&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;cc的学习text&quot;&gt;C/C++的学习TEXT&lt;/h1&gt;
&lt;h2
id=&quot;避免累积乘的问题for循环嵌套&quot;&gt;避免累积乘的问题（for循环嵌套）&lt;/h2&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="C语言基础笔记" scheme="https://pipi1002.github.io/categories/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
